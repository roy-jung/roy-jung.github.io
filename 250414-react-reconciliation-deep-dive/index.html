<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>React Reconciliation: 컴포넌트 뒤에 숨겨진 엔진 | FE재남</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="http://roy-jung.github.io/250414-react-reconciliation-deep-dive/"/>
<meta name="description" content="원문: React Reconciliation: The Hidden Engine Behind Your Components   조정 엔진(Reconciliation Engine) 이전 글들(1, 2)에서 React.memo의 작동 방식과 컴포지션을…">
<meta property="og:type" content="article">
<meta property="og:title" content="React Reconciliation: 컴포넌트 뒤에 숨겨진 엔진">
<meta property="og:url" content="http://roy-jung.github.io/250414-react-reconciliation-deep-dive/">
<meta property="og:site_name" content="FE재남">
<meta property="og:description" content="원문: React Reconciliation: The Hidden Engine Behind Your Components   조정 엔진(Reconciliation Engine) 이전 글들(1, 2)에서 React.memo의 작동 방식과 컴포지션을…">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="http://roy-jung.github.io/images/React%20Reconciliation%20Engine.webp">
<meta property="article:published_time" content="2025-04-14T13:52:41.000Z">
<meta property="article:modified_time" content="2025-04-23T05:25:52.302Z">
<meta property="article:author" content="Jaenam Jung">
<meta property="article:tag" content="React.js">
<meta property="article:tag" content="번역">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://roy-jung.github.io/images/React%20Reconciliation%20Engine.webp"><meta property="article:author" content="Jaenam Jung"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2025-04-14 22:52:41"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="Jaenam Jung"><link rel="icon" href="/images/logo.png"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="FE재남"><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/logo.png" alt="FE재남"><span class="menu__item__link--brand__label">FE재남</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">React Reconciliation: 컴포넌트 뒤에 숨겨진 엔진</h1><div class="article__meta"><time class="article__meta__time" datetime="2025-04-14T13:52:41.000Z" itemprop="datePublished">2025-04-14 22:52:41</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/fe/">FE</a><span class="article__meta__categories__separator">></span><a class="article__meta__categories__item" href="/categories/fe/react-js/">React.js</a></div></div><div class="article__contents"><img src="/images/React Reconciliation Engine.webp"/><blockquote>
<p>원문: <a target="_blank" rel="noopener" href="https://cekrem.github.io/posts/react-reconciliation-deep-dive/">React Reconciliation: The Hidden Engine Behind Your Components</a></p>
</blockquote>
<!-- ## The Reconciliation Engine -->
<h2 id="조정-엔진-Reconciliation-Engine"><a href="#조정-엔진-Reconciliation-Engine" class="headerlink" title="조정 엔진(Reconciliation Engine)"></a>조정 엔진(Reconciliation Engine)</h2><!-- In my previous articles ([1](//posts/beyond-react-memo-smarter-performance-optimization/), [2](/posts/react-memo-when-it-helps-when-it-hurts/)), I explored how `React.memo` works and smarter ways to optimize performance through composition. But to truly master React performance, we need to understand the engine that powers it all: React's reconciliation algorithm. -->
<p>이전 글들(<a target="_blank" rel="noopener" href="https://cekrem.github.io/posts/beyond-react-memo-smarter-performance-optimization/">1</a>, <a target="_blank" rel="noopener" href="https://cekrem.github.io/posts/react-memo-when-it-helps-when-it-hurts/">2</a>)에서 <code>React.memo</code>의 작동 방식과 컴포지션을 활용한 성능 최적화 방법을 살펴보았습니다. 하지만 리액트 성능을 제대로 정복하기 위해서는 리액트의 핵심 엔진, 즉 조정(Reconciliation) 알고리즘을 깊이 이해해야 합니다.</p>
<!-- Reconciliation is the process by which React updates the DOM to match your component tree. It's what makes React's declarative programming model possible - you describe what you want, and React figures out how to make it happen efficiently. -->
<p>조정은 리액트가 DOM을 컴포넌트 트리와 일치하도록 업데이트하는 과정입니다. 이를 통해 리액트의 선언형 프로그래밍 모델이 가능해집니다. 개발자가 원하는 결과를 선언적으로 기술하면, 리액트가 이를 효율적으로 구현하는 방법을 찾아 적용하는 것입니다.</p>
<!-- ## Component Identity and State Persistence -->
<h2 id="컴포넌트-정체성-Identity-과-상태-유지-State-Persistence"><a href="#컴포넌트-정체성-Identity-과-상태-유지-State-Persistence" class="headerlink" title="컴포넌트 정체성(Identity)과 상태 유지(State Persistence)"></a>컴포넌트 정체성(Identity)과 상태 유지(State Persistence)</h2><!-- Before diving into the technical details, let's explore a surprising behavior that reveals how React thinks about component identity. -->
<p>우선, 리액트가 컴포넌트 정체성을 어떻게 다루는지 보여주는 흥미로운 동작을 살펴보겠습니다.</p>
<!-- Consider this simple text input toggle example: -->
<p>다음은 텍스트 인풋을 토글하는 간단한 예제입니다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">UserInfoForm</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [isEditing, setIsEditing] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;form-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setIsEditing(!isEditing)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        &#123;isEditing ? &quot;Cancel&quot; : &quot;Edit&quot;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      &#123;isEditing ? (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">placeholder</span>=<span class="string">&quot;Enter your name&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">className</span>=<span class="string">&quot;edit-input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">      ) : (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">placeholder</span>=<span class="string">&quot;Enter your name&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">disabled</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">className</span>=<span class="string">&quot;view-input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<!-- The interesting behavior occurs when you interact with this form. If you type something into the input field while editing and then click the "Cancel" button, your text remains when you click "Edit" again! This happens even though the two `input` elements have different props (one is disabled with a different class). -->
<p>인풋에 텍스트를 입력한 후 “Cancel” 버튼을 클릭하고 다시 “Edit” 버튼을 클릭하면, 입력한 텍스트가 그대로 남아 있습니다. 두 <code>input</code> 요소가 서로 다른 props(클래스 명 및 비활성화 여부)를 가지고 있음에도 불구하고 말이죠.</p>
<!-- React preserves the DOM element and its state because both elements are of the same type (`input`) at the same position in the element tree. React simply updates the props of the existing element rather than recreating it. -->
<p>리액트는 두 요소가 동일한 타입(<code>input</code>)이고, 요소 트리 내에서 같은 위치에 있을 때, 해당 DOM 요소와 그 상태를 그대로 유지합니다. 이때 리액트는 단순히 기존 요소의 props만 업데이트할 뿐, 새로 생성하지 않습니다.</p>
<!-- But if we changed our implementation to: -->
<p>코드를 다음과 같이 변경하고 다시 테스트해봅시다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  isEditing ? (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your name&quot;</span> <span class="attr">className</span>=<span class="string">&quot;edit-input&quot;</span> /&gt;</span></span></span><br><span class="line">  ) : (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;view-only-display&quot;</span>&gt;</span>Name will appear here<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- Then toggling the edit mode would result in completely different elements being mounted and unmounted, with any user input being lost. -->
<p>이번에는 편집 모드를 토글하면 입력한 텍스트가 사라집니다. 완전히 다른 요소가 언마운트(<code>input</code>) 및 마운트(<code>div</code>)되기 때문입니다.</p>
<!-- This behavior highlights a fundamental aspect of React's reconciliation: **element type is the primary factor in determining identity**. Understanding this concept is key to mastering React performance. -->
<p>이는 리액트의 조정에서 <strong>요소 타입이 컴포넌트의 정체성을 결정하는 중요한 요소</strong>임을 보여줍니다. 이 개념을 이해하는 것이 리액트 성능을 마스터하는 핵심 열쇠입니다.</p>
<!-- ## Element Trees, Not Virtual DOM -->
<h2 id="가상-DOM이-아닌-“요소-Element-”-트리"><a href="#가상-DOM이-아닌-“요소-Element-”-트리" class="headerlink" title="가상 DOM이 아닌 “요소(Element)” 트리"></a>가상 DOM이 아닌 “요소(Element)” 트리</h2><!-- You've probably heard that React uses a "Virtual DOM" to optimize updates. While this is a useful mental model, it's more accurate to think of React's internal representation as an element tree - a lightweight description of what should be on screen. -->
<p>흔히 리액트가 업데이트를 최적화하기 위해 “가상 DOM”을 사용한다고 알려져 있지만, 그보다는 화면에 표시되어야 할 내용을 간단히 기술한 “요소 트리”로 생각하는 것이 더 정확합니다.</p>
<!-- When you write JSX like this: -->
<p>다음과 같이 JSX를 작성해 봅시다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<!-- React transforms it into a tree of plain JavaScript objects: -->
<p>리액트는 이를 다음과 같은 단순한 자바스크립트 객체 트리로 변환합니다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">        <span class="attr">props</span>: &#123;</span><br><span class="line">          <span class="attr">children</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">        <span class="attr">props</span>: &#123;</span><br><span class="line">          <span class="attr">children</span>: <span class="string">&#x27;World&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- For DOM elements like `div` or `input`, the "type" is a string. For custom React components, the "type" is the actual function reference: -->
<p><code>div</code>나 <code>input</code> 같은 DOM 요소의 “type”은 문자열입니다. 반면, 커스텀 리액트 컴포넌트의 “type”은 실제 함수에 대한 참조입니다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="title class_">Input</span>, <span class="comment">// Input 함수 자체에 대한 참조</span></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;company-tax-id&quot;</span>,</span><br><span class="line">    <span class="attr">placeholder</span>: <span class="string">&quot;Enter company Tax ID&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- ## How Reconciliation Works -->
<h2 id="조정이-작동하는-방식"><a href="#조정이-작동하는-방식" class="headerlink" title="조정이 작동하는 방식"></a>조정이 작동하는 방식</h2><!-- When React needs to update the UI (after state changes or a re-render), it: -->
<p>UI를 업데이트하고자 할 때(상태 변경 또는 재렌더링 시), 리액트는 다음의 과정을 거칩니다.</p>
<!-- 1. Creates a new element tree by calling your components
2. Compares it with the previous tree
3. Figures out what DOM operations are needed to make the real DOM match the new tree
4. Performs those operations efficiently -->
<ol>
<li>컴포넌트를 호출하여 새로운 요소 트리를 생성합니다.</li>
<li>이전 트리와 비교합니다.</li>
<li>실제 DOM을 새로운 트리와 일치시키기 위해 작업이 필요한 DOM을 파악합니다.</li>
<li>파악한 작업을 효율적으로 수행합니다.</li>
</ol>
<!-- The comparison algorithm follows these key principles: -->
<p>비교 알고리즘은 다음의 주요 원칙을 따릅니다.</p>
<!-- ### 1. Element Type Determines Identity -->
<h3 id="1-요소-타입이-정체성을-결정합니다"><a href="#1-요소-타입이-정체성을-결정합니다" class="headerlink" title="1. 요소 타입이 정체성을 결정합니다."></a>1. 요소 타입이 정체성을 결정합니다.</h3><!-- React first checks the "type" of elements. If the type changes, React rebuilds the entire subtree: -->
<p>리액트는 먼저 요소의 “type”을 확인하고, 타입이 변경되면 전체 하위 트리를 다시 빌드합니다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 첫 번째 렌더링</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 번째 렌더링</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<!-- Since `div` changed to `span`, React destroys the entire old tree (including `Counter`) and builds a new one from scratch. -->
<p><code>div</code>가 <code>span</code>으로 변경되었으므로 리액트는 이전 트리 전체를 제거하고 새 트리를 처음부터 다시 빌드합니다.</p>
<!-- ### 2. Position in the Tree Matters -->
<h3 id="2-트리에서의-위치가-중요합니다"><a href="#2-트리에서의-위치가-중요합니다" class="headerlink" title="2. 트리에서의 위치가 중요합니다."></a>2. 트리에서의 위치가 중요합니다.</h3><!-- React's reconciliation algorithm relies heavily on component position within the tree structure. Position serves as a primary identity indicator during the diffing process. -->
<p>리액트의 조정 알고리즘은 트리 구조 내에서 컴포넌트의 위치에 크게 의존합니다. 위치는 비교 과정에서 주요 정체성 지표로 작용합니다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// showDetails = true: &lt;UserProfile userId=&#123;123&#125; /&gt;</span></span><br><span class="line">&lt;&gt;</span><br><span class="line">  &#123;showDetails ? <span class="language-xml"><span class="tag">&lt;<span class="name">UserProfile</span> <span class="attr">userId</span>=<span class="string">&#123;123&#125;</span> /&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">LoginPrompt</span> /&gt;</span></span>&#125;</span><br><span class="line">&lt;/&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// showDetails = false: &lt;LoginPrompt /&gt;</span></span><br><span class="line">&lt;&gt;</span><br><span class="line">  &#123;showDetails ? <span class="language-xml"><span class="tag">&lt;<span class="name">UserProfile</span> <span class="attr">userId</span>=<span class="string">&#123;123&#125;</span> /&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">LoginPrompt</span> /&gt;</span></span>&#125;</span><br><span class="line">&lt;/&gt;</span><br></pre></td></tr></table></figure>

<!-- In this conditional example, React treats the first child position of the fragment as a single "slot." When `showDetails` changes from `true` to `false`, React compares what's in that position across renders and sees different component types (`UserProfile` vs `LoginPrompt`). Since the component type at position 1 has changed, React unmounts the previous component entirely (including its state) and mounts the new one. -->
<p>이 조건부 렌더링 예제에서, 리액트는 프래그먼트의 첫 번째 자식 위치(위치 1)를 단일 “슬롯”으로 처리합니다. <code>showDetails</code>가 <code>true</code>에서 <code>false</code>로 변경되면, 리액트는 해당 위치에서 렌더링 간의 내용을 비교하여 컴포넌트 타입이 서로 다름(<code>UserProfile</code>과 <code>LoginPrompt</code>)을 파악합니다. 위치 1의 컴포넌트 타입이 변경되었으므로, 리액트는 이전 컴포넌트를 완전히 언마운트(상태 포함)하고 새 컴포넌트를 마운트합니다.</p>
<!-- This position-based identity also explains why components preserve their state in simpler cases: -->
<p>더 간단한 다음 예시에서는 위치 기반 정체성 덕분에 컴포넌트가 상태를 유지합니다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// isPrimary = true: &lt;UserProfile userId=&#123;123&#125; role=&quot;primary&quot; /&gt;</span></span><br><span class="line">&lt;&gt;</span><br><span class="line">  &#123;isPrimary ? (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">UserProfile</span> <span class="attr">userId</span>=<span class="string">&#123;123&#125;</span> <span class="attr">role</span>=<span class="string">&quot;primary&quot;</span> /&gt;</span></span></span><br><span class="line">  ) : (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">UserProfile</span> <span class="attr">userId</span>=<span class="string">&#123;456&#125;</span> <span class="attr">role</span>=<span class="string">&quot;secondary&quot;</span> /&gt;</span></span></span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// isPrimary = false: &lt;UserProfile userId=&#123;456&#125; role=&quot;secondary&quot; /&gt;</span></span><br><span class="line">&lt;&gt;</span><br><span class="line">  &#123;isPrimary ? (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">UserProfile</span> <span class="attr">userId</span>=<span class="string">&#123;123&#125;</span> <span class="attr">role</span>=<span class="string">&quot;primary&quot;</span> /&gt;</span></span></span><br><span class="line">  ) : (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">UserProfile</span> <span class="attr">userId</span>=<span class="string">&#123;456&#125;</span> <span class="attr">role</span>=<span class="string">&quot;secondary&quot;</span> /&gt;</span></span></span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/&gt;</span><br></pre></td></tr></table></figure>

<!-- Here, regardless of the `isPrimary` value, React sees the same component type (`UserProfile`) at the same position. It will preserve the component instance, simply updating its props rather than remounting it. -->
<p><code>isPrimary</code> 값에 상관없이, 리액트는 위치 1에 렌더링할 컴포넌트 타입이 동일함(<code>UserProfile</code>)을 파악합니다. 따라서 컴포넌트를 다시 마운트하지 않고 props만 업데이트하여 컴포넌트 인스턴스를 유지합니다.</p>
<!-- This position-based approach works well for most scenarios, but becomes problematic when: -->
<p>이 위치 기반 접근 방식은 대부분의 시나리오에서 잘 작동하지만, 다음과 같은 경우에는 문제가 될 수 있습니다.</p>
<!-- 1. Component positions shift dynamically (like in sorted lists)
2. You need to preserve state when components move between different positions
3. You want to control exactly when components should be remounted
-->
<ol>
<li>컴포넌트 위치가 동적으로 변경될 때(예: 리스트를 동적으로 정렬(sort)하는 경우)</li>
<li>컴포넌트가 다른 위치로 이동하더라도 상태를 보존하고자 할 때</li>
<li>컴포넌트의 재마운트 시점을 제어하고자 할 때</li>
</ol>
<!-- This is where React's key system comes in. -->
<p>이러한 상황에서는 리액트의 key 시스템이 유용합니다.</p>
<!-- ### 3. Keys Override Position-Based Comparison -->
<h3 id="3-key는-위치-기반-비교보다-우선합니다"><a href="#3-key는-위치-기반-비교보다-우선합니다" class="headerlink" title="3. key는 위치 기반 비교보다 우선합니다."></a>3. key는 위치 기반 비교보다 우선합니다.</h3><!-- The `key` attribute gives developers explicit control over component identity, overriding React's default position-based identification: -->
<p><code>key</code> 속성은 리액트의 기본적인 위치 기반 식별 방식보다 우선 적용되어, 개발자가 명시적으로 컴포넌트 정체성을 제어할 수 있도록 합니다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">TabContent</span> = (<span class="params">&#123; activeTab, tabs &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;tab-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;tabs.map((tab) =&gt; (</span></span><br><span class="line"><span class="language-xml">        // key는 위치 기반 비교에 우선합니다.</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;tab.id&#125;</span> <span class="attr">className</span>=<span class="string">&quot;tab-content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;activeTab === tab.id ? (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">UserProfile</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">key</span>=<span class="string">&quot;active-profile&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">userId</span>=<span class="string">&#123;tab.userId&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">role</span>=<span class="string">&#123;tab.role&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            /&gt;</span></span></span><br><span class="line"><span class="language-xml">          ) : (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;placeholder&quot;</span> <span class="attr">className</span>=<span class="string">&quot;placeholder&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              Select this tab to view &#123;tab.userId&#125;&#x27;s profile</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          )&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<!-- Even if the `UserProfile` component appears in different positions across conditional renders, React will treat components with the same key as the same component. When a tab becomes active, React preserves the component's state because the key "active-profile" remains consistent, allowing for smoother transitions between tabs. -->
<p><code>UserProfile</code> 컴포넌트가 조건부 렌더링에서 서로 다른 위치에 나타나더라도, 리액트는 동일한 key를 가진 컴포넌트를 동일한 컴포넌트로 간주합니다. 어떤 탭이 활성화되든, 활성화된 탭의 “active-profile” key는 일정하게 유지되므로, 리액트는 컴포넌트의 상태를 보존함으로써 탭 간 전환을 더 부드럽게 처리할 수 있습니다.</p>
<blockquote>역자주: 두 개의 탭이 존재한다고 했을 때, activeTab의 값이 "1"일 때와 "2"일 때의 렌더링 결과는 다음과 같습니다.
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* const tabs = [&#123; id: &quot;1&quot;, userId: &quot;a&quot;, role: &quot;aa&quot; &#125;, &#123; id: &quot;2&quot;, userId: &quot;b&quot;, role: &quot;bb&quot; &#125;] */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// activeTab === &quot;1&quot;일 때</span></span><br><span class="line">(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;tab-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span> <span class="attr">className</span>=<span class="string">&quot;tab-content&quot;</span>&gt;</span></span></span><br><span class="line marked"><span class="language-xml">      <span class="tag">&lt;<span class="name">UserProfile</span> <span class="attr">key</span>=<span class="string">&quot;active-profile&quot;</span> <span class="attr">userId</span>=<span class="string">&quot;a&quot;</span> <span class="attr">role</span>=<span class="string">&quot;aa&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span> <span class="attr">className</span>=<span class="string">&quot;tab-content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;placeholder&quot;</span> <span class="attr">className</span>=<span class="string">&quot;placeholder&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Select this tab to view &#123;tab.userId&#125;&#x27;s profile</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// activeTab === &quot;2&quot;일 때</span></span><br><span class="line">(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;tab-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span> <span class="attr">className</span>=<span class="string">&quot;tab-content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;placeholder&quot;</span> <span class="attr">className</span>=<span class="string">&quot;placeholder&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Select this tab to view &#123;tab.userId&#125;&#x27;s profile</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span> <span class="attr">className</span>=<span class="string">&quot;tab-content&quot;</span>&gt;</span></span></span><br><span class="line marked"><span class="language-xml">      <span class="tag">&lt;<span class="name">UserProfile</span> <span class="attr">key</span>=<span class="string">&quot;active-profile&quot;</span> <span class="attr">userId</span>=<span class="string">&quot;b&quot;</span> <span class="attr">role</span>=<span class="string">&quot;bb&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
7번 줄과 26번 줄의 컴포넌트 타입 및 key가 동일하므로, 리액트는 이를 동일한 컴포넌트로 파악하여 재렌더링하지 않고 props만 변경합니다.
</blockquote>


 <!-- This illustrates how keys provide a way to maintain component identity regardless of structural position in the render tree - a powerful tool for controlling how React reconciles your component hierarchy. -->
<p>이처럼 key는 렌더 트리의 구조적 위치와 상관없이 컴포넌트 정체성을 유지할 수 있는 방법을 제공하는, 리액트의 컴포넌트 계층구조조정 방식을 제어할 수 있는 강력한 도구입니다.</p>
<!-- ## The Magic of Keys -->
<h2 id="key의-마법"><a href="#key의-마법" class="headerlink" title="key의 마법"></a>key의 마법</h2><!-- Keys are primarily known for their role in lists, but they have deeper implications for React's reconciliation process. -->
<p>key는 주로 리스트에서 쓰이는 것으로 알려져 있지만, 실은 리액트의 조정 과정에서 더 깊은 의미를 가집니다.</p>
<!-- ### Why Keys Are Required for Lists -->
<h3 id="리스트에-key가-필요한-이유"><a href="#리스트에-key가-필요한-이유" class="headerlink" title="리스트에 key가 필요한 이유"></a>리스트에 key가 필요한 이유</h3><!-- When rendering lists, React uses keys to track which items have been added, removed, or reordered: -->
<p>리스트를 렌더링할 때, 리액트는 key를 통해 어떤 항목이 추가, 제거, 또는 재정렬 되었는지를 파악합니다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &#123;items.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>&#123;item.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  ))&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<!-- Without keys, React would solely rely on the element's position in the array. If you insert a new item at the beginning, React would see every element as having changed position and would rerender the entire list. -->
<p>key가 없으면, 리액트는 리스트 내에서의 요소의 위치만을 기준으로 판단하게 됩니다. 이때 만약 리스트의 맨 앞에 새로운 항목을 삽입하면, 리액트는 모든 요소가 위치를 변경한 것으로 이해하여 전체 리스트를 다시 렌더링할 것입니다.</p>
<!-- With keys, React can match elements between renders regardless of their position. -->
<p>key를 사용하면, 리액트는 위치의 변경과 무관하게, 변경 전후의 렌더링 과정에서 변경된 요소 및 변경되지 않은 요소를 정확히 파악할 수 있습니다.</p>
<!-- ### 1. Keys Outside of Arrays? -->
<h3 id="1-배열이-아닌-경우의-key"><a href="#1-배열이-아닌-경우의-key" class="headerlink" title="1. 배열이 아닌 경우의 key?"></a>1. 배열이 아닌 경우의 key?</h3><!-- React doesn't force you to add keys for static elements: -->
<p>리액트는 정적인 요소에 대해 key를 강제하지 않습니다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key가 필요하지 않습니다.</span></span><br><span class="line">&lt;&gt;</span><br><span class="line marked">  <span class="language-xml"><span class="tag">&lt;<span class="name">Input</span> /&gt;</span></span></span><br><span class="line marked">  <span class="language-xml"><span class="tag">&lt;<span class="name">Input</span> /&gt;</span></span></span><br><span class="line">&lt;/&gt;</span><br></pre></td></tr></table></figure>

<!-- This works because React knows these elements are static - their position in the tree is predictable. -->
<p>위 예제에서 두 인풋은 정적 요소로써 리액트가 트리에서의 위치를 파악할 수 있으므로 key가 필요하지 않습니다.</p>
<!-- But keys can be powerful even outside of lists. Consider this example: -->
<p>그러나 다음과 같이, key는 리스트가 아닌 경우에도 강력한 기능을 제공합니다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [isReverse, setIsReverse] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line marked"><span class="language-xml">      <span class="tag">&lt;<span class="name">Input</span> <span class="attr">key</span>=<span class="string">&#123;isReverse</span> ? &quot;<span class="attr">some-key</span>&quot; <span class="attr">:</span> <span class="attr">null</span>&#125; /&gt;</span></span></span><br><span class="line marked"><span class="language-xml">      <span class="tag">&lt;<span class="name">Input</span> <span class="attr">key</span>=<span class="string">&#123;!isReverse</span> ? &quot;<span class="attr">some-key</span>&quot; <span class="attr">:</span> <span class="attr">null</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<!-- When `isReverse` toggles, the key `'some-key'` moves from one input to the other, causing React to "move" the component's state between the two positions! -->
<p><code>isReverse</code>가 토글될 때, key <code>&#39;some-key&#39;</code>가 한 인풋 요소에서 다른 인풋 요소으로 이동하여 리액트가 컴포넌트의 상태를 두 위치 간에 “이동”하도록 만듭니다!</p>
<blockquote>
<p>역자주: <code>isReverse = true</code>일 때 6번 줄의 <code>Input</code>과, <code>isReverse = false</code>일 때 7번 줄의 <code>Input</code>은 모두 동일한 key(<code>&#39;some-key&#39;</code>)를 가지므로, 리액트는 <strong>이를 동일한 컴포넌트가 6번 줄에서 7번 줄로 이동한 것으로 파악</strong>합니다.</p>
</blockquote>
<!-- ### 2. Mixing Dynamic and Static Elements -->
<h3 id="2-동적-요소와-정적-요소-혼합"><a href="#2-동적-요소와-정적-요소-혼합" class="headerlink" title="2. 동적 요소와 정적 요소 혼합"></a>2. 동적 요소와 정적 요소 혼합</h3><!-- A common worry is whether adding items to a dynamic list might shift the identity of static elements after the list: -->
<p>흔히 동적 리스트의 뒷부분에 정적 요소를 추가하면 정적 요소의 정체성이 변경될지를 우려합니다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;&gt;</span><br><span class="line">  &#123;items.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ListItem</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span> /&gt;</span></span></span><br><span class="line">  ))&#125;</span><br><span class="line marked">  &lt;<span class="title class_">StaticElement</span> /&gt; &#123;<span class="comment">/* items가 변경되면 이 부분도 다시 마운트 될까요? */</span>&#125;</span><br><span class="line">&lt;/&gt;</span><br></pre></td></tr></table></figure>

<!-- React handles this intelligently. It treats the entire dynamic list as a single unit at the first position, so the `StaticElement` will always maintain its position and identity, regardless of changes to the list. -->
<p>리액트는 이를 지능적으로 처리합니다. 리액트는 전체 동적 리스트를 하나의 단위로 취급하므로, <code>StaticElement</code>는 리스트 변경과 상관없이 항상 동일한 위치와 정체성을 유지합니다.</p>
<!-- Here's how React actually represents this internally: -->
<p>리액트가 이를 내부적으로 어떻게 표현하는지 살펴보면 다음과 같습니다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">// 전체 동적 배열이 단일 자식으로 처리됨</span></span><br><span class="line">  [</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="title class_">ListItem</span>, <span class="attr">key</span>: <span class="string">&quot;1&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="title class_">ListItem</span>, <span class="attr">key</span>: <span class="string">&quot;2&quot;</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line marked">  &#123; <span class="attr">type</span>: <span class="title class_">StaticElement</span> &#125;, <span class="comment">// 항상 두 번째 위치를 추적</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<!-- Even if you add or remove items from the list, the `StaticElement` will remain at position 2 in the parent array. This means it won't re-mount when the list changes. This is a clever optimization that ensures static elements don't get unnecessarily re-mounted due to changes in adjacent dynamic lists. -->
<p>리스트에 항목을 추가하거나 제거하더라도, <code>StaticElement</code>는 부모 배열에서 두 번째 위치를 유지합니다. 따라서 리스트 변경으로 인해 정적 요소가 다시 마운트 되지 않습니다. 이는 리액트가 불필요한 재마운트를 방지하고자 영리하게 최적화한 결과입니다.</p>
<!-- ### 3. Keys for Strategic DOM Control -->
<h3 id="3-전략적인-DOM-제어를-위한-key"><a href="#3-전략적인-DOM-제어를-위한-key" class="headerlink" title="3. 전략적인 DOM 제어를 위한 key"></a>3. 전략적인 DOM 제어를 위한 key</h3><!-- Keys aren't just for lists - they're a powerful tool for controlling component and DOM element identity in React. For React component state preservation across different views, remember that key and component type work together - components with the same key but different types will still unmount and remount. In these cases, lifting state up is typically the better approach: -->
<p>리액트에서 key는 리스트만을 위한 것이 아닙니다. key는 리액트에서 컴포넌트와 DOM 요소의 정체성을 제어하는 강력한 도구입니다. 서로 다른 뷰 간에 리액트 컴포넌트 상태를 유지할지를 판단하는 기준으로 key와 컴포넌트 타입이 함께 쓰인다는 점을 기억하세요. 동일한 key를 가진 컴포넌트라도 타입이 다르면 여전히 언마운트 및 리마운트가 발생합니다. 이러한 경우에는 상태를 상위 컴포넌트로 끌어올리는 것이 일반적으로 더 나은 접근 방식입니다.</p>
 <figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 상태를 다른 뷰 간에 보존하기 위한 접근법 - 상태 끌어올리기 (여기서는 key가 효과적이지 않습니다.)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">TabContent</span> = (<span class="params">&#123; activeTab &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 탭 변경 간에 보존하고자 하는 상태</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [sharedState, setSharedState] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">    <span class="comment">/* 초기 상태 */</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;activeTab === &quot;profile&quot; &amp;&amp; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ProfileTab</span> <span class="attr">state</span>=<span class="string">&#123;sharedState&#125;</span> <span class="attr">onStateChange</span>=<span class="string">&#123;setSharedState&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;activeTab === &quot;settings&quot; &amp;&amp; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">SettingsTab</span> <span class="attr">state</span>=<span class="string">&#123;sharedState&#125;</span> <span class="attr">onStateChange</span>=<span class="string">&#123;setSharedState&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;/* 나머지 탭 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<!-- Preserving the key woundn’t be enough in this case since the type (and reference) is different between tabs. -->
<p>이 경우, 탭 간에 타입(및 참조)이 다르기 때문에 key를 유지하는 것만으로는 충분하지 않습니다.</p>
<!-- But take a look at this example, however, using keys and uncontrolled components: -->
<p>하지만 key와 비제어 컴포넌트를 사용하는 다음 예제를 살펴보세요.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">UserForm</span> = (<span class="params">&#123; userId &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">key</span>=<span class="string">&#123;userId&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">name</span>=<span class="string">&quot;username&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">defaultValue</span>=<span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 나머지 인풋 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<!-- By giving the uncontrolled input a key based on userId, we ensure that React creates a completely new DOM element whenever the userId changes. Since the uncontrolled input’s state lives in the DOM itself rather than in React state, this effectively resets the input when switching between different users. In this case key is all you need. -->
<p>userId를 기반으로 비제어 인풋에 key를 부여하면, userId가 변경될 때마다 리액트가 완전히 새로운 DOM 요소를 생성하도록 보장할 수 있습니다. 비제어 인풋의 상태는 리액트 상태가 아닌 DOM 자체에 존재하므로, 다른 사용자로 전환하면 인풋이 초기화됩니다. 그래서 이런 경우에는 key만으로도 충분합니다.</p>
<!-- Quite something, huh? -->
<p>꽤 흥미롭지 않나요? 😊</p>
<!-- ## State Colocation: A Powerful Performance Pattern -->
<h2 id="상태의-지역화-State-Colocation-강력한-성능-패턴"><a href="#상태의-지역화-State-Colocation-강력한-성능-패턴" class="headerlink" title="상태의 지역화(State Colocation): 강력한 성능 패턴"></a>상태의 지역화(State Colocation): 강력한 성능 패턴</h2><!-- State colocation is a pattern that involves keeping state as close as possible to where it's used. This approach minimizes unnecessary re-renders by ensuring that only the components directly affected by state changes are updated. -->
<p>상태의 지역화는 상태를 사용하는 곳에 최대한 가깝게 유지하는 패턴입니다. 이 접근법은 상태 변경으로 인해 영향을 받는 컴포넌트만 업데이트 되도록 보장하여 불필요한 재렌더링을 최소화합니다.</p>
<!-- Consider this example: -->
<p>다음 예제를 살펴봅시다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 성능 낮음 - 필터가 변경되면 맵 전체를 다시 렌더링함</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [filterText, setFilterText] = <span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> filteredUsers = users.<span class="title function_">filter</span>(<span class="function">(<span class="params">user</span>) =&gt;</span> user.<span class="property">name</span>.<span class="title function_">includes</span>(filterText));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">SearchBox</span> <span class="attr">filterText</span>=<span class="string">&#123;filterText&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;setFilterText&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">UserList</span> <span class="attr">users</span>=<span class="string">&#123;filteredUsers&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ExpensiveComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<!-- When `filterText` changes, the entire `App` component re-renders, including `ExpensiveComponent` which isn't affected by the filter. -->
<p><code>filterText</code>가 변경되면, <code>ExpensiveComponent</code>처럼 필터와 관련 없는 컴포넌트를 포함하여 전체 <code>App</code> 컴포넌트가 재렌더링됩니다.</p>
<!-- By colocating the filter state with just the components that use it: -->
<p>반면, 필터 상태를 실제로 사용하는 컴포넌트 내부로 옮기면 다음과 같이 됩니다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">UserSection</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [filterText, setFilterText] = <span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> filteredUsers = users.<span class="title function_">filter</span>(<span class="function">(<span class="params">user</span>) =&gt;</span> user.<span class="property">name</span>.<span class="title function_">includes</span>(filterText));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">SearchBox</span> <span class="attr">filterText</span>=<span class="string">&#123;filterText&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;setFilterText&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">UserList</span> <span class="attr">users</span>=<span class="string">&#123;filteredUsers&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">UserSection</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ExpensiveComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<!-- Now when the filter changes, only `UserSection` re-renders. This pattern not only improves performance but also leads to better component design by ensuring each component only manages the state that truly belongs to it. -->
<p>필터가 변경될 때 <code>UserSection</code>만 재렌더링됩니다. 이 패턴은 성능을 향상시킬 뿐 아니라, 각 컴포넌트가 실제로 사용해야 할 상태만 관리하도록 설계하여 더 나은 컴포넌트 구조를 만듭니다.</p>
<!-- ## Component Design: Optimizing for Change -->
<h2 id="컴포넌트-설계-변경에-대한-최적화"><a href="#컴포넌트-설계-변경에-대한-최적화" class="headerlink" title="컴포넌트 설계: 변경에 대한 최적화"></a>컴포넌트 설계: 변경에 대한 최적화</h2><!-- Performance optimization is often a component design problem. If a component does too many things, it's more likely to re-render unnecessarily. -->
<p>보통 성능 최적화는 컴포넌트 설계 문제에서부터 시작합니다. 컴포넌트가 너무 많은 일을 하면 불필요하게 재렌더링될 가능성이 높아집니다.</p>
<!-- Before reaching for `React.memo`, ask: -->
<p><code>React.memo</code>를 사용하기 전에 다음 질문을 던져보세요.</p>
<!-- 1. **Does this component have mixed responsibilities?** Components that handle multiple concerns are likely to re-render more frequently.
2. **Is state being lifted too high?** When state is kept higher in the tree than needed, it causes more components to re-render. -->

<ol>
<li><strong>이 컴포넌트가 여러 가지 책임을 지고 있나요?</strong><br>여러 관심사를 처리하는 컴포넌트는 더 자주 재렌더링될 가능성이 있습니다.</li>
<li><strong>상태가 너무 높은 위치로 끌어올려져 있나요?</strong><br>상태가 필요 이상으로 트리 상단에 위치하면 더 많은 컴포넌트가 재렌더링됩니다.</li>
</ol>
<!-- Consider this example: -->
<p>다음 예제를 봅시다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문제 있는 설계 - 여러 가지 책임을 지는 컴포넌트</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ProductPage</span> = (<span class="params">&#123; productId &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [selectedSize, setSelectedSize] = <span class="title function_">useState</span>(<span class="string">&quot;medium&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [quantity, setQuantity] = <span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> [shipping, setShipping] = <span class="title function_">useState</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [reviews, setReviews] = <span class="title function_">useState</span>([]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 제품 상세 정보와 리뷰를 모두 가져옴</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetchProductDetails</span>(productId);</span><br><span class="line">    <span class="title function_">fetchReviews</span>(productId).<span class="title function_">then</span>(setReviews);</span><br><span class="line">  &#125;, [productId]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ProductInfo</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">selectedSize</span>=<span class="string">&#123;selectedSize&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onSizeChange</span>=<span class="string">&#123;setSelectedSize&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">quantity</span>=<span class="string">&#123;quantity&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onQuantityChange</span>=<span class="string">&#123;setQuantity&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ShippingOptions</span> <span class="attr">shipping</span>=<span class="string">&#123;shipping&#125;</span> <span class="attr">onShippingChange</span>=<span class="string">&#123;setShipping&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Reviews</span> <span class="attr">reviews</span>=<span class="string">&#123;reviews&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<!-- Every time the size, quantity, or shipping changes, the entire page re-renders, including the unrelated reviews section. -->
<p>사이즈, 수량, 배송 옵션이 변경될 때마다 페이지 전체가 재렌더링되며, 리뷰 섹션과 같은 관련 없는 부분도 영향을 받습니다.</p>
<!-- A better design separates these concerns: -->
<p>더 나은 설계는 이러한 책임을 분리하는 것입니다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ProductPage</span> = (<span class="params">&#123; productId &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ProductConfig</span> <span class="attr">productId</span>=<span class="string">&#123;productId&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ReviewsSection</span> <span class="attr">productId</span>=<span class="string">&#123;productId&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ProductConfig</span> = (<span class="params">&#123; productId &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [selectedSize, setSelectedSize] = <span class="title function_">useState</span>(<span class="string">&quot;medium&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [quantity, setQuantity] = <span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> [shipping, setShipping] = <span class="title function_">useState</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 제품 관련 로직</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ProductInfo</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">selectedSize</span>=<span class="string">&#123;selectedSize&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onSizeChange</span>=<span class="string">&#123;setSelectedSize&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">quantity</span>=<span class="string">&#123;quantity&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onQuantityChange</span>=<span class="string">&#123;setQuantity&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ShippingOptions</span> <span class="attr">shipping</span>=<span class="string">&#123;shipping&#125;</span> <span class="attr">onShippingChange</span>=<span class="string">&#123;setShipping&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ReviewsSection</span> = (<span class="params">&#123; productId &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [reviews, setReviews] = <span class="title function_">useState</span>([]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetchReviews</span>(productId).<span class="title function_">then</span>(setReviews);</span><br><span class="line">  &#125;, [productId]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Reviews</span> <span class="attr">reviews</span>=<span class="string">&#123;reviews&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<!-- This structure ensures that changing the product size doesn't cause the reviews to re-render. No memoization needed - just good component boundaries. -->
<p>이 구조는 제품 사이즈를 변경해도 리뷰가 재렌더링되지 않도록 보장합니다. 메모이제이션 없이도 컴포넌트 경계를 잘 설정하면 성능을 최적화할 수 있습니다.</p>
<!-- ## Reconciliation and Clean Architecture -->
<h2 id="조정-Reconciliation-과-클린-아키텍처"><a href="#조정-Reconciliation-과-클린-아키텍처" class="headerlink" title="조정(Reconciliation)과 클린 아키텍처"></a>조정(Reconciliation)과 클린 아키텍처</h2><!-- This understanding of reconciliation aligns perfectly with Clean Architecture principles:-->
<p>리액트의 조정 알고리즘은 클린 아키텍처 원칙과 완벽하게 일치합니다.</p>
<!-- 1. **Single Responsibility Principle**: Each component should have one reason to change. When components are focused on a single responsibility, they're less likely to trigger unnecessary re-renders. -->
<!-- 2. **Dependency Inversion**: Components should depend on abstractions, not concrete implementations. This makes it easier to optimize performance through composition. -->
<!-- 3. **Interface Segregation**: Components should have minimal, focused interfaces. This reduces the chance of prop changes triggering unnecessary re-renders. -->
<ol>
<li><strong>단일 책임 원칙(Single Responsibility Principle)</strong><br>각 컴포넌트는 변경 이유가 하나여야 합니다. 컴포넌트가 단일 책임에 집중하면 불필요한 재렌더링이 줄어듭니다.</li>
<li><strong>의존성 역전 원칙(Dependency Inversion)</strong><br>컴포넌트는 구체적인 구현이 아닌 추상화에 의존해야 합니다. 이를 통해 컴포지션을 통해 성능을 최적화하기가 더 쉬워집니다.</li>
<li><strong>인터페이스 분리 원칙(Interface Segregation)</strong><br>컴포넌트는 최소한의 집중된 인터페이스를 가져야 합니다. 이는 props 변경으로 인해 불필요한 재렌더링이 발생할 가능성을 줄여줍니다.</li>
</ol>
<!-- ## Practical Guidelines -->
<h2 id="실용적인-가이드라인"><a href="#실용적인-가이드라인" class="headerlink" title="실용적인 가이드라인"></a>실용적인 가이드라인</h2><!-- Based on our deep dive into reconciliation, here are some practical guidelines:
1. **Keep component definitions outside parent components** to prevent remounting.
2. **Move state down** to isolate re-render boundaries.
3. **Be consistent with component types** in the same position to avoid unmounting.
4. **Use keys strategically** - not just for lists, but whenever you want to control component identity.
5. **When debugging re-render issues**, think in terms of element trees and component identity.
6. **Remember that React.memo is just a tool** that works within the constraints of reconciliation - it doesn't change the fundamental algorithm. -->

<p>조정에 대한 심층 분석을 바탕으로 다음과 같은 실용적인 가이드라인을 제안합니다.</p>
<ol>
<li><strong>컴포넌트 정의를 부모 컴포넌트 외부로 이동</strong>하여 재마운트를 방지하세요.</li>
<li><strong>상태를 하위로 이동</strong>하여 재렌더링 경계를 분리하세요.</li>
<li><strong>동일한 위치에서 일관된 컴포넌트 타입을 유지</strong>하여 언마운트를 방지하세요.</li>
<li><strong>key를 전략적으로 사용</strong>하세요. 리스트뿐만 아니라 컴포넌트 정체성을 제어하고 싶을 때도 유용합니다.</li>
<li><strong>재렌더링 문제를 디버깅할 때</strong>, 요소 트리와 컴포넌트 정체성을 기준으로 생각하세요.</li>
<li><strong>React.memo는 단지 도구일 뿐</strong>입니다. 조정 알고리즘의 제약 내에서 작동하며, 근본적인 알고리즘을 변경하지는 않습니다.</li>
</ol>
<!-- ## Conclusion -->
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><!-- Understanding React's reconciliation algorithm reveals the "why" behind many React performance patterns. It explains why composition works so well, why we need keys for lists, and why defining components inside other components is problematic. -->
<p>리액트의 조정 알고리즘을 이해하면 많은 리액트 성능 패턴의 “이유”를 파악할 수 있습니다. 컴포지션이 효과적인 이유, 리스트에 key가 필요한 이유, 나아가 컴포넌트를 내부에 정의하는 것의 문제점을 드러냅니다.</p>
<!-- This knowledge helps us make better architectural decisions that naturally lead to performant React applications. Rather than fighting React's reconciliation algorithm with excessive memoization, we can work with it by designing component structures that align with how React identifies and updates components. -->
<p>이 지식은 리액트 애플리케이션의 성능을 자연스럽게 끌어올릴 수 있는 더 나은 아키텍처를 결정하는 데 도움을 줍니다. 과도한 메모이제이션으로 리액트의 조정 알고리즘과 싸우는 대신, 리액트가 컴포넌트를 식별하고 업데이트하는 방식에 맞춰 컴포넌트 구조를 설계함으로써 이를 활용할 수 있습니다.</p>
<!-- The next time you're optimizing a React application, think about how your component structure affects the reconciliation process. Sometimes, the best optimization is a simpler, more focused component tree that respects how React identifies and updates components. -->
<p>다음에 리액트 애플리케이션을 최적화할 때, 컴포넌트 구조가 조정 과정에 어떤 영향을 미치는지 생각해 보세요. 때때로 가장 좋은 최적화는 리액트가 컴포넌트를 식별하고 업데이트하는 방식을 고려하여 더 간단하고 집중된 컴포넌트 트리를 만드는 것입니다.</p>
<!-- What patterns have you found most effective for working with React's reconciliation process? I'd love to hear your experiences, use the Feedback.One button on the right 🤓 -->
<p>리액트의 조정 프로세스를 다룰 때 여러분이 가장 효과적이라고 생각한 패턴은 무엇인가요? 여러분의 경험을 듣고 싶습니다. 댓글 남겨주세요 🤓</p>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/react-js/">React.js</a><a class="article__tags__item" href="/tags/%EB%B2%88%EC%97%AD/">번역</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="https://www.gravatar.com/avatar/02e9f56a3202da2e6e0e36a5a23facbb" alt="Jaenam Jung"><a class="article__author__link" title="About Jaenam Jung" rel="author">Jaenam Jung</a><p class="article__author__desc">할 수 있는걸 합니다.</p><div class="article__author__socials"><a class="article__author__socials__item" href="http://github.com/roy-jung" title="github" target="_blank"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="Jaenam Jung"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><div id="disqus_thread"></div><script>(function() {
  var d = document, s = d.createElement('script');
  s.src = '//gomugom.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Enable JavaScript to see comments.</noscript><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2025-04-23T05:25:52.302Z"><meta itemprop="articleBody" content="
원문: React Reconciliation: The Hidden Engine Behind Your Components


조정 엔진(Reconciliation Engine)
이전 글들(1, 2)에서 React.memo의 작동 방식과 컴포지션을 활용한 성능 최적화 방법을 살펴보았습니다. 하지만 리액트 성능을 제대로 정복하기 위해서는 리액트의 핵심..."><meta itemprop="url" content="http://roy-jung.github.io/250414-react-reconciliation-deep-dive/"><meta itemprop="mainEntityOfPage" content="http://roy-jung.github.io/250414-react-reconciliation-deep-dive/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="FE재남"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="http://roy-jung.github.io/images/logo.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="http://roy-jung.github.io/images/React Reconciliation Engine.webp"><meta itemprop="url" content="http://roy-jung.github.io/images/React Reconciliation Engine.webp"><meta itemprop="width"><meta itemprop="height"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/250323-react-server-components/"><div class="related-posts__item__background" style="background-image:url('/images/Forensics of React Server Components.jpg');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">리액트 서버 컴포넌트 톺아보기 (번역)</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/201129_apollo-graphql-infinite-scroll/"><div class="related-posts__item__background" style="background-image:url('/201129_apollo-graphql-infinite-scroll/0.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">infinite scroll 구현하기 (1) apollo-graphql</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/201111-concise-redux-saga/"><div class="related-posts__item__background" style="background-image:url('/images/post-cover4.jpg');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">redux-saga를 간결하게 사용해보자!</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/iterator-helper-overview/">이터레이터 헬퍼 맛보기</a></li><li class="recent-posts__item"><a href="/250414-react-reconciliation-deep-dive/">React Reconciliation: 컴포넌트 뒤에 숨겨진 엔진</a></li><li class="recent-posts__item"><a href="/250323-react-server-components/">리액트 서버 컴포넌트 톺아보기 (번역)</a></li><li class="recent-posts__item"><a href="/211231-review-2021/">2021 회고</a></li><li class="recent-posts__item"><a href="/201130_swr-graphql-infinite-scroll/">infinite scroll 구현하기 (2) swr-graphql</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">2025 5월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">2025 4월</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">2022 1월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">2020 11월</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">2020 10월</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">2017 1월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">2016 12월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">2016 11월</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">2016 10월</a><span class="archive-list-count">2</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ecmascript/">ECMAScript</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fe/">FE</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/fe/react-js/">React.js</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/fe/react-js/next-js/">Next.js</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/fe/javascript/">javascript</a><span class="category-list-count">6</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/etc/">etc</a><span class="category-list-count">2</span></li></ul></div></div></div><p class="copyright"><small>© 2025 Jaenam Jung<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>