<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>리액트 서버 컴포넌트 톺아보기 (번역) | FE재남</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="http://roy-jung.github.io/250323-react-server-components/"/>
<meta name="description" content="원문: The Forensics of React Server Components (RSC)    간단 요약: 클라이언트 사이드 렌더링은 서버의 무거운 연산 부담을 덜어줍니다. 그 대신 초기 페이지 로드 시 빈 HTML 페이지가 보이는 점에서…">
<meta property="og:type" content="article">
<meta property="og:title" content="리액트 서버 컴포넌트 톺아보기 (번역)">
<meta property="og:url" content="http://roy-jung.github.io/250323-react-server-components/">
<meta property="og:site_name" content="FE재남">
<meta property="og:description" content="원문: The Forensics of React Server Components (RSC)    간단 요약: 클라이언트 사이드 렌더링은 서버의 무거운 연산 부담을 덜어줍니다. 그 대신 초기 페이지 로드 시 빈 HTML 페이지가 보이는 점에서…">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="http://roy-jung.github.io/images/Forensics%20of%20React%20Server%20Components.jpg">
<meta property="article:published_time" content="2025-04-02T11:00:00.000Z">
<meta property="article:modified_time" content="2025-04-23T05:25:46.732Z">
<meta property="article:author" content="Jaenam Jung">
<meta property="article:tag" content="React.js">
<meta property="article:tag" content="번역">
<meta property="article:tag" content="Next.js">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://roy-jung.github.io/images/Forensics%20of%20React%20Server%20Components.jpg"><meta property="article:author" content="Jaenam Jung"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2025-04-02 20:00:00"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="Jaenam Jung"><link rel="icon" href="/images/logo.png"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="FE재남"><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/logo.png" alt="FE재남"><span class="menu__item__link--brand__label">FE재남</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">리액트 서버 컴포넌트 톺아보기 (번역)</h1><div class="article__meta"><time class="article__meta__time" datetime="2025-04-02T11:00:00.000Z" itemprop="datePublished">2025-04-02 20:00:00</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/fe/">FE</a><span class="article__meta__categories__separator">></span><a class="article__meta__categories__item" href="/categories/fe/react-js/">React.js</a><span class="article__meta__categories__separator">></span><a class="article__meta__categories__item" href="/categories/fe/react-js/next-js/">Next.js</a></div></div><div class="article__contents"><img src="/images/Forensics of React Server Components.jpg"/><blockquote>
<p>원문: <a target="_blank" rel="noopener" href="https://www.smashingmagazine.com/2024/05/forensics-react-server-components/">The Forensics of React Server Components (RSC)</a></p>
</blockquote>
<!-- > **Quick Summary:** We love client-side rendering for the way it relieves the server of taxing operations, but serving an empty HTML page often leads to taxing user experiences during the initial page load. We love server-side rendering because it allows us to serve static assets on speedy CDNs, but they’re unfit for large-scale projects with dynamic content. React Server Components (RSCs) combine the best of both worlds, and author Lazar Nikolov thoroughly examines how we got here with a deep look at the impact that RSCs have on the page load timeline. -->
<blockquote>
<p><strong>간단 요약:</strong> 클라이언트 사이드 렌더링은 서버의 무거운 연산 부담을 덜어줍니다. 그 대신 초기 페이지 로드 시 빈 HTML 페이지가 보이는 점에서 사용자 경험에 좋지 않습니다. 반면, 서버 사이드 렌더링은 빠른 CDN을 통해 정적 자산(static assets)을 제공함으로써 초기 페이지 로드 시 충분한 정보를 제공할 수 있게 해줍니다. 그러나 동적 콘텐츠가 많은 대규모 프로젝트에는 서버 사이드 렌더링이 적합하지 않습니다. 리액트 서버 컴포넌트는 두 방식의 장점을 결합한 기술로, 저자 Lazar Nikolov은 RSC가 페이지 로드 타임라인에 미치는 영향을 깊이 있게 살펴봅니다.</p>
</blockquote>
<!-- In this article, we’re going to look deeply at React Server Components (RSCs). They are the latest innovation in React’s ecosystem, leveraging both server-side and client-side rendering as well as [streaming HTML](https://en.wikipedia.org/wiki/Chunked_transfer_encoding) to deliver content as fast as possible. -->
<p>이 글에서는 리액트 서버 컴포넌트(React Server Components, 이하 RSC)를 깊이 있게 살펴봅니다. RSC는 리액트 생태계의 혁신적인 최신 기술로, 서버 사이드 렌더링과 클라이언트 사이드 렌더링, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding">스트리밍 HTML</a>을 활용하여 가능한 한 빠르게 콘텐츠를 전달합니다.</p>
<!-- We will get really nerdy to get a full understanding of how RSCs fit into the React picture, the level of control they offer over the rendering lifecycle of components, and what page loads look like with RSCs in place. -->
<p>RSC가 리액트 구조 속에서 어떻게 자리 잡는지, 컴포넌트 렌더링 라이프사이클에 대해 어느 정도의 제어권을 제공하는지, 그리고 RSC가 적용된 페이지 로드는 어떤 모습인지 완벽하게 이해하기 위해 세세하게 파고들 것입니다.</p>
<!-- But before we dive into all of that, I think it’s worth looking back at how React has rendered websites up until this point to set the context for why we need RSCs in the first place. -->
<p>그 전에, RSC가 필요하게 된 원인에 대한 맥락을 이해하기 위해, 기존에 리액트가 웹사이트를 렌더링 하던 방식을 되짚어보면 좋겠습니다.</p>
<!-- ## 1. The Early Days: React Client-Side Rendering -->
<h2 id="1-초기-클라이언트-사이드-렌더링"><a href="#1-초기-클라이언트-사이드-렌더링" class="headerlink" title="1. 초기: 클라이언트 사이드 렌더링"></a>1. 초기: 클라이언트 사이드 렌더링</h2><!-- The first React apps were rendered on the client side, i.e., in the browser. As developers, we wrote apps with JavaScript classes as components and packaged everything up using bundlers, like Webpack, in a nicely compiled and tree-shaken heap of code ready to ship in a production environment. -->
<p>최초의 리액트 앱은 클라이언트, 즉 브라우저에서 렌더링했습니다(Client-Side Rendering, CSR). 개발자들은 자바스크립트 클래스로 컴포넌트를 작성하고, 웹팩과 같은 번들러를 사용해 모든 코드를 컴파일 및 트리쉐이킹한 상태로 상용 환경에 배포할 수 있는 코드로 패키징했습니다.</p>
<!-- The HTML that returned from the server contained a few things, including: -->
<p>서버에서 전달한 HTML에는 다음과 같은 몇 가지 요소가 포함되었습니다.</p>
<!-- - An HTML document with metadata in the `<head>` and a blank `<div>` in the `<body>` used as a hook to inject the app into the DOM; -->
<ul>
<li>HTML 문서. <code>&lt;head&gt;</code>에는 메타데이터가 포함되었으며, <code>&lt;body&gt;</code>에는 빈 <code>&lt;div&gt;</code>가 포함되어 있습니다. 빈 <code>&lt;div&gt;</code>는 DOM에 리액트 앱을 주입하기 위한 요소로 사용됩니다.</li>
</ul>
<!-- - JavaScript resources containing React’s core code and the actual code for the web app, which would generate the user interface and populate the app inside of the empty `<div>`. -->
<ul>
<li>리액트 핵심 코드와 실제 웹 앱 코드가 포함된 자바스크립트 리소스. 이를 통해 빈 <code>&lt;div&gt;</code> 안에 리액트 앱을 채워 넣고 사용자 인터페이스를 생성할 것입니다.</li>
</ul>
<figure>
<img src="./1-client-side-rendering-process.jpg" width="100%" alt="그림 1. 클라이언트 사이드 렌더링 과정"/>
<figcaption style="text-align: center">그림 1. 클라이언트 사이드 렌더링 과정 (<a target="_blank" href="./1-client-side-rendering-process.jpg">크게 보기</a>)</figcaption>
</figure>

<!-- A web app under this process is only fully interactive once JavaScript has fully completed its operations. You can probably already see the tension here that comes with an **improved developer experience (DX) that negatively impacts the user experience (UX)**. -->
<p>이 방식을 따르는 웹 앱은 자바스크립트의 작업이 모두 완료된 이후에야 비로소 사용자와 상호작용을 할 수 있습니다. 이는 개발자 경험(DX)에는 좋지만, <strong>사용자 경험(UX)에는 부정적인 영향</strong>을 주게 됩니다.</p>
<!-- The truth is that there were (and are) pros and cons to CSR in React. Looking at the positives, web applications delivered **smooth, quick transitions** that reduced the overall time it took to load a page, thanks to reactive components that update with user interactions without triggering page refreshes. CSR lightens the server load and allows us to serve assets from speedy content delivery networks (CDNs) capable of delivering content to users from a server location geographically closer to the user for even more optimized page loads. -->
<p>사실, 리액트의 CSR에는 장단점이 존재합니다. 장점은 다음과 같습니다. 화면 전체를 새로고침 하지 않고 업데이트되는 반응형 컴포넌트 덕분에 매끄럽고 빠른 페이지 전환을 제공합니다. 페이지 로딩에 걸리는 시간을 단축합니다. 또한 서버 부담을 줄이고, 빠른 CDN(content delivery network)을 통해 사용자가 지리적으로 가까운 서버에서 콘텐츠를 제공받을 수 있게 해줍니다.</p>
<!-- There are also not-so-great consequences that come with CSR, most notably perhaps that components could fetch data independently, leading to [waterfall network requests](https://blog.sentry.io/fetch-waterfall-in-react/) that dramatically slow things down. This may sound like a minor nuisance on the UX side of things, but the damage can actually be quite large on a human level. Eric Bailey’s [“Modern Health, frameworks, performance, and harm”](https://ericwbailey.design/published/modern-health-frameworks-performance-and-harm/) should be a cautionary tale for all CSR work. -->
<p>그러나 CSR에는 단점도 있습니다. 예컨대 각 컴포넌트가 독립적으로 데이터를 가져올 수 있어서, <a target="_blank" rel="noopener" href="https://blog.sentry.io/fetch-waterfall-in-react/">워터폴 네트워크 요청</a>이 발생하면 전체 속도가 현저히 느려질 수 있습니다. 이는 UX 측면에서 단순한 불편함 정도로 여길 수도 있지만, 실은 사용자에게 상당한 손해를 끼칠 수 있는 문제입니다. Eric Bailey의 <a target="_blank" rel="noopener" href="https://ericwbailey.design/published/modern-health-frameworks-performance-and-harm/">“Modern Health, frameworks, performance, and harm”</a>은 모든 CSR 작업에 경고하는 이야기라고 할 것입니다.</p>
<!-- Other negative CSR consequences are not quite as severe but still lead to damage. For example, it used to be that an HTML document containing nothing but metadata and an empty `<div>` was illegible to search engine crawlers that never get the fully-rendered experience. While that’s solved today, the SEO hit at the time was an anchor on company sites that rely on search engine traffic to generate revenue. -->
<p>또 다른 부정적인 CSR 결과로 검색 엔진 크롤러를 들 수 있습니다. 크롤러는 CSR 페이지에 대해 메타데이터와 빈 <code>&lt;div&gt;</code>만 있는 HTML 문서를 접할 수 있을 뿐, 렌더링이 완료된 페이지 전체 정보를 수집하지 못합니다. 최근에는 이 문제가 해결되었지만, 당시 검색 엔진 트래픽에 의존하는 회사 사이트들에는 심각한 문제였습니다.</p>
<!-- ## 2. The Shift: Server-Side Rendering (SSR) -->
<h2 id="2-전환-서버-사이드-렌더링"><a href="#2-전환-서버-사이드-렌더링" class="headerlink" title="2. 전환: 서버 사이드 렌더링"></a>2. 전환: 서버 사이드 렌더링</h2><!-- Something needed to change. CSR presented developers with a powerful new approach for constructing speedy, interactive interfaces, but users everywhere were inundated with blank screens and loading indicators to get there. The solution was to move the rendering experience from the **client** to the **server**. I know it sounds funny that we needed to improve something by going back to the way it was before. -->
<p>변화가 필요했습니다. CSR은 개발자에게 빠르고 인터랙티브한 인터페이스를 구축할 수 있는 강력한 접근 방식을 제공했지만, 전 세계 사용자는 빈 화면과 로딩 인디케이터에 시달려야 했습니다. 해결책은 렌더링 경험을 <strong>클라이언트</strong>에서 <strong>서버</strong>로 이전하는 것이었습니다. <em>개선하기 위해 기존 방식으로 돌아간다는 점이 아이러니해 보일 수도 있겠네요.</em></p>
<!-- So, yes, React gained server-side rendering (SSR) capabilities. At one point, SSR was such a topic in the React community that [it had a moment](https://sentry.io/resources/moving-to-server-side-rendering/) in the spotlight. The move to SSR brought significant changes to app development, specifically in how it influenced React behavior and how content could be delivered by way of servers instead of browsers. -->
<p>그래서 리액트는 서버 사이드 렌더링(Server-Side Rendering, SSR) 기능을 도입했습니다. SSR은 리액트 커뮤니티 내에서 큰 논쟁거리가 되었으며, 한 때 <a target="_blank" rel="noopener" href="https://sentry.io/resources/moving-to-server-side-rendering/">큰 주목</a>을 받기도 했습니다. SSR 도입은 앱 개발 방식에 중대한 변화를 불러왔습니다. 리액트의 동작 방식이 크게 달라졌고, 브라우저 대신 서버를 통해 콘텐츠를 전달할 수 있게 되었습니다.</p>
<figure>
<img src="./2-diagram-server-side-rendering-process.jpg" width="100%" alt="그림 2. 서버 사이드 렌더링 과정"/>
<figcaption style="text-align: center">그림 2. 서버 사이드 렌더링 과정
(<a target="_blank" href="./2-diagram-server-side-rendering-process.jpg">크게 보기</a>)
</figcaption>
</figure>

<!-- ### A. Addressing CSR Limitations -->
<h3 id="2-1-CSR-한계-해결"><a href="#2-1-CSR-한계-해결" class="headerlink" title="2.1. CSR 한계 해결"></a>2.1. CSR 한계 해결</h3><!-- Instead of sending a blank HTML document with SSR, we rendered the initial HTML on the server and sent it to the browser. The browser was able to immediately start displaying the content without needing to show a loading indicator. This significantly improves the [First Contentful Paint (FCP) performance metric in Web Vitals](https://docs.sentry.io/product/performance/web-vitals/web-vitals-concepts/#first-contentful-paint-fcp). -->
<p>SSR에서는 빈 HTML 문서를 보내는 대신, 서버에서 초기 HTML을 렌더링 하여 브라우저로 전송합니다. 브라우저는 로딩 인디케이터를 보여줄 필요 없이 즉시 콘텐츠를 표시할 수 있습니다. 이는 웹 성능(Web Vitals) 중 <a target="_blank" rel="noopener" href="https://docs.sentry.io/product/performance/web-vitals/web-vitals-concepts/#first-contentful-paint-fcp">First Contentful Paint (FCP) 성능 지표</a>를 크게 개선합니다.</p>
<!-- Server-side rendering also fixed the SEO issues that came with CSR. Since the crawlers received the content of our websites directly, they were then able to index it right away. The data fetching that happens initially also takes place on the server, which is a plus because it’s closer to the data source and can eliminate fetch waterfalls [_if done properly_](https://blog.sentry.io/fetch-waterfall-in-react/#fetch-data-on-server-to-avoid-a-fetch-waterfall). -->
<p>서버 사이드 렌더링은 CSR에서 발생한 SEO 문제도 해결했습니다. 크롤러가 웹사이트의 콘텐츠를 직접 받아 인덱싱할 수 있게 되었기 때문입니다. 또한 클라이언트보다 데이터 소스에 가까운 서버에서 초기 데이터 페칭을 수행하므로, <a target="_blank" rel="noopener" href="https://blog.sentry.io/fetch-waterfall-in-react/#fetch-data-on-server-to-avoid-a-fetch-waterfall"><em>오류 없이 잘 수행된다면</em></a> 데이터 요청의 워터폴 현상을 없앨 수 있게 되었습니다.</p>
<!-- ### Hydration -->
<h3 id="2-2-하이드레이션"><a href="#2-2-하이드레이션" class="headerlink" title="2.2. 하이드레이션"></a>2.2. 하이드레이션</h3><!-- SSR has its own complexities. For React to make the static HTML received from the server interactive, it needs to hydrate it. Hydration is the process that happens when React reconstructs its Virtual Document Object Model (DOM) on the client side based on what was in the DOM of the initial HTML. -->
<p>SSR은 복잡한 과정을 거칩니다. 리액트가 서버에서 받은 정적 HTML을 인터랙티브하게 만들기 위해서는 <strong>하이드레이션</strong>(Hydration)이 필요합니다. 하이드레이션은 초기 HTML의 DOM을 기반으로 클라이언트 측에서 가상 문서 객체 모델(Virtual DOM)을 재구성하는 과정입니다.</p>
<!-- > **Note:** React maintains its own [Virtual DOM](https://legacy.reactjs.org/docs/faq-internals.html) because it’s faster to figure out updates on it instead of the actual DOM. It synchronizes the actual DOM with the Virtual DOM when it needs to update the UI but performs the diffing algorithm on the Virtual DOM. -->
<blockquote>
<p><strong>참고:</strong> 리액트는 실제 DOM보다 가상 DOM에서 업데이트를 파악하는 것이 빠르기 때문에 자체 <a target="_blank" rel="noopener" href="https://legacy.reactjs.org/docs/faq-internals.html">Virtual DOM</a>을 사용합니다. UI 업데이트가 필요할 때 가상 DOM과 실제 DOM을 동기화하지만, 변경 사항을 파악하는 알고리즘은 가상 DOM에서 수행됩니다.</p>
</blockquote>
<!-- We now have two flavors of Reacts: -->
<p>이제 리액트에는 두 가지 버전이 존재합니다.</p>
<!-- 1. A server-side flavor that knows how to render static HTML from our component tree, -->
<ol>
<li>컴포넌트 트리로부터 정적 HTML을 렌더링 하는 <strong>서버 사이드 버전</strong></li>
</ol>
<!-- 2. A client-side flavor that knows how to make the page interactive. -->
<ol start="2">
<li>페이지를 인터랙티브하게 만드는 <strong>클라이언트 사이드 버전</strong></li>
</ol>
<!-- We’re still shipping React and code for the app to the browser because — in order to hydrate the initial HTML — React needs the same components on the client side that were used on the server. During hydration, [React performs a process called](https://css-tricks.com/how-react-reconciliation-works/) [_reconciliation_](https://css-tricks.com/how-react-reconciliation-works/) in which it compares the server-rendered DOM with the client-rendered DOM and tries to identify differences between the two. If there are differences between the two DOMs, React attempts to fix them by rehydrating the component tree and updating the component hierarchy to match the server-rendered structure. And if there are still inconsistencies that cannot be resolved, React will throw errors to indicate the problem. This problem is commonly known as a hydration error. -->
<p>초기 HTML을 하이드레이트하기 위해서는 리액트와 앱 코드를 브라우저로 전송해야 합니다. 하이드레이션 과정에서 리액트는 서버에서 렌더링 된 DOM과 클라이언트에서 렌더링 된 DOM을 비교하여 차이점을 찾아내는 <a target="_blank" rel="noopener" href="https://css-tricks.com/how-react-reconciliation-works/"><em>재조정(reconciliation)</em></a> 작업을 수행합니다. 만약 두 DOM 사이에 차이가 있다면, 리액트는 컴포넌트 트리를 다시 하이드레이트하고, 컴포넌트 계층 구조를 서버에서 렌더링 된 구조에 맞추어 업데이트하려 합니다. 그래도 해결되지 않는 불일치가 있다면, 리액트는 문제를 알리기 위해 오류를 발생시킵니다. 일반적으로 이를 <em>‘하이드레이션 오류’</em>라고 합니다.</p>
<!-- ### SSR Drawbacks -->
<h3 id="2-3-SSR의-단점"><a href="#2-3-SSR의-단점" class="headerlink" title="2.3. SSR의 단점"></a>2.3. SSR의 단점</h3><!-- SSR is not a silver bullet solution that addresses CSR limitations. SSR comes with its own drawbacks. Since we moved the initial HTML rendering and data fetching to the server, those servers are now experiencing a much greater load than when we loaded everything on the client. -->
<p>SSR은 CSR의 한계를 해결하는 만능 해결책은 아닙니다. SSR 역시 단점이 있습니다. 초기 HTML 렌더링과 데이터 페칭을 서버로 옮겼기 때문에, 해당 서버들은 클라이언트에서 모든 것을 로드할 때보다 훨씬 더 큰 부하를 겪게 됩니다.</p>
<!-- Remember when I mentioned that SSR generally improves the FCP performance metric? That may be true, but the [Time to First Byte (TTFB) performance metric](https://docs.sentry.io/product/performance/web-vitals/web-vitals-concepts/#time-to-first-byte-ttfb) took a negative hit with SSR. The browser literally has to wait for the server to fetch the data it needs, generate the initial HTML, and send the first byte. And while TTFB is not a Core Web Vital metric in itself, it influences the metrics. A negative TTFB leads to negative Core Web Vitals metrics. -->
<p>일반적으로 SSR 도입은 FCP 성능 지표를 개선한다고 합니다. 이는 대체로 맞지만, <a target="_blank" rel="noopener" href="https://docs.sentry.io/product/performance/web-vitals/web-vitals-concepts/#time-to-first-byte-ttfb">Time to First Byte (TTFB) 성능 지표</a> 만큼은 그렇지 않습니다. 브라우저는 서버가 필요한 데이터를 페칭하고 초기 HTML을 생성하여 첫 바이트를 전송할 때까지 마냥 기다려야 합니다. TTFB 자체는 핵심 웹 성능에 해당하지 않지만, 다른 성능 지표에 영향을 줍니다. 즉, TTFB가 나쁘면 핵심 웹 성능 지표가 하락합니다.</p>
<!-- Another drawback of SSR is that the entire page is unresponsive until client-side React has finished hydrating it. Interactive elements cannot listen and “react” to user interactions before React hydrates them, i.e., React attaches the intended event listeners to them. The hydration process is typically fast, but the internet connection and hardware capabilities of the device in use can slow down rendering by a noticeable amount. -->
<p>SSR의 또 다른 단점은 클라이언트 측의 리액트가 하이드레이션을 완료하기 전까지는 전체 페이지가 제대로 동작하지 않는다는 점입니다. 예를 들어, 리액트가 이벤트 리스너를 부착하는 과정을 수행하기 전까지는 인터랙티브 요소들이 사용자 상호작용에 대해 “반응”하지 않습니다. 하이드레이션 과정은 일반적으로 빠르게 이뤄지지만, 사용 중인 기기의 인터넷 연결 상태나 하드웨어 성능에 따라 속도가 눈에 띄게 느려질 수도 있습니다.</p>
<!-- ## 3. The Present: A Hybrid Approach -->
<h2 id="3-현재-하이브리드-접근-방식"><a href="#3-현재-하이브리드-접근-방식" class="headerlink" title="3. 현재: 하이브리드 접근 방식"></a>3. 현재: 하이브리드 접근 방식</h2><!-- So far, we have covered two different flavors of React rendering: CSR and SSR. While the two were attempts to improve one another, we now get the best of both worlds, so to speak, as SSR has branched into three additional React flavors that offer a hybrid approach in hopes of reducing the limitations that come with CSR and SSR. -->
<p>지금까지 리액트 렌더링의 두 가지 형태, 즉 CSR과 SSR에 대해 살펴보았습니다. 이 두 가지 방식이 서로의 한계를 보완하려는 시도였다면, 이제는 CSR과 SSR의 한계를 줄이기 위해 SSR을 다시 세 가지 방식으로 분화한 하이브리드 접근 방식을 취하고 있습니다.</p>
<!-- We’ll look at the first two — **static site generation and incremental static regeneration** — before jumping into an entire discussion on React Server Components, the third flavor. -->
<p>먼저 <strong>정적 사이트 생성(Static Site Generation, SSG)</strong> 및 <strong>증분 정적 재생성(Incremental Static Regeneration, ISR)</strong>에 대해 살펴본 후, 세 번째 유형인 RSC로 넘어가겠습니다.</p>
<!-- ### Static Site Generation (SSG) -->
<h3 id="3-1-정적-사이트-생성-SSG"><a href="#3-1-정적-사이트-생성-SSG" class="headerlink" title="3.1. 정적 사이트 생성 (SSG)"></a>3.1. 정적 사이트 생성 (SSG)</h3><!-- Instead of regenerating the same HTML code on every request, we came up with SSG. This React flavor compiles and builds the entire app at build time, generating static (as in vanilla HTML and CSS) files that are, in turn, hosted on a speedy CDN. -->
<p>SSG는 요청마다 동일한 HTML 코드를 재생성하지 않습니다. 빌드 타임에 전체 앱을 컴파일하고 구축하여 정적인 순수 HTML과 CSS 파일을 생성하고, 이를 빠른 CDN에 호스팅합니다.</p>
<!-- As you might suspect, this hybrid approach to rendering is a nice fit for smaller projects where the content doesn’t change much, like a marketing site or a personal blog, as opposed to larger projects where content may change with user interactions, like an e-commerce site. -->
<p>예상할 수 있듯이, 이 접근 방식은 콘텐츠가 크게 변하지 않는 소규모 프로젝트(예: 마케팅 사이트나 개인 블로그)에는 적합하지만, 사용자 상호작용에 따라 콘텐츠가 자주 변경되는 대규모 프로젝트(예: 전자상거래 사이트)에는 적합하지 않습니다.</p>
<!-- SSG reduces the burden on the server while improving performance metrics related to TTFB because the server no longer has to perform heavy, expensive tasks for re-rendering the page. -->
<p>SSG는 서버의 부담을 줄이는 동시에 서버가 페이지를 다시 렌더링 하기 위해 무거운 작업을 수행할 필요가 없으므로 TTFB와 관련된 성능 지표를 개선합니다.</p>
<!-- ### Incremental Static Regeneration (ISR) -->
<h3 id="3-2-증분-정적-재생성-ISR"><a href="#3-2-증분-정적-재생성-ISR" class="headerlink" title="3.2. 증분 정적 재생성 (ISR)"></a>3.2. 증분 정적 재생성 (ISR)</h3><!-- One SSG drawback is having to rebuild all of the app’s code when a content change is needed. The content is set in stone — being static and all — and there’s no way to change just one part of it without rebuilding the whole thing. -->
<p>SSG는 콘텐츠 변경이 필요할 때 앱의 모든 코드를 다시 빌드해야 한다는 단점이 있습니다. 정적이라는 특성상 콘텐츠가 고정되어 있어서 전체를 다시 빌드하지 않고 일부만 변경할 수는 없습니다.</p>
<!-- The Next.js team created the second hybrid flavor of React that addresses the drawback of complete SSG rebuilds: **incremental static regeneration (ISR)**. The name says a lot about the approach in that ISR only rebuilds what’s needed instead of the entire thing. We generate the “initial version” of the page statically during build time but are also able to rebuild any page containing stale data after a user lands on it (i.e., the server request triggers the data check). -->
<p>Next.js 팀은 전체를 빌드해야 한다는 SSG의 단점을 해결하기 위해 <strong>증분 정적 재생성(ISR)</strong>이라는 리액트의 두 번째 하이브리드 방식을 만들었습니다. 이름에서 알 수 있듯이, ISR은 전체를 다시 빌드하는 대신 필요한 부분만 빌드합니다. 초기 빌드 시기에는 (SSG와 마찬가지로) 페이지의 “초기 버전”을 정적으로 생성합니다. 이후 사용자가 어떤 페이지에 접근하여 서버 요청이 발생하면 데이터를 확인하여, 오래된 데이터가 포함된 경우에는 해당 페이지를 다시 빌드할 수 있습니다.</p>
<!-- From that point on, the server will serve new versions of that page statically in increments when needed. That makes ISR a hybrid approach that is neatly positioned between SSG and traditional SSR. -->
<p>이후부터 서버는 필요한 때에만 점진적으로 해당 페이지의 새로운 버전을 정적으로 제공하게 됩니다. 즉, ISR은 SSG와 전통적인 SSR을 잘 섞은 하이브리드 접근 방식입니다.</p>
<!-- At the same time, ISR does not address the “stale content” symptom, where users may visit a page before it has finished being generated. Unlike SSG, ISR needs an actual server to regenerate individual pages in response to a user’s browser making a server request. That means we lose the valuable ability to deploy ISR-based apps on a CDN for optimized asset delivery. -->
<p>그렇지만 ISR을 적용하더라도 문제가 있습니다. 사용자가 새 버전의 콘텐츠가 생성되기 전에 페이지를 방문하면 여전히 ‘오래된 콘텐츠’를 보게 됩니다. 또한 ISR은 SSG와 달리 개별 페이지를 재생성하기 위해 실제 서버가 필요합니다. 이는 최적화된 자산 전달을 위해 CDN에 앱을 배포한 의미를 퇴색시킵니다.</p>
<!-- ## 4. The Future: React Server Components -->
<h2 id="4-미래-리액트-서버-컴포넌트-RSC"><a href="#4-미래-리액트-서버-컴포넌트-RSC" class="headerlink" title="4. 미래: 리액트 서버 컴포넌트 (RSC)"></a>4. 미래: 리액트 서버 컴포넌트 (RSC)</h2><!-- Up until this point, we’ve juggled between CSR, SSR, SSG, and ISR approaches, where all make some sort of trade-off, negatively affecting performance, development complexity, and user experience. Newly introduced [React Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components) (RSC) aim to address most of these drawbacks by allowing us — the developer — to choose the right rendering strategy for each individual React component. -->
<p>지금까지는 필요에 따라 CSR, SSR, SSG, ISR 방식을 선택하여 사용해 왔습니다. 각각은 성능, 개발의 복잡성, 사용자 경험에 부정적인 영향을 미치는 일종의 트레이드오프가 있었습니다. 새로 도입된 <a target="_blank" rel="noopener" href="https://nextjs.org/docs/app/building-your-application/rendering/server-components">RSC</a>는 개발자가 <strong>개별 리액트 컴포넌트마다 올바른 렌더링 전략을 선택</strong>할 수 있도록 하여 위의 단점 대부분을 해결하고자 합니다.</p>
<!-- RSCs can significantly reduce the amount of JavaScript shipped to the client since we can selectively decide which ones to serve statically on the server and which render on the client side. There’s a lot more control and flexibility for striking the right balance for your particular project. -->
<p>RSC를 사용하면 서버에서 정적으로 처리할 컴포넌트와 클라이언트에서 렌더링할 컴포넌트를 선택적으로 결정할 수 있어 클라이언트에 전송되는 자바스크립트 양을 크게 줄일 수 있습니다. 이를 통해 각 프로젝트의 특성에 맞게 최적의 균형을 맞추는 데 더 많은 자유도와 유연성을 확보할 수 있습니다.</p>
<!-- > **Note:** It’s important to keep in mind that as we adopt more advanced architectures, like RSCs, monitoring solutions become invaluable. Sentry offers robust [performance monitoring](https://docs.sentry.io/product/performance/) and error-tracking capabilities that help you keep an eye on the real-world performance of your RSC-powered application. Sentry also helps you gain insights into how your releases are performing and how stable they are, which is yet another crucial feature to have while migrating your existing applications to RSCs. Implementing Sentry in an RSC-enabled framework like [Next.js](https://sentry.io/for/nextjs/) is as easy as running a single terminal command. -->
<blockquote>
<p><strong>참고:</strong> RSC와 같은 고급 아키텍처를 도입할 때 모니터링은 매우 중요합니다. Sentry는 RSC 기반 애플리케이션의 실제 성능을 모니터링하고, 릴리즈의 성능 및 안정성에 대한 통찰력을 제공하는 강력한 <a target="_blank" rel="noopener" href="https://docs.sentry.io/product/performance/">성능 모니터링</a> 및 오류 추적 기능을 제공합니다. <a target="_blank" rel="noopener" href="https://sentry.io/for/nextjs/">Next.js</a>와 같은 RSC를 지원하는 프레임워크에 Sentry를 구현하는 것은 단 한 줄의 터미널 명령으로도 충분합니다.</p>
</blockquote>
<!-- But what exactly is an RSC? Let’s pick one apart to see how it works under the hood. -->
<p>그렇다면 RSC란 정확히 무엇일까요? 이제 그 내부 작동 방식을 살펴보겠습니다.</p>
<!-- ## 5. The Anatomy of React Server Components -->
<h2 id="5-RSC의-구성-요소"><a href="#5-RSC의-구성-요소" class="headerlink" title="5. RSC의 구성 요소"></a>5. RSC의 구성 요소</h2><!-- This new approach introduces two types of rendering components: Server Components and Client Components. The differences between these two are not how they function but where they execute and the environments they’re designed for. At the time of this writing, the only way to use RSCs is through React frameworks. And at the moment, there are only three frameworks that support them: [Next.js](https://nextjs.org/docs/app/building-your-application/rendering/server-components), [Gatsby](https://www.gatsbyjs.com/docs/conceptual/partial-hydration/), and [RedwoodJS](https://redwoodjs.com/blog/rsc-now-in-redwoodjs). -->
<p>RSC는 컴포넌트를 <strong>서버 컴포넌트</strong>와 <strong>클라이언트 컴포넌트</strong>의 두 가지 유형으로 구분하고자 합니다. 둘의 차이는 작동 방식이 아니라, 어디에서 실행되는지, 또한 어떤 환경을 위해 설계되었는지에 있습니다. 이 글을 쓰는 시점에서 RSC는 RSC를 지원하는 프레임워크를 통해서만 사용할 수 있습니다. 현재까지는 <a target="_blank" rel="noopener" href="https://nextjs.org/docs/app/building-your-application/rendering/server-components">Next.js</a>, <a target="_blank" rel="noopener" href="https://www.gatsbyjs.com/docs/conceptual/partial-hydration/">Gatsby</a>, <a target="_blank" rel="noopener" href="https://redwoodjs.com/blog/rsc-now-in-redwoodjs">RedwoodJS</a>의 세 프레임워크에서만 지원합니다.</p>
<figure>
<img src="./3-wire-diagram-server-client-components.jpg" width="100%" alt="그림 3. 서버 컴포넌트와 클라이언트 컴포넌트로 구성된 아키텍처 예시"/>
<figcaption style="text-align: center">그림 3. 서버 컴포넌트와 클라이언트 컴포넌트로 구성된 아키텍처 예시(<a target="_blank" href="./3-wire-diagram-server-client-components.jpg">크게 보기</a>)</figcaption>
</figure>

<!-- ### Server Components -->
<h3 id="5-1-서버-컴포넌트"><a href="#5-1-서버-컴포넌트" class="headerlink" title="5.1. 서버 컴포넌트"></a>5.1. 서버 컴포넌트</h3><!-- Server Components are designed to be executed on the server, and their code is never shipped to the browser. The HTML output and any props they might be accepting are the only pieces that are served. This approach has multiple performance benefits and user experience enhancements: -->
<p>서버 컴포넌트는 서버에서 실행되도록 설계되었으며, 그 코드가 브라우저로는 절대 전송되지 않습니다. 서버 컴포넌트는 오직 HTML 출력물과 컴포넌트가 받을 props만을 제공합니다. 이 접근 방식은 여러 가지 성능상 이점과 향상된 사용자 경험을 제공합니다.</p>
<!-- - **Server Components allow for large dependencies to remain on the server side.**
Imagine using a large library for a component. If you’re executing the component on the client side, it means that you’re also shipping the full library to the browser. With Server Components, you’re only taking the static HTML output and avoiding having to ship any 자바스크립트 to the browser. Server Components are truly static, and they remove the whole hydration step. -->
<ul>
<li><strong>서버 컴포넌트는 용량이 큰 의존성 정보를 서버에 남겨둘 수 있습니다.</strong><br>어떤 컴포넌트에 용량이 큰 라이브러리를 사용한다고 가정해 봅시다. 클라이언트 측에서 컴포넌트를 실행하면 해당 라이브러리 전체를 브라우저로 전달해야 합니다. 하지만 서버 컴포넌트를 사용하면 정적인 HTML 출력물만 전달하고, 자바스크립트는 브라우저로 보내지 않아도 됩니다. 이런 경우 서버 컴포넌트는 문자 그대로 정적이어서, 하이드레이션 과정 자체를 생략하게 됩니다.</li>
</ul>
<!-- - **Server Components are located much closer to the data sources — e.g., databases or file systems — they need to generate code.**
They also leverage the server’s computational power to speed up compute-intensive rendering tasks and send only the generated results back to the client. They are also generated in a single pass, which [avoids request waterfalls and HTTP round trips](https://blog.sentry.io/fetch-waterfall-in-react/#fetch-data-on-server-to-avoid-a-fetch-waterfall). -->
<ul>
<li><strong>서버 컴포넌트는 코드 생성에 필요한 데이터 소스(예: 데이터베이스나 파일 시스템)에 훨씬 가까이 위치합니다.</strong><br>서버의 연산 능력을 활용하여 연산을 많이 필요로 하는 렌더링 작업을 빠르게 수행하고, 생성된 결과만 클라이언트에 전달합니다. 단일 패스로 생성되기 때문에 <a target="_blank" rel="noopener" href="https://blog.sentry.io/fetch-waterfall-in-react/#fetch-data-on-server-to-avoid-a-fetch-waterfall">워터폴 요청과 HTTP 왕복 횟수를 줄일 수 있습니다</a>.</li>
</ul>
<!-- - **Server Components safely keep sensitive data and logic away from the browser.**
That’s thanks to the fact that personal tokens and API keys are executed on a secure server rather than the client. -->
<ul>
<li><strong>서버 컴포넌트는 민감한 데이터와 로직을 브라우저로부터 안전하게 격리합니다.</strong><br>이는 개인 토큰이나 API 키가 클라이언트가 아닌 안전한 서버에서 실행되기 때문입니다.</li>
</ul>
<!-- - **The rendering results can be cached and reused between subsequent requests and even across different sessions.**
This significantly reduces rendering time, as well as the overall amount of data that is fetched for each request. -->
<ul>
<li><strong>렌더링 결과는 캐시 되어 이후 요청이나 다른 세션 간에 재사용될 수 있습니다.</strong><br>이에 따라 렌더링 시간이 크게 단축되고, 요청마다 페칭되는 전체 데이터양이 줄어듭니다.</li>
</ul>
<!-- This architecture also makes use of **HTML streaming**, which means the server defers generating HTML for specific components and instead renders a fallback element in their place while it works on sending back the generated HTML. Streaming Server Components wrap components in [`<Suspense>`](https://react.dev/reference/react/Suspense) tags that provide a fallback value. The implementing framework uses the fallback initially but streams the newly generated content when it‘s ready. We’ll talk more about streaming, but let’s first look at Client Components and compare them to Server Components. -->
<p>또한 서버 컴포넌트는 <strong>HTML 스트리밍</strong>을 활용합니다. 서버가 특정 컴포넌트에 대한 HTML 생성을 지연하고, 그동안 그 자리에 폴백(fallback) 값을 렌더링했다가, 이후 생성된 HTML을 스트리밍 방식으로 전달하는 것을 의미합니다. 스트리밍 서버 컴포넌트는 <a target="_blank" rel="noopener" href="https://react.dev/reference/react/Suspense"><code>&lt;Suspense&gt;</code></a> 태그로 컴포넌트를 감싸서 폴백을 제공합니다. 초기에는 폴백이 표시되다가 새로운 콘텐츠가 준비되면 스트리밍됩니다.</p>
<p>스트리밍에 대해서는 뒤에 더 자세히 알아봅시다. 그 전에 우선 클라이언트 컴포넌트와 서버 컴포넌트를 비교해 보죠.</p>
<!-- ### Client Components -->
<h3 id="5-2-클라이언트-컴포넌트"><a href="#5-2-클라이언트-컴포넌트" class="headerlink" title="5.2. 클라이언트 컴포넌트"></a>5.2. 클라이언트 컴포넌트</h3><!-- Client Components are the components we already know and love. They’re executed on the client side. Because of this, Client Components are capable of handling user interactions and have access to the browser APIs like **localStorage** and geolocation. -->
<p>클라이언트 컴포넌트는 우리가 이미 잘 알고 있는 컴포넌트입니다. 이들은 클라이언트 측에서 실행되며, 사용자 상호작용을 처리하고 <code>localStorage</code>나 <code>geolocation</code> 같은 브라우저 API에 접근할 수 있습니다.</p>
<!-- The term “Client Component” doesn’t describe anything new; they merely are given the label to help distinguish the “old” CSR components from Server Components. Client Components are defined by a [`"use client"`](https://react.dev/reference/react/use-server) directive at the top of their files. -->
<p>“클라이언트 컴포넌트”라는 용어는 새로운 개념을 설명하는 것이 아닙니다. 단지 “기존”의 CSR 컴포넌트와 서버 컴포넌트를 구분하기 위해 사용됩니다. 클라이언트 컴포넌트는 파일 상단에 <a target="_blank" rel="noopener" href="https://react.dev/reference/react/use-server"><code>&quot;use client&quot;</code></a> 지시어로 정의합니다.</p>
<!-- <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line marked"> --&gt;</span><br><span class="line marked">&lt;!-- </span><br></pre></td></tr></table></figure> -->
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;use client&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">LikeButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">likePost</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;likePost&#125;</span>&gt;</span>Like<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- In Next.js, all components are Server Components by default. That’s why we need to explicitly define our Client Components with `"use client"`. There’s also a `"use server"` directive, but it’s used for Server Actions (which are RPC-like actions that invoked from the client, but executed on the server). You don’t use it to define your Server Components. -->
<p>Next.js는 기본적으로 모든 컴포넌트를 서버 컴포넌트로 취급합니다. 따라서 클라이언트 컴포넌트는 명시적으로 <code>&quot;use client&quot;</code>로 정의해야 합니다. 물론 <code>&quot;use server&quot;</code> 지시어도 존재하지만, 이는 서버 액션<em>-클라이언트에서 호출하지만, 실행은 서버에서 이뤄지는 RPC(Remote Procedure Call)와 유사한 액션-</em>을 위해 사용하며, 서버 컴포넌트를 정의하는 데 사용하지는 않습니다.</p>
<!-- You might (rightfully) assume that Client Components are only rendered on the client, but Next.js renders Client Components on the server to generate the initial HTML. As a result, browsers can immediately start rendering them and then perform hydration later. -->
<p>클라이언트 컴포넌트는 오직 클라이언트에서 렌더링 된다고 생각할 수 있습니다. 그러나 Next.js는 초기 HTML 생성을 위해 서버에서 클라이언트 컴포넌트를 렌더링 합니다. 그 결과로 브라우저는 이를 즉시 렌더링할 수 있으며, 이후 하이드레이션 과정을 거칩니다.</p>
<!-- ### The Relationship Between Server Components and Client Components -->
<h3 id="5-3-서버-컴포넌트와-클라이언트-컴포넌트의-관계"><a href="#5-3-서버-컴포넌트와-클라이언트-컴포넌트의-관계" class="headerlink" title="5.3. 서버 컴포넌트와 클라이언트 컴포넌트의 관계"></a>5.3. 서버 컴포넌트와 클라이언트 컴포넌트의 관계</h3><!-- Client Components can only explicitly import other Client Components. In other words, we’re unable to import a Server Component into a Client Component because of re-rendering issues. But we can have Server Components in a Client Component’s subtree — only passed through the `children` prop. Since Client Components live in the browser and they handle user interactions or define their own state, they get to re-render often. When a Client Component re-renders, so will its subtree. But if its subtree contains Server Components, how would they re-render? They don’t live on the client side. That’s why the React team put that limitation in place. -->
<p>클라이언트 컴포넌트는 오직 다른 클라이언트 컴포넌트만 <em>명시적으로</em> 임포트 할 수 있습니다. 즉, 클라이언트 컴포넌트는 재 렌더링 문제 때문에 서버 컴포넌트를 직접 임포트 할 수 없습니다. 다만 <code>children</code> prop을 통해 클라이언트 컴포넌트의 하위에 서버 컴포넌트를 전달할 수는 있습니다. 클라이언트 컴포넌트는 브라우저에 존재하며 사용자 상호작용을 처리하거나 자체 상태를 정의하기 때문에, 재 렌더링이 빈번하게 발생합니다. 클라이언트 컴포넌트가 다시 렌더링 되면 서브 트리도 함께 렌더링 되는데, 그 서브 트리에 서버 컴포넌트가 포함되어 있다면 어떻게 렌더링할 수 있을까요? 서버 컴포넌트는 클라이언트에 존재하지 않습니다. 그래서 리액트 팀은 이러한 제약을 두게 된 것입니다.</p>
<blockquote>
<p>역자주: Next.js는 최초 서버에서 클라이언트 컴포넌트를 렌더링 합니다. 이때는 클라이언트 컴포넌트에서 서버 컴포넌트를 임포트 하더라도 문제가 되지 않습니다. 그러나 브라우저로 넘어간 이후에는 상황이 다릅니다. 브라우저로 넘어갈 때 서버 컴포넌트는 하이드레이션 과정에서 제외되어 존재하지 않게 됩니다. 이후 클라이언트 컴포넌트를 다시 렌더링 하라는 요청이 발생하면, 리액트는 서브 트리 중 <strong>일부(서버 컴포넌트)가 존재하지 않는다는 사실을 비로소 인지</strong>하게 되고, 렌더링 과정이 정상적으로 수행되지 않는 등의 문제가 발생할 것입니다. 리액트 팀은 이런 오류를 예방하기 위해 “클라이언트 컴포넌트는 서버 컴포넌트를 직접 임포트 할 수 없다”라는 제약을 만들었다는 설명입니다.</p>
</blockquote>
<!-- But hold on! We actually can import Server Components into Client Components. It’s just not a direct one-to-one relationship because the Server Component will be converted into a Client Component. If you’re using server APIs that you can’t use in the browser, you’ll get an error; if not — you’ll have a Server Component whose code gets “leaked” to the browser. -->
<p>그런데 잠깐! 실제로는 클라이언트 컴포넌트에서 서버 컴포넌트를 임포트 할 수 있긴 합니다. 단, 직접적으로 임포트 되는 것은 아니며, 서버 컴포넌트가 클라이언트 컴포넌트로 전환되어 전달됩니다. 이때, 만약 브라우저에서 사용할 수 없는 서버 API를 사용한다면 에러가 발생합니다. 그렇지 않다면 서버 컴포넌트의 코드가 브라우저로 “누출”된 형태로 처리됩니다.</p>
<!-- This is an incredibly important nuance to keep in mind as you work with RSCs. -->
<p>이 점은 RSC로 작업할 때 매우 중요한 개념이므로 유념해야 합니다.</p>
<!-- ## 6. The Rendering Lifecycle -->
<h2 id="6-렌더링-생명주기"><a href="#6-렌더링-생명주기" class="headerlink" title="6. 렌더링 생명주기"></a>6. 렌더링 생명주기</h2><!-- Here’s the order of operations that Next.js takes to stream contents: -->
<p>Next.js가 콘텐츠를 스트리밍하는 순서는 다음과 같습니다.</p>
<!-- 1. The app router matches the page’s URL to a Server Component, builds the component tree, and instructs the server-side React to render that Server Component and all of its children components.
2. During render, React generates an “RSC Payload”. The RSC Payload informs Next.js about the page and what to expect in return, as well as what to fall back to during a `<Suspense>`.
3. If React encounters a suspended component, it pauses rendering that subtree and uses the suspended component’s fallback value.
4. When React loops through the last static component, Next.js prepares the generated HTML and the RSC Payload before streaming it back to the client through one or multiple chunks.
5. The client-side React then uses the instructions it has for the RSC Payload and client-side components to render the UI. It also hydrates each Client Component as they load.
6. The server streams in the suspended Server Components as they become available as an RSC Payload. Children of Client Components are also hydrated at this time if the suspended component contains any. -->

<ol>
<li><p>앱 라우터가 페이지의 URL과 서버 컴포넌트를 매칭하여 컴포넌트 트리를 구성하고, 서버 측 리액트에 해당 서버 컴포넌트와 그 하위 컴포넌트 전부를 렌더링 하도록 지시합니다.</p>
</li>
<li><p>렌더링 하는 동안 리액트는 “RSC 페이로드”를 생성합니다. RSC 페이로드는 페이지 정보와 예상 결과물, <code>&lt;Suspense&gt;</code> 상태(보류 중)일 때 보여줄 폴백 등을 Next.js에 알려줍니다.</p>
</li>
<li><p>리액트가 보류된 컴포넌트를 만나면, 해당 서브 트리의 렌더링을 일시 중지하고, 보류된 컴포넌트의 폴백을 사용합니다.</p>
</li>
<li><p>마지막 정적 컴포넌트까지 순회를 마치고 나면, Next.js는 생성된 HTML과 RSC 페이로드를 준비하여, 하나 이상의 청크(chunk)로 나누어 클라이언트에 스트리밍합니다.</p>
</li>
<li><p>클라이언트 측 리액트는 전달받은 RSC 페이로드와 클라이언트 컴포넌트에 대한 지침에 따라 UI를 렌더링 합니다. 그리고 로드되는 각 클라이언트 컴포넌트를 하이드레이트합니다.</p>
</li>
<li><p>서버는 보류 중인 서버 컴포넌트가 준비되는 대로 RSC 페이로드 형태로 스트리밍합니다. 보류된 컴포넌트에 클라이언트 컴포넌트의 자식이 포함된 경우, 그들도 이 시점에 함께 하이드레이트합니다.</p>
</li>
</ol>
<!-- We will look at the RSC rendering lifecycle from the browser’s perspective momentarily. For now, the following figure illustrates the outlined steps we covered. -->
<p>아래 그림은 앞서 설명한 단계들을 도식화한 것입니다. (브라우저 관점에서의 RSC 렌더링 생명주기는 잠시 후에 살펴보겠습니다.)</p>
<figure>
<img src="./4-wire-diagram-rsc-rendering-lifecycle.jpg" width="100%" alt="그림 4. RSC 렌더링 라이프사이클 다이어그램"/>
<figcaption style="text-align: center">그림 4. RSC 렌더링 라이프사이클 다이어그램 (<a target="_blank" href="./4-wire-diagram-rsc-rendering-lifecycle.jpg">크게 보기</a>)</figcaption>
</figure>

<!-- We’ll see this operation flow from the browser’s perspective in just a bit. -->
<p>다음 장에서는 이 작업 흐름을 브라우저 관점에서 조금 더 살펴보겠습니다.</p>
<h2 id="7-RSC-페이로드"><a href="#7-RSC-페이로드" class="headerlink" title="7. RSC 페이로드"></a>7. RSC 페이로드</h2><!-- The RSC payload is a special data format that the server generates as it renders the component tree, and it includes the following: -->
<p>RSC 페이로드는 서버가 컴포넌트 트리를 렌더링 하면서 생성하는 특별한 데이터 형식으로, 다음과 같은 내용을 포함합니다.</p>
<!-- - The rendered HTML,
- Placeholders where the Client Components should be rendered,
- References to the Client Components’ JavaScript files,
- Instructions on which JavaScript files it should invoke,
- Any props passed from a Server Component to a Client Component. -->

<ul>
<li><p>렌더링 된 HTML</p>
</li>
<li><p>클라이언트 컴포넌트가 렌더링 되어야 할 자리를 표시하는 플레이스홀더(placeholder)</p>
</li>
<li><p>클라이언트 컴포넌트의 자바스크립트 파일에 대한 참조 정보</p>
</li>
<li><p>어떤 자바스크립트 파일을 실행해야 하는지에 대한 지시 사항</p>
</li>
<li><p>서버 컴포넌트에서 클라이언트 컴포넌트로 전달된 모든 props</p>
</li>
</ul>
<!-- There’s no reason to worry much about the RSC payload, but it’s worth understanding what exactly the RSC payload contains. Let’s examine an example (truncated for brevity) from a [demo app I created](https://github.com/nikolovlazar/rsc-forensics): -->
<p>물론 너무 깊게 파고들 필요는 없지만, RSC 페이로드에 어떤 내용이 담기는지를 파악하는 것은 도움이 될 것입니다. 다음은 저자가 만든 <a target="_blank" rel="noopener" href="https://github.com/nikolovlazar/rsc-forensics">데모 앱</a>에서 간략하게 일부만 잘라낸 예시입니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:<span class="variable constant_">HL</span>[<span class="string">&quot;/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2&quot;</span>,<span class="string">&quot;font&quot;</span>,&#123;<span class="string">&quot;crossOrigin&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;font/woff2&quot;</span>&#125;]</span><br><span class="line"><span class="number">2</span>:<span class="variable constant_">HL</span>[<span class="string">&quot;/_next/static/css/app/layout.css?v=1711137019097&quot;</span>,<span class="string">&quot;style&quot;</span>]</span><br><span class="line"><span class="number">0</span>:<span class="string">&quot;$L3&quot;</span></span><br><span class="line"><span class="number">4</span>:<span class="variable constant_">HL</span>[<span class="string">&quot;/_next/static/css/app/page.css?v=1711137019097&quot;</span>,<span class="string">&quot;style&quot;</span>]</span><br><span class="line"><span class="number">5</span>:I[<span class="string">&quot;(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js&quot;</span>,[<span class="string">&quot;app-pages-internals&quot;</span>,<span class="string">&quot;static/chunks/app-pages-internals.js&quot;</span>],<span class="string">&quot;&quot;</span>]</span><br><span class="line"><span class="number">8</span>:<span class="string">&quot;$Sreact.suspense&quot;</span></span><br><span class="line"><span class="attr">a</span>:I[<span class="string">&quot;(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js&quot;</span>,[<span class="string">&quot;app-pages-internals&quot;</span>,<span class="string">&quot;static/chunks/app-pages-internals.js&quot;</span>],<span class="string">&quot;&quot;</span>]</span><br><span class="line"><span class="attr">b</span>:I[<span class="string">&quot;(app-pages-browser)/./node_modules/next/dist/client/components/render-from-template-context.js&quot;</span>,[<span class="string">&quot;app-pages-internals&quot;</span>,<span class="string">&quot;static/chunks/app-pages-internals.js&quot;</span>],<span class="string">&quot;&quot;</span>]</span><br><span class="line"><span class="attr">d</span>:I[<span class="string">&quot;(app-pages-browser)/./src/app/global-error.jsx&quot;</span>,[<span class="string">&quot;app/global-error&quot;</span>,<span class="string">&quot;static/chunks/app/global-error.js&quot;</span>],<span class="string">&quot;&quot;</span>]</span><br><span class="line"><span class="attr">f</span>:I[<span class="string">&quot;(app-pages-browser)/./src/components/clearCart.js&quot;</span>,[<span class="string">&quot;app/page&quot;</span>,<span class="string">&quot;static/chunks/app/page.js&quot;</span>],<span class="string">&quot;ClearCart&quot;</span>]</span><br><span class="line"><span class="number">7</span>:[<span class="string">&quot;$&quot;</span>,<span class="string">&quot;main&quot;</span>,<span class="literal">null</span>,&#123;<span class="string">&quot;className&quot;</span>:<span class="string">&quot;page_main__GlU4n&quot;</span>,<span class="string">&quot;children&quot;</span>:[[<span class="string">&quot;$&quot;</span>,<span class="string">&quot;$Lf&quot;</span>,<span class="literal">null</span>,&#123;&#125;],[<span class="string">&quot;$&quot;</span>,<span class="string">&quot;$8&quot;</span>,<span class="literal">null</span>,&#123;<span class="string">&quot;fallback&quot;</span>:[<span class="string">&quot;$&quot;</span>,<span class="string">&quot;p&quot;</span>,<span class="literal">null</span>,&#123;<span class="string">&quot;children&quot;</span>:<span class="string">&quot;🌀 loading products...&quot;</span>&#125;],<span class="string">&quot;children&quot;</span>:<span class="string">&quot;$L10&quot;</span>&#125;]]&#125;]</span><br><span class="line"><span class="attr">c</span>:[[<span class="string">&quot;$&quot;</span>,<span class="string">&quot;meta&quot;</span>,<span class="string">&quot;0&quot;</span>,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;viewport&quot;</span>,<span class="string">&quot;content&quot;</span>:<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&#125;]...</span><br><span class="line"><span class="number">9</span>:[<span class="string">&quot;$&quot;</span>,<span class="string">&quot;p&quot;</span>,<span class="literal">null</span>,&#123;<span class="string">&quot;children&quot;</span>:[<span class="string">&quot;🛍️ &quot;</span>,<span class="number">3</span>]&#125;]</span><br><span class="line"><span class="number">11</span>:I[<span class="string">&quot;(app-pages-browser)/./src/components/addToCart.js&quot;</span>,[<span class="string">&quot;app/page&quot;</span>,<span class="string">&quot;static/chunks/app/page.js&quot;</span>],<span class="string">&quot;AddToCart&quot;</span>]</span><br><span class="line"><span class="number">10</span>:[<span class="string">&quot;$&quot;</span>,<span class="string">&quot;ul&quot;</span>,<span class="literal">null</span>,&#123;<span class="string">&quot;children&quot;</span>:[[<span class="string">&quot;$&quot;</span>,<span class="string">&quot;li&quot;</span>,<span class="string">&quot;1&quot;</span>,&#123;<span class="string">&quot;children&quot;</span>:[<span class="string">&quot;Gloves&quot;</span>,<span class="string">&quot; - $&quot;</span>,<span class="number">20</span>,[<span class="string">&quot;$...</span></span><br></pre></td></tr></table></figure>

<!-- To find this code in the demo app, open your browser’s developer tools at the Elements tab and look at the `<script>` tags at the bottom of the page. They’ll contain lines like: -->
<p>데모 앱에서 이 코드를 확인하려면, 브라우저 개발자 도구의 Elements 탭에서 페이지 하단의 <code>&lt;script&gt;</code> 태그들을 살펴보세요. 해당 태그들은 다음과 같은 형태의 라인을 포함합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="property">__next_f</span>.<span class="title function_">push</span>([<span class="number">1</span>,<span class="string">&quot;PAYLOAD_STRING_HERE&quot;</span>]).</span><br></pre></td></tr></table></figure>

<!-- Every line from the snippet above is an individual RSC payload. You can see that each line starts with a number or a letter, followed by a colon, and then an array that’s sometimes prefixed with letters. We won’t get into too deep in detail as to what they mean, but in general: -->
<p>위 스니펫의 각 라인은 개별적인 RSC 페이로드입니다. 각 라인은 숫자나 문자로 시작하고, 콜론 뒤에 배열이 옵니다. 배열에는 때때로 접두사가 붙는데, 간단히 설명하면 다음과 같습니다.</p>
<!-- - **`HL` payloads** are called “hints” and link to specific resources like CSS and fonts.
- **`I` payloads** are called “modules,” and they invoke specific scripts. This is how Client Components are being loaded as well. If the Client Component is part of the main bundle, it’ll execute. If it’s not (meaning it’s lazy-loaded), a fetcher script is added to the main bundle that fetches the component’s CSS and JavaScript files when it needs to be rendered. There’s going to be an I payload sent from the server that invokes the fetcher script when needed.
- **`"$"` payloads** are DOM definitions generated for a certain Server Component. They are usually accompanied by actual static HTML streamed from the server. That’s what happens when a suspended component becomes ready to be rendered: the server generates its static HTML and RSC Payload and then streams both to the browser. -->

<ul>
<li><p><strong><code>HL</code> 페이로드:</strong> “힌트”라고 하며, CSS나 폰트 같은 특정 리소스와 연결됩니다.</p>
</li>
<li><p><strong><code>I</code> 페이로드:</strong> “모듈”이라고 부르며, 특정 스크립트를 호출합니다. 클라이언트 컴포넌트도 이와 같은 방식으로 로드됩니다. 클라이언트 컴포넌트가 메인 번들의 일부인 경우에는 바로 실행됩니다. 그렇지 않다면(지연 로드의 경우) 해당 컴포넌트의 CSS와 자바스크립트 파일을 가져오는 명령이 담긴 페처(fetcher) 스크립트가 메인 번들에 추가됩니다. 그리고 필요할 때 페처 스크립트를 호출하는 I 페이로드가 서버에서 전송됩니다.</p>
</li>
<li><p><strong><code>&quot;$&quot;</code> 페이로드:</strong> 특정 서버 컴포넌트에 대해 생성된 DOM 정의입니다. 일반적으로 서버에서 스트리밍된 실제 정적 HTML과 함께 제공됩니다. 보류된 컴포넌트가 렌더링될 준비가 되면, 서버는 해당 컴포넌트의 정적 HTML과 RSC 페이로드를 생성하여 이들을 모두 브라우저로 스트리밍합니다.</p>
</li>
</ul>
<h2 id="8-스트리밍"><a href="#8-스트리밍" class="headerlink" title="8. 스트리밍"></a>8. 스트리밍</h2><!-- Streaming allows us to progressively render the UI from the server. With RSCs, each component is capable of fetching its own data. Some components are fully static and ready to be sent immediately to the client, while others require more work before loading. Based on this, Next.js splits that work into multiple chunks and streams them to the browser as they become ready. So, when a user visits a page, the server invokes all Server Components, generates the initial HTML for the page (i.e., the page shell), replaces the “suspended” components’ contents with their fallbacks, and streams all of that through one or multiple chunks back to the client. -->
<p>스트리밍(Streaming)은 서버로부터 UI를 점진적으로 렌더링할 수 있도록 해줍니다. RSC를 사용하면 각 컴포넌트가 자체적으로 데이터를 페칭할 수 있습니다. 어떤 컴포넌트는 완전히 정적이어서 즉시 클라이언트로 전송할 수 있지만, 다른 컴포넌트는 로드 전에 추가 작업이 필요할 수 있습니다. Next.js는 각 컴포넌트의 성격에 따라 여러 개의 청크로 분할하고, 각 청크가 준비되는 대로 브라우저로 스트리밍합니다. 즉, 사용자가 페이지를 방문하면 서버는 모든 서버 컴포넌트를 호출하여 페이지의 초기 HTML(페이지 껍질)을 생성하고, “보류된” 컴포넌트의 콘텐츠를 폴백으로 대체한 다음, 이를 하나 이상의 청크로 나누어 클라이언트에 스트리밍합니다.</p>
<!-- The server returns a `Transfer-Encoding: chunked` header that lets the browser know to expect streaming HTML. This prepares the browser for receiving multiple chunks of the document, rendering them as it receives them. We can actually see the header when opening Developer Tools at the Network tab. Trigger a refresh and click on the document request. -->
<p>서버는 브라우저에 HTML 스트리밍을 전송할 것이라는 신호로 <code>Transfer-Encoding: chunked</code> 헤더를 반환합니다. 브라우저는 이 헤더에 따라 여러 개의 청크를 수신할 준비를 하고, 수신하는 대로 렌더링 합니다. 개발자 도구의 Network 탭에서 문서 요청을 클릭하고 새로고침 하면 이 헤더를 확인할 수 있습니다.</p>
<figure>
<img src="./5-streaming-header.jpeg" width="100%" alt="그림 5. HTML 스트리밍을 준비하도록 브라우저에 신호 제공"/>
<figcaption style="text-align: center">그림 5. HTML 스트리밍을 준비하도록 브라우저에 신호 제공 (<a target="_blank" href="./5-streaming-header.jpeg">크게 보기</a>)</figcaption>
</figure>

<!-- We can also debug the way Next.js sends the chunks in a terminal with the `curl` command: -->
<p>터미널에서 <code>curl</code> 명령어를 사용해 Next.js가 청크를 전송하는 방식을 디버깅할 수도 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -D - --raw localhost:3000 &gt; chunked-response.txt</span><br></pre></td></tr></table></figure>

<figure>
<img src="./6-chunked-response.jpeg" width="100%" alt="그림 6. 청크 응답"/>
<figcaption style="text-align: center">그림 6. 청크 응답 (<a target="_blank" href="./6-chunked-response.jpeg">크게 보기</a>)</figcaption>
</figure>

<!-- You probably see the pattern. For each chunk, the server responds with the chunk’s size before sending the chunk’s contents. Looking at the output, we can see that the server streamed the entire page in 16 different chunks. At the end, the server sends back a zero-sized chunk, indicating the end of the stream. -->
<p>출력을 보면 패턴이 보입니다. 각 청크마다 서버가 청크의 크기를 먼저 응답한 다음에 청크의 내용을 전송하고 있습니다. 출력 결과를 보면 서버가 전체 페이지를 16개의 청크로 나누어 스트리밍했음을 확인할 수 있습니다. 마지막에는 크기가 0인 청크를 보내 스트리밍의 종료를 알리고 있습니다.</p>
<!-- The first chunk starts with the `<!DOCTYPE html>` declaration. The second-to-last chunk, meanwhile, contains the closing `</body>` and `</html>` tags. So, we can see that the server streams the entire document from top to bottom, then pauses to wait for the suspended components, and finally, at the end, closes the body and HTML before it stops streaming. -->
<p>첫 번째 청크는 <code>&lt;!DOCTYPE html&gt;</code> 선언으로 시작합니다. 마지막에서 두 번째 청크에는 닫는 <code>&lt;/body&gt;</code>와 <code>&lt;/html&gt;</code> 태그가 포함되어 있습니다. 즉, 서버가 문서를 상단부터 하단까지 스트리밍하고, 보류된 컴포넌트를 기다린 후, 마지막에 body와 HTML을 닫고 스트리밍을 종료하는 것을 볼 수 있습니다.</p>
<!-- Even though the server hasn’t completely finished streaming the document, the browser’s fault tolerance features allow it to draw and invoke whatever it has at the moment without waiting for the closing `</body>` and `</html>` tags. -->
<p>서버가 문서 전체 스트리밍을 완전히 마치지 않았더라도, 브라우저의 내결함성(fault tolerance) 기능 덕분에 닫는 <code>&lt;/body&gt;</code>와 <code>&lt;/html&gt;</code> 태그를 기다리지 않고도 현재 가지고 있는 내용을 그릴 수 있습니다.</p>
<h3 id="8-1-보류-중인-컴포넌트"><a href="#8-1-보류-중인-컴포넌트" class="headerlink" title="8.1. 보류 중인 컴포넌트"></a>8.1. 보류 중인 컴포넌트</h3><!-- We learned from the render lifecycle that when a page is visited, Next.js matches the RSC component for that page and asks React to render its subtree in HTML. When React stumbles upon a suspended component (i.e., async function component), it grabs its fallback value from the `<Suspense>` component (or the `loading.js` file if it’s a Next.js route), renders that instead, then continues loading the other components. Meanwhile, the RSC invokes the async component in the background, which is streamed later as it finishes loading. -->
<p>렌더링 생명주기에서 살펴보았듯이, 페이지를 방문하면 Next.js는 해당 페이지의 RSC 컴포넌트를 매칭하고, 리액트에 해당 서브 트리를 HTML로 렌더링 하도록 요청합니다. 리액트가 보류된 컴포넌트(비동기 컴포넌트)를 만나면, <code>&lt;Suspense&gt;</code> 컴포넌트(또는 Next.js 라우트의 경우 <code>loading.js</code> 파일)에서 해당 폴백을 가져와 대신 렌더링 하고, 나머지 컴포넌트 로딩을 이어서 진행합니다. 그와 동시에 RSC는 백그라운드에서 비동기 컴포넌트를 호출합니다. 이는 나중에 로드가 완료되면 스트리밍될 것입니다.</p>
<!-- At this point, Next.js has returned a full page of static HTML that includes either the components themselves (rendered in static HTML) or their fallback values (if they’re suspended). It takes the static HTML and RSC payload and streams them back to the browser through one or multiple chunks. -->
<p>이 시점에서 Next.js는 전체 페이지에 대한 정적 HTML을 반환합니다. 반환되는 HTML은 (정적 HTML로 렌더링 된) 컴포넌트들을 포함하는데, 보류된 컴포넌트의 경우에는 대신 그에 대응하는 폴백 값을 포함합니다. Next.js는 이 정적 HTML과 RSC 페이로드를 하나 이상의 청크로 나누어 브라우저로 스트리밍합니다.</p>
<figure>
<img src="./7-fallbacks-suspended-components.jpeg" width="100%" alt="그림 7. 콜백과 보류된 컴포넌트"/>
<figcaption style="text-align: center">그림 7. 콜백과 보류된 컴포넌트 (<a target="_blank" href="./7-fallbacks-suspended-components.jpeg">크게 보기</a>)</figcaption>
</figure>

<!-- As the suspended components finish loading, React generates HTML recursively while looking for other nested `<Suspense>` boundaries, generates their RSC payloads and then lets Next.js stream the HTML and RSC Payload back to the browser as new chunks. When the browser receives the new chunks, it has the HTML and RSC payload it needs and is ready to replace the fallback element from the DOM with the newly-streamed HTML. And so on. -->
<p>보류된 컴포넌트가 로딩을 마치면, 리액트는 재귀적으로 HTML을 생성하며 다른 중첩된 <code>&lt;Suspense&gt;</code> 경계를 찾고, 그에 해당하는 RSC 페이로드를 생성한 다음, Next.js가 새로운 청크로 HTML과 RSC 페이로드를 브라우저에 스트리밍하도록 합니다. 브라우저는 새로운 청크를 수신하면 필요한 HTML과 RSC 페이로드를 갖게 되어, DOM 상의 폴백 요소를 새롭게 스트리밍된 HTML로 대체할 준비를 마칩니다. 이런 과정이 반복됩니다.</p>
<figure>
<img src="./8-suspended-components-html.jpeg" width="100%" alt="그림 8. 보류된 컴포넌트 HTML"/>
<figcaption style="text-align: center">그림 8. 보류된 컴포넌트 HTML (<a target="_blank" href="./8-suspended-components-html.jpeg">크게 보기</a>)</figcaption>
</figure>

<!-- In Figures 7 and 8, notice how the fallback elements have a unique ID in the form of `B:0`, `B:1`, and so on, while the actual components have a similar ID in a similar form: `S:0` and `S:1`, and so on. -->
<p>그림 7과 8에서 보듯, 폴백 요소들은 <code>B:0</code>, <code>B:1</code> 등의 고유한 ID를 갖고 있으며, 실제 컴포넌트들도 유사한 형태의 ID인 <code>S:0</code>, <code>S:1</code> 등을 가집니다.</p>
<!-- Along with the first chunk that contains a suspended component’s HTML, the server also ships an `$RC` function (i.e., `completeBoundary` from [React’s source code](https://github.com/facebook/react/blob/main/packages/react-dom-bindings/src/server/fizz-instruction-set/ReactDOMFizzInstructionSetShared.js#L46)) that knows how to find the `B:0` fallback element in the DOM and replace it with the `S:0` template it received from the server. That’s the “replacer” function that lets us see the component contents when they arrive in the browser. -->
<p>첫 번째 청크에 보류된 컴포넌트의 HTML이 포함되어 있으면, 서버는 <code>$RC</code> 함수(리액트 소스 코드의 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/main/packages/react-dom-bindings/src/server/fizz-instruction-set/ReactDOMFizzInstructionSetShared.js#L46"><code>completeBoundary</code> 함수</a>)도 함께 전송합니다. 이 함수는 DOM 내의 <code>B:0</code> 폴백 요소를 찾아 서버로부터 받은 <code>S:0</code> 템플릿으로 대체하는 역할을 합니다. 이것이 바로 컴포넌트의 내용이 브라우저에 도착하면 이를 교체하는 “교체자” 함수입니다.</p>
<!-- The entire page eventually finishes loading, chunk by chunk. -->
<p>청크 단위로 로딩을 계속하여 결국에는 전체 페이지에 대한 로딩을 마치게 됩니다.</p>
<h3 id="8-2-지연-로딩-컴포넌트"><a href="#8-2-지연-로딩-컴포넌트" class="headerlink" title="8.2. 지연 로딩 컴포넌트"></a>8.2. 지연 로딩 컴포넌트</h3><!-- If a suspended Server Component contains a lazy-loaded Client Component, Next.js will also send an RSC payload chunk containing instructions on how to fetch and load the lazy-loaded component’s code. This represents a significant performance improvement because the page load isn’t dragged out by JavaScript, which might not even be loaded during that session. -->
<p>보류된 서버 컴포넌트가 지연 로딩(lazy-loading)된 클라이언트 컴포넌트를 포함하는 경우, Next.js는 해당 클라이언트 컴포넌트의 코드 페칭 및 로드를 위한 지시 사항을 포함한 RSC 페이로드 청크를 함께 전송합니다. 이는 세션 중에 로드되지 않을 수 있는 자바스크립트에 의해 페이지 로드가 지연되지 않도록 하여, 성능을 크게 개선하는 효과를 가져옵니다.</p>
<figure>
<img src="./9-fetching-lazy-loaded-scripts.jpeg" width="100%" alt="그림 9. 지연 로딩 스크립트 페칭"/>
<figcaption style="text-align: center">그림 9. 지연 로딩 스크립트 페칭 (<a target="_blank" href="./9-fetching-lazy-loaded-scripts.jpeg">크게 보기</a>)</figcaption>
</figure>

<!-- At the time I’m writing this, the dynamic method to lazy-load a Client Component in a Server Component in Next.js does not work as you might expect. To effectively lazy-load a Client Component, put it in a [“wrapper” Client Component](https://github.com/nikolovlazar/rsc-forensics/blob/main/src/components/addToCartWrapper.js) that uses the `dynamic` method itself to lazy-load the actual Client Component. The wrapper will be turned into a script that fetches and loads the Client Component’s JavaScript and CSS files at the time they’re needed. -->
<p>이 글을 쓰는 시점에서는 Next.js 내에서 서버 컴포넌트 안에 있는 클라이언트 컴포넌트를 지연 로딩하는 동적 방식이 예상한 대로 작동하지 않고 있습니다. 효과적으로 클라이언트 컴포넌트를 지연 로딩하려면, 해당 컴포넌트를 감싸는 <a target="_blank" rel="noopener" href="https://github.com/nikolovlazar/rsc-forensics/blob/main/src/components/addToCartWrapper.js">“래퍼” 클라이언트 컴포넌트</a>를 만들고, 그 래퍼가 해당 컴포넌트를 <code>dynamic</code> 메서드를 사용해 불러오도록 해야 합니다. 이 래퍼는 필요한 시점에 클라이언트 컴포넌트의 자바스크립트와 CSS 파일을 페칭하고 로드하는 스크립트로 전환될 것입니다.</p>
<h3 id="8-3-요약"><a href="#8-3-요약" class="headerlink" title="8.3. 요약"></a>8.3. 요약</h3><!-- I know that’s a lot of plates spinning and pieces moving around at various times. What it boils down to, however, is that a page visit triggers Next.js to render as much HTML as it can, using the fallback values for any suspended components, and then sends that to the browser. Meanwhile, Next.js triggers the suspended async components and gets them formatted in HTML and contained in RSC Payloads that are streamed to the browser, one by one, along with an `$RC` script that knows how to swap things out. -->
<p>너무 많은 정보가 쏟아져 혼란스러울 수 있다고 생각합니다. 요약하자면, 페이지 방문 시 Next.js는 가능한 많은 HTML을 렌더링 하고, 보류된 컴포넌트에 대해서는 폴백을 사용하여 HTML을 생성한 뒤 이를 브라우저에 전송합니다. 한편, Next.js는 보류된 비동기 컴포넌트를 호출해 HTML과 함께 RSC 페이로드에 담아 청크 단위로 스트리밍하고, <code>$RC</code> 스크립트를 함께 보내어 교체 작업을 수행하도록 합니다.</p>
<!-- ## 9. The Page Load Timeline -->
<h2 id="9-페이지-로드-타임라인"><a href="#9-페이지-로드-타임라인" class="headerlink" title="9. 페이지 로드 타임라인"></a>9. 페이지 로드 타임라인</h2><!-- By now, we should have a solid understanding of how RSCs work, how Next.js handles their rendering, and how all the pieces fit together. In this section, we’ll zoom in on what exactly happens when we visit an RSC page in the browser. -->
<p>이제 RSC가 어떻게 작동하는지, Next.js가 이를 어떻게 렌더링 하는지, 그리고 모든 요소가 어떻게 맞물려 동작하는지 확실히 이해하게 되었으리라 생각합니다. 이 섹션에서는 브라우저에서 RSC 페이지를 방문할 때 정확히 어떤 일이 발생하는지 자세히 살펴보겠습니다.</p>
<!-- ### The Initial Load -->
<h3 id="9-1-초기-로드"><a href="#9-1-초기-로드" class="headerlink" title="9.1. 초기 로드"></a>9.1. 초기 로드</h3><!-- As we mentioned in the TL;DR section above, when visiting a page, Next.js will render the initial HTML minus the suspended component and stream it to the browser as part of the first streaming chunks. -->
<p>위 요약 섹션에서 언급했듯, 페이지를 방문하면 Next.js는 보류된 컴포넌트를 제외한 초기 HTML을 렌더링 하여 첫 번째 스트리밍 청크의 일부로 브라우저에 전송합니다.</p>
<!-- To see everything that happens during the page load, we’ll visit the “Performance” tab in Chrome DevTools and click on the “reload” button to reload the page and capture a profile. Here’s what that looks like: -->
<p>페이지 로드 중에 발생하는 모든 과정을 확인하려면, Chrome DevTools의 “Performance” 탭을 열고 “reload” 버튼을 누릅니다. 그러면 페이지를 새로고침 한 다음 프로파일을 캡처할 것입니다. 아래 그림은 그 결과에 대한 예시 화면입니다.</p>
<figure>
<img src="./10-first-chunks-being-streamed.jpeg" width="100%" alt="그림 10. 첫 번째 청크가 스트리밍되는 모습"/>
<figcaption style="text-align: center">그림 10. 첫 번째 청크가 스트리밍되는 모습 (<a target="_blank" href="./10-first-chunks-being-streamed.jpeg">크게 보기</a>)</figcaption>
</figure>

<!-- When we zoom in at the very beginning, we can see the first “Parse HTML” span. That’s the server streaming the first chunks of the document to the browser. The browser has just received the initial HTML, which contains the page shell and a few links to resources like fonts, CSS files, and JavaScript. The browser starts to invoke the scripts. -->
<p>앞부분을 확대해 보면 첫 “Parse HTML” 영역이 보입니다. 이는 서버가 문서의 첫 번째 청크를 브라우저에 스트리밍하기 시작했음을 의미합니다. 브라우저는 페이지 껍데기 및 폰트, CSS 파일, 자바스크립트 등 몇몇 리소스에 대한 링크를 포함한 초기 HTML을 받았고, 스크립트를 실행하기 시작합니다.</p>
<figure>
<img src="./11-first-frames.jpeg" width="100%" alt="그림 11. 첫 프레임들"/>
<figcaption style="text-align: center">그림 11. (<a target="_blank" href="./11-first-frames.jpeg">크게 보기</a>)</figcaption>
</figure>

<!-- After some time, we start to see the page’s first frames appear, along with the initial JavaScript scripts being loaded and hydration taking place. If you look at the frame closely, you’ll see that the whole page shell is rendered, and “loading” components are used in the place where there are suspended Server Components. You might notice that this takes place around 800ms, while the browser started to get the first HTML at 100ms. During those 700ms, the browser is continuously receiving chunks from the server. -->
<p>잠시 후 페이지의 첫 번째 프레임들이 나타나고, 초기 자바스크립트 스크립트들이 로드되며 하이드레이션이 진행됩니다. 프레임을 자세히 보면, 전체 페이지 껍데기가 렌더링 되고, 보류된 서버 컴포넌트 자리에 “loading” 컴포넌트들이 적용된 것을 확인할 수 있습니다. 이 과정은 약 800ms 정도 소요되었는데, 브라우저는 100ms에 첫 HTML을 받기 시작한 이후 700ms 동안 계속해서 서버로부터 청크를 수신하고 있습니다.</p>
<!-- Bear in mind that this is a Next.js demo app running locally in development mode, so it’s going to be slower than when it’s running in production mode. -->
<p>참고로, 이는 로컬 개발 모드에서 실행 중인 Next.js 데모 앱이기 때문에, 프로덕션 모드에서 실행될 때보다 느릴 수 있습니다.</p>
<!-- ### The Suspended Component -->
<h3 id="9-2-보류된-컴포넌트"><a href="#9-2-보류된-컴포넌트" class="headerlink" title="9.2. 보류된 컴포넌트"></a>9.2. 보류된 컴포넌트</h3><!-- Fast forward few seconds and we see another “Parse HTML” span in the page load timeline, but this one it indicates that a suspended Server Component finished loading and is being streamed to the browser. -->
<p>몇 초 뒤로 가보면 타임라인에 또 다른 “Parse HTML” 영역이 보입니다. 이는 보류된 서버 컴포넌트가 로딩을 마치고 브라우저로 스트리밍되고 있음을 나타냅니다.</p>
<figure>
<img src="./12-suspended-component.jpeg" width="100%" alt="그림 12. 보류된 컴포넌트"/>
<figcaption style="text-align: center">그림 12. 보류된 컴포넌트 (<a target="_blank" href="./12-suspended-component.jpeg">크게 보기</a>)</figcaption>
</figure>

<!-- We can also see that a lazy-loaded Client Component is discovered at the same time, and it contains CSS and JavaScript files that need to be fetched. These files weren’t part of the initial bundle because the component isn’t needed until later on; the code is split into their own files. -->
<p>같은 시간대에 지연 로딩된 클라이언트 컴포넌트와 해당 컴포넌트에 필요한 CSS 및 자바스크립트 파일들이 보입니다. 이 파일들은 초기 번들에는 포함되지 않았습니다. 필요한 시점에 비로소 로드될 수 있도록 하기 위함입니다.</p>
<!-- This way of code-splitting certainly improves the performance of the initial page load. It also makes sure that the Client Component’s code is shipped only if it’s needed. If the Server Component (which acts as the Client Component’s parent component) throws an error, then the Client Component does not load. It doesn’t make sense to load all of its code before we know whether it will load or not. -->
<p>이러한 코드 분할 방식은 초기 페이지 로드 성능을 확실히 개선합니다. 또한 클라이언트 컴포넌트의 코드가 실제로 필요할 때만 전달되도록 보장합니다. 만약 클라이언트 컴포넌트의 부모 컴포넌트 역할을 하는 서버 컴포넌트가 오류를 발생시키면, 하위의 클라이언트 컴포넌트는 로드되지 않습니다. 로드될지 여부를 알 수 없는 상황에서 미리 모든 코드를 로드하는 것은 불필요한 낭비인 셈이니까요.</p>
<!-- Figure 12 shows the `DOMContentLoaded` event is reported at the end of the page load timeline. And, just before that, we can see that the `localhost` HTTP request comes to an end. That means the server has likely sent the last zero-sized chunk, indicating to the client that the data is fully transferred and that the streaming communication can be closed. -->
<p>그림 12에서는 <code>DOMContentLoaded(DCL)</code> 이벤트가 페이지 로드 타임라인의 끝부분에 기록되는 것을 볼 수 있습니다. 그리고 그 직전에는 <code>localhost</code>에 대한 HTTP 요청이 종료되는 것을 확인할 수 있습니다. 이는 서버가 마지막 0바이트 크기의 청크를 보내 데이터 전송이 완료되었음을 클라이언트에 알렸다는 의미입니다.</p>
<h3 id="9-3-최종-결과"><a href="#9-3-최종-결과" class="headerlink" title="9.3. 최종 결과"></a>9.3. 최종 결과</h3><!-- The main `localhost` HTTP request took around five seconds, but thanks to streaming, we began seeing page contents load much earlier than that. If this was a traditional SSR setup, we would likely be staring at a blank screen for those five seconds before anything arrives. On the other hand, if this was a traditional CSR setup, we would likely have shipped a lot more of JavaScript and put a heavy burden on both the browser and network. -->
<p><code>localhost</code> HTTP 요청은 약 5초 정도 걸렸지만, 스트리밍 덕분에 그보다 훨씬 이전부터 페이지 내용이 보이기 시작했습니다. 만약 전통적인 SSR 방식이었다면, 5초 동안 빈 화면만 보고 있어야 했을 것입니다. 또한 전통적인 CSR 방식이었다면, 훨씬 더 많은 자바스크립트를 불러오도록 하여 브라우저와 네트워크에 부담을 주었을 것입니다.</p>
<!-- This way, however, the app was fully interactive in those five seconds. We were able to navigate between pages and interact with Client Components that have loaded as part of the initial main bundle. This is a pure win from a user experience standpoint. -->
<p>반면 RSC 방식은 5초가 지나기 전부터 이미 앱이 완전히 인터랙티브한 상태를 유지합니다. 클라이언트 컴포넌트가 초기 메인 번들에 포함된 덕분에 페이지 간 내비게이션과 상호작용을 원활하게 수행할 수 있습니다. 사용자 경험 측면에서 명백한 승리입니다.</p>
<h2 id="10-결론"><a href="#10-결론" class="headerlink" title="10. 결론"></a>10. 결론</h2><!-- RSCs mark a significant evolution in the React ecosystem. They leverage the strengths of server-side and client-side rendering while embracing HTML streaming to speed up content delivery. This approach not only addresses the SEO and loading time issues we experience with CSR but also improves SSR by reducing server load, thus enhancing performance. -->
<p>RSC는 리액트 생태계의 중요한 진화를 의미합니다. RSC는 서버 사이드와 클라이언트 사이드 렌더링의 장점을 모두 활용하면서 HTML 스트리밍을 통해 콘텐츠 전달 속도를 높입니다. 이 접근 방식은 CSR에서 경험하는 SEO 및 로딩 시간 문제를 해결할 뿐만 아니라, SSR의 서버 부하를 줄여 성능을 끌어올립니다.</p>
<!-- I’ve refactored the same RSC app I shared earlier so that it uses the Next.js Page router with SSR. The improvements in RSCs are significant: -->
<p>앞서 공유했던 RSC 앱을 Next.js Page 라우터와 SSR을 사용하도록 바꿔보았더니, 확실히 RSC의 개선 사항이 두드러집니다.</p>
<figure>
<img src="./13-ssr-vs-rscs.jpeg" width="100%" alt="그림 13. SSR vs RSCs"/>
<figcaption style="text-align: center">그림 13. SSR vs RSC (<a target="_blank" href="./13-ssr-vs-rscs.jpeg">크게 보기</a>)</figcaption>
</figure>

<!-- Looking at these two reports I pulled from Sentry, we can see that streaming allows the page to start loading its resources before the actual request finishes. This significantly improves the Web Vitals metrics, which we see when comparing the two reports. -->
<p>Sentry에서 추출한 두 보고서를 비교해 보면, 스트리밍 덕분에 실제 요청이 완료되기 전에 페이지의 리소스 로드가 시작된다는 것을 알 수 있습니다. 그래서 보고서상의 웹 성능 지표도 크게 개선되었습니다.</p>
<!-- The conclusion: **Users enjoy faster, more reactive interfaces with an architecture that relies on RSCs.** -->
<p>결론: <strong>사용자는 RSC에 기반한 아키텍처 덕에 더 빠르고 반응성이 뛰어난 인터페이스를 경험하게 됩니다.</strong></p>
<!-- The RSC architecture introduces two new component types: Server Components and Client Components. This division helps React and the frameworks that rely on it — like Next.js — streamline content delivery while maintaining interactivity. -->
<p>RSC 아키텍처는 서버 컴포넌트와 클라이언트 컴포넌트라는 두 가지 새로운 컴포넌트 유형을 도입하였습니다. 이 구분은 리액트와 이를 기반으로 한 프레임워크(예: Next.js)가 콘텐츠를 전달하는 동안에도 상호작용성을 유지할 수 있도록 합니다.</p>
<!-- However, this setup also introduces new challenges in areas like state management, authentication, and component architecture. Exploring those challenges is a great topic for another blog post! -->
<p>물론 이러한 설정은 상태 관리, 인증, 컴포넌트 아키텍처 등의 분야에 새로운 과제를 야기하기도 합니다. 이 과제들을 탐구하는 것은 또 다른 블로그 글로 다룰 수 있는 좋은 주제가 될 것입니다!</p>
<!-- Despite these challenges, the benefits of RSCs present a compelling case for their adoption. We definitely will see guides published on how to address RSC’s challenges as they mature, but, in my opinion, they already look like the future of rendering practices in modern web development. -->
<p>이러한 어려움에도 불구하고 RSC의 장점은 이를 도입해야 하는 강력한 이유가 됩니다. RSC가 발전함에 따라 앞서 언급한 과제들을 해결하는 방법에 대한 다양한 가이드가 제시될 것입니다. 제 생각에 RSC는 이미 현대 웹 개발 렌더링 관행의 미래로 보입니다.</p>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/react-js/">React.js</a><a class="article__tags__item" href="/tags/%EB%B2%88%EC%97%AD/">번역</a><a class="article__tags__item" href="/tags/next-js/">Next.js</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="https://www.gravatar.com/avatar/02e9f56a3202da2e6e0e36a5a23facbb" alt="Jaenam Jung"><a class="article__author__link" title="About Jaenam Jung" rel="author">Jaenam Jung</a><p class="article__author__desc">할 수 있는걸 합니다.</p><div class="article__author__socials"><a class="article__author__socials__item" href="http://github.com/roy-jung" title="github" target="_blank"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="Jaenam Jung"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><div id="disqus_thread"></div><script>(function() {
  var d = document, s = d.createElement('script');
  s.src = '//gomugom.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Enable JavaScript to see comments.</noscript><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2025-04-23T05:25:46.732Z"><meta itemprop="articleBody" content="
원문: The Forensics of React Server Components (RSC)



간단 요약: 클라이언트 사이드 렌더링은 서버의 무거운 연산 부담을 덜어줍니다. 그 대신 초기 페이지 로드 시 빈 HTML 페이지가 보이는 점에서 사용자 경험에 좋지 않습니다. 반면, 서버 사이드 렌더링은 빠른 CDN을 통해 정적 자산(static..."><meta itemprop="url" content="http://roy-jung.github.io/250323-react-server-components/"><meta itemprop="mainEntityOfPage" content="http://roy-jung.github.io/250323-react-server-components/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="FE재남"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="http://roy-jung.github.io/images/logo.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="http://roy-jung.github.io/images/Forensics of React Server Components.jpg"><meta itemprop="url" content="http://roy-jung.github.io/images/Forensics of React Server Components.jpg"><meta itemprop="width"><meta itemprop="height"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/250414-react-reconciliation-deep-dive/"><div class="related-posts__item__background" style="background-image:url('/images/React Reconciliation Engine.webp');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">React Reconciliation: 컴포넌트 뒤에 숨겨진 엔진</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/201111-concise-redux-saga/"><div class="related-posts__item__background" style="background-image:url('/images/post-cover4.jpg');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">redux-saga를 간결하게 사용해보자!</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/201129_apollo-graphql-infinite-scroll/"><div class="related-posts__item__background" style="background-image:url('/201129_apollo-graphql-infinite-scroll/0.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">infinite scroll 구현하기 (1) apollo-graphql</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/iterator-helper-overview/">이터레이터 헬퍼 맛보기</a></li><li class="recent-posts__item"><a href="/250414-react-reconciliation-deep-dive/">React Reconciliation: 컴포넌트 뒤에 숨겨진 엔진</a></li><li class="recent-posts__item"><a href="/250323-react-server-components/">리액트 서버 컴포넌트 톺아보기 (번역)</a></li><li class="recent-posts__item"><a href="/211231-review-2021/">2021 회고</a></li><li class="recent-posts__item"><a href="/201130_swr-graphql-infinite-scroll/">infinite scroll 구현하기 (2) swr-graphql</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">2025 4월</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">2022 1월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">2020 11월</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">2020 10월</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">2017 1월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">2016 12월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">2016 11월</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">2016 10월</a><span class="archive-list-count">2</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ecmascript/">ECMAScript</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fe/">FE</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/fe/react-js/">React.js</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/fe/react-js/next-js/">Next.js</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/fe/javascript/">javascript</a><span class="category-list-count">6</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/etc/">etc</a><span class="category-list-count">2</span></li></ul></div></div></div><p class="copyright"><small>© 2025 Jaenam Jung<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>