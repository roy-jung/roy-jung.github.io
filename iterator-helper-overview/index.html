<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>이터레이터 헬퍼 맛보기 | FE재남</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="http://roy-jung.github.io/iterator-helper-overview/"/>
<meta name="description" content="이터레이터 헬퍼?이터레이터 헬퍼(Iterator Helper)는 ECMAScript 2025(ES2025)에 새롭게 추가될 기능으로, 이터레이터를 더욱 편리하게 사용할 수 있도록 돕는 다양한 인터페이스의 집합입니다. ES2015에서 이터레이터…">
<meta property="og:type" content="article">
<meta property="og:title" content="이터레이터 헬퍼 맛보기">
<meta property="og:url" content="http://roy-jung.github.io/iterator-helper-overview/">
<meta property="og:site_name" content="FE재남">
<meta property="og:description" content="이터레이터 헬퍼?이터레이터 헬퍼(Iterator Helper)는 ECMAScript 2025(ES2025)에 새롭게 추가될 기능으로, 이터레이터를 더욱 편리하게 사용할 수 있도록 돕는 다양한 인터페이스의 집합입니다. ES2015에서 이터레이터…">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="http://roy-jung.github.io/iterator-helper-overview/iterator-helpers.png">
<meta property="article:published_time" content="2025-05-12T15:57:13.000Z">
<meta property="article:modified_time" content="2025-05-15T03:48:33.008Z">
<meta property="article:author" content="Jaenam Jung">
<meta property="article:tag" content="ecmascript">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="es2025">
<meta property="article:tag" content="iterator helper">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://roy-jung.github.io/iterator-helper-overview/iterator-helpers.png"><meta property="article:author" content="Jaenam Jung"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2025-05-13 00:57:13"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="Jaenam Jung"><link rel="icon" href="/images/logo.png"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="FE재남"><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/logo.png" alt="FE재남"><span class="menu__item__link--brand__label">FE재남</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">이터레이터 헬퍼 맛보기</h1><div class="article__meta"><time class="article__meta__time" datetime="2025-05-12T15:57:13.000Z" itemprop="datePublished">2025-05-13 00:57:13</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/ecmascript/">ECMAScript</a></div></div><div class="article__contents"><img src="/iterator-helper-overview/iterator-helpers.png"/><h2 id="이터레이터-헬퍼"><a href="#이터레이터-헬퍼" class="headerlink" title="이터레이터 헬퍼?"></a>이터레이터 헬퍼?</h2><p>이터레이터 헬퍼(Iterator Helper)는 ECMAScript 2025(ES2025)에 새롭게 추가될 기능으로, 이터레이터를 더욱 편리하게 사용할 수 있도록 돕는 다양한 인터페이스의 집합입니다.</p>
<p>ES2015에서 이터레이터 프로토콜이 도입된 이후, 필요한 기능을 직접 구현하거나 배열로 변환하여 배열 메서드를 사용하는 방법 외에는 이터레이터를 폭넓게 활용하기가 어려웠습니다. 하지만 필요한 기능을 직접 구현하면 오류 발생 확률이 높을 뿐 아니라 제한된 기능만 활용하게 되기 쉽고, 배열로 변환하면 지연 평가라는 이터레이터의 장점을 잃고 불필요한 메모리를 낭비하게 되어 비효율적입니다.</p>
<p>이제 이터레이터 헬퍼 메서드를 체이닝하여 이터레이터의 지연 평가 기능을 적극 활용하면, 코드 가독성을 높이고 순회 횟수를 줄임으로써 성능을 크게 개선할 수 있게 되었습니다.</p>
<p>이 글에서는 지연 평가를 위한 이터레이터 메서드 체이닝의 동작 원리를 알아보고, 이터레이터 헬퍼 메서드의 종류 및 성능상 이점을 테스트해 본 다음, 실무에서 데이터 타입 별로 기존 코드를 이터레이터 헬퍼로 대체하기 위한 다양한 기법 및 유의사항을 살펴보겠습니다.</p>
<h2 id="지연-평가"><a href="#지연-평가" class="headerlink" title="지연 평가?"></a>지연 평가?</h2><p>이터레이터의 <code>next</code> 메서드는 <code>&#123; value: 반환값, done: boolean &#125;</code> 객체를 반환합니다. <code>for ... of</code> 문법은 내부적으로 <code>next</code> 메서드를 <code>done</code>이 <code>true</code>가 될 때까지 반복 호출합니다. 단순한 순회 명령만 보면 배열의 메서드와 큰 차이가 없어 보일 수 있습니다.</p>
<p>그러나 배열 메서드는 한 번에 모든 순회 대상을 메모리에 적재한 뒤 처리하는 반면, 이터레이터는 <code>next()</code>를 호출하기 전까지 아무 작업도 하지 않고 대기합니다. <code>next()</code>가 호출되는 시점에 비로소 순회 대상의 ‘다음’ 요소를 평가합니다. 이를 <strong>지연 평가(Lazy Evaluation)</strong>라고 합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 배열</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">5</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> i + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> arrSum = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, c</span>) =&gt;</span> a + c, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrSum) <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 이터레이터</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">5</span>) <span class="keyword">yield</span> ++i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterSum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> <span class="title function_">generator</span>()) &#123;</span><br><span class="line">  iterSum += v</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterSum) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>결과만 보면 배열과 이터레이터 사이에 차이가 없는 것처럼 보입니다. 하지만 동작 방식에는 큰 차이가 있습니다. 코드 곳곳에 로그를 추가해 확인해 보겠습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;array&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">5</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;generate&#x27;</span>, i)</span><br><span class="line">  <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> arrSum = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reduce&#x27;</span>, c)</span><br><span class="line">  <span class="keyword">return</span> a + c</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupEnd</span>(<span class="string">&#x27;array&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;iterator&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;generate&#x27;</span>, i)</span><br><span class="line">    <span class="keyword">yield</span> ++i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterSum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> <span class="title function_">generator</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reduce&#x27;</span>, v)</span><br><span class="line">  iterSum += v</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupEnd</span>(<span class="string">&#x27;iterator&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>위 코드를 실행하면 개발자 도구 콘솔에 다음과 같은 내용이 출력됩니다.</p>
<table class="imgs"><tr><td><img src="./1-1.png" alt="배열 결과" width="192"/></td><td>&nbsp;</td><td><img src="./1-2.png" alt="이터레이터 결과" width="192"/></td></tr><tr><td>배열 결과</td><td></td><td>이터레이터 결과</td></tr></table>

<p>배열 코드에서는 <code>generate</code>가 5번 출력된 후 <code>reduce</code>가 5번 출력되었습니다. 반면, 이터레이터 코드에서는 <code>generate</code>와 <code>reduce</code>가 번갈아 출력되었습니다. 즉, 배열은 모든 요소를 생성한 뒤 연산을 수행했지만, 이터레이터는 값을 하나 생성하고 바로 연산을 수행한 뒤 다시 값을 생성하는 방식으로 진행되었습니다.</p>
<p><code>for ... of</code> 문법은 내부적으로 <code>next</code> 메서드를 호출하여 <code>done</code>이 <code>true</code>가 될 때까지 반복합니다. <code>next</code>가 호출되면 제너레이터 함수의 실행이 시작되고, <code>yield</code>를 만나면 멈춥니다. 이후 다시 <code>next</code>가 호출되면 멈췄던 자리에서 실행을 재개합니다. 이처럼 <code>for ... of</code>는 필요한 순간까지 기다렸다가(지연) 평가를 수행합니다.</p>
<h2 id="이터레이터-메서드-체이닝"><a href="#이터레이터-메서드-체이닝" class="headerlink" title="이터레이터 메서드 체이닝"></a>이터레이터 메서드 체이닝</h2><p>좀 더 복잡한 연산 과정을 살펴보겠습니다. 다음은 배열의 <code>filter</code>와 <code>map</code> 메서드를 체이닝한 코드입니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">5</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> i + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> arrResult = arr</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;filter&#x27;</span>, v)</span><br><span class="line">    <span class="keyword">return</span> v % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;map&#x27;</span>, v)</span><br><span class="line">    <span class="keyword">return</span> v ** <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrResult)</span><br></pre></td></tr></table></figure>

<p>위 코드를 실행하면 개발자 도구 콘솔에 다음과 같은 내용이 출력됩니다.</p>
<table class="imgs"><tr><td><img src="./2.png" alt="배열 메서드 체이닝" width="192" /></td></tr><tr><td>배열 메서드 체이닝</td></tr></table>

<p><code>filter</code> 메서드는 배열의 모든 요소를 순회하고, <code>map</code> 메서드는 필터링 된 결과 배열을 다시 순회합니다. 따라서 전체 순회 횟수는 <code>filter</code>에서 한 번, <code>map</code>에서 한 번으로 총 두 번입니다. 이를 한 번의 순회로 처리하려면 어떻게 해야 할까요? 일단 메서드 체이닝으로 분리된 내용을 <code>for ... of</code> 내부로 옮겨봅시다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">5</span>) <span class="keyword">yield</span> ++i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterResult = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> <span class="title function_">generator</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;filter&#x27;</span>, v)</span><br><span class="line">  <span class="keyword">if</span> (v % <span class="number">2</span> !== <span class="number">0</span>) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;map&#x27;</span>, v)</span><br><span class="line">  iterResult.<span class="title function_">push</span>(v ** <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterResult)</span><br></pre></td></tr></table></figure>

<table class="imgs"><tr><td><img src="./3.png" alt="유사 지연 평가" width="192" /></td></tr><tr><td>유사 지연 평가</td></tr></table>

<p>위 코드는 한 번의 순회로 원하는 결과를 얻을 수 있었습니다. 실제 지연 평가도 위 코드에서 여러 명령을 순차적으로 수행한 것과 비슷하게 진행됩니다. 여러 메서드를 체이닝했을 때, 이터레이터의 각 항목에 대해 연결된 메서드를 순차적으로 실행하고, 모든 메서드 실행이 종료되면 비로소 다음 항목으로 넘어가 동일한 순서를 반복합니다.</p>
<p>다음은 직접 만든 지연 평가 메서드의 예시 코드입니다.</p>
<blockquote>
<p>※ 주의 ※<br>다음 예제 코드는 <code>Iterator.prototype</code>에 직접 메서드를 추가합니다. 이는 전역 객체를 수정하여 다른 라이브러리와 충돌하거나 예기치 않은 동작을 유발할 수 있습니다. 따라서 실제 프로젝트에서는 <code>Iterator.prototype</code>을 직접 확장하지 않는 것을 권장합니다.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Iterator</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_filter</span> = <span class="keyword">function</span>* (fn) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, iter)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;_filter iteration&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="variable language_">this</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;_filter&#x27;</span>, item)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">fn</span>(item)) <span class="keyword">yield</span> item</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Iterator</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_map</span> = <span class="keyword">function</span>* (fn) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;_map iteration&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="variable language_">this</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;_map&#x27;</span>, item)</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">fn</span>(item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> iter = arr</span><br><span class="line">  .<span class="title function_">values</span>()</span><br><span class="line">  .<span class="title function_">_filter</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;_filterFn&#x27;</span>, v)</span><br><span class="line">    <span class="keyword">return</span> v % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">_map</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;_mapFn&#x27;</span>, v)</span><br><span class="line">    <span class="keyword">return</span> v ** <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter)</span><br><span class="line"><span class="comment">// Iterator._map &#123;&lt;suspended&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>_filter</code>와 <code>_map</code>은 제너레이터 메서드입니다. 변수 <code>iter</code>는 제너레이터를 실행한 결과물인 이터레이터에 불과하며, 아직 평가가 이루어지지 않은 상태입니다. 따라서 마지막 줄에서 중단된 상태의 이터레이터(<code>Iterator._map &#123;&lt;suspended&gt;&#125;</code>)가 출력됩니다.</p>
<p>이제 <code>iter.next()</code>를 호출하면 다음과 같은 순서로 코드가 진행됩니다.</p>
<ol>
<li><sup>L25)</sup><code>Iterator._map</code> 이터레이터에 대해 첫 번째 평가가 이루어집니다. 이제부터 <code>Iterator._map</code>은 <code>&lt;running&gt;</code> 상태가 됩니다. 이터레이터 내부에서 <code>yield</code>를 만날 때까지 코드를 진행합니다.</li>
<li><sup>L9)</sup><code>_map</code> 내부에서 <code>this</code>는 메서드 체이닝 상 <code>Iterator._filter</code>입니다. <sup>L12)</sup><code>for (const item of this)</code>에서 <code>this</code>가 이터레이터이므로 해당 이터레이터(<sup>L21)</sup><code>_filter(...)</code>)를 먼저 평가합니다. <code>_filter</code>에서 <code>yield</code>를 만나면 <code>_filter</code>를 빠져나오면서 이 값을 <code>item</code>에 할당하고, <sup>L12)</sup><code>for ... of</code> 내부 코드를 진행합니다.</li>
<li><sup>L1)</sup><code>_filter</code> 내부에서 <code>this</code>는 메서드 체이닝 상 <code>Array Iterator</code>입니다. <sup>L4)</sup><code>for (const item of this)</code>에서 <code>this</code>가 이터레이터이므로 해당 이터레이터(<sup>L20)</sup><code>values()</code>)를 먼저 평가합니다. <code>values</code>에서 <code>yield</code>를 만나면 <code>values</code>를 빠져나오면서 이 값을 <code>item</code>에 할당하고, <sup>L4)</sup><code>for ... of</code> 내부 코드를 진행합니다.</li>
<li><sup>L20)</sup><code>values</code>는 첫 번째 이터레이션에서 <code>&#123; value: 1, done: false &#125;</code>를 <code>yield</code> 합니다.</li>
<li><sup>L1)</sup><code>_filter</code>의 <sup>L4)</sup><code>for ... of</code>문에서 <code>item</code>에는 위 4번에서 <code>yield</code>한 객체의 <code>value</code> 값, 즉 <code>1</code>이 할당됩니다. <sup>L6)</sup><code>fn(1)</code>의 실행 결과 <code>1 % 2 !== 0</code>으로 <code>false</code>가 되므로, 조건문을 충족하지 않아 <code>yield</code>하지 않고, 다음 이터레이션으로 넘어갑니다.</li>
<li>다시 <sup>L20)</sup><code>values()</code>에 대한 평가를 합니다. <code>values</code>는 두 번째 이터레이션에서 <code>&#123; value: 2, done: false &#125;</code>를 <code>yield</code> 합니다.</li>
<li><sup>L1)</sup><code>_filter</code>의 <sup>L4)</sup><code>for ... of</code>문에서 <code>item</code>에는 위 <code>2</code>가 할당됩니다. <sup>L6)</sup><code>fn(2)</code>의 실행 결과 <code>2 % 2 === 0</code>으로 <code>true</code>가 되므로, 조건문을 충족하여 <code>2</code>를 <code>yield</code> 합니다.</li>
<li><sup>L9)</sup><code>_map</code>의 <sup>L12)</sup><code>for ... of</code>문에서 <code>item</code>에는 위 7번에서 <code>yield</code>한 객체의 <code>value</code> 값, 즉 <code>2</code>가 할당됩니다. <sup>L14)</sup><code>fn(2)</code>의 실행 결과 <code>2 ** 2 = 4</code>로 <code>4</code>가 반환되어, <code>&#123; value: 4, done: false &#125;</code>를 <code>yield</code> 합니다. 이로써 <code>Iterator._map</code>에 대한 <code>next()</code> 호출의 결과를 반환하였으므로, 이터레이션을 멈추고 다시 <code>&lt;suspended&gt;</code> 상태로 돌아갑니다.</li>
</ol>
<p>같은 방식으로 <code>iter.next()</code>를 반복하여 실행한 결과는 다음과 같습니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* L숫자) : 위 코드 블락의 줄 번호를 의미합니다. */</span></span><br><span class="line">iter.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// L10) Iterator._filter &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="comment">// L11) _map iteration</span></span><br><span class="line"><span class="comment">// L02) Array Iterator &#123;&#125;, Iterator._map &#123;&lt;running&gt;&#125;</span></span><br><span class="line"><span class="comment">// L03) _filter iteration</span></span><br><span class="line"><span class="comment">// L05) _filter 1</span></span><br><span class="line"><span class="comment">// L22) _filterFn 1</span></span><br><span class="line"><span class="comment">// L05) _filter 2</span></span><br><span class="line"><span class="comment">// L22) _filterFn 2</span></span><br><span class="line"><span class="comment">// L13) _map 2</span></span><br><span class="line"><span class="comment">// L26) _mapFn 2</span></span><br><span class="line marked"><span class="comment">// 결과) &#123;value: 4, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter)</span><br><span class="line marked"><span class="comment">// Iterator._map &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">iter.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// L05) _filter 3</span></span><br><span class="line"><span class="comment">// L22) _filterFn 3</span></span><br><span class="line"><span class="comment">// L05) _filter 4</span></span><br><span class="line"><span class="comment">// L22) _filterFn 4</span></span><br><span class="line"><span class="comment">// L13) _map 4</span></span><br><span class="line"><span class="comment">// L26) _mapFn 4</span></span><br><span class="line marked"><span class="comment">// 결과) &#123;value: 16, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter)</span><br><span class="line marked"><span class="comment">// Iterator._map &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">iter.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// L05) _filter 5</span></span><br><span class="line"><span class="comment">// L22) _filterFn 5</span></span><br><span class="line marked"><span class="comment">// 결과) &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter)</span><br><span class="line marked"><span class="comment">// Iterator._map &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>for ... of</code>는 <code>done</code>이 <code>true</code>일 때까지 <code>next</code> 메서드를 반복 호출하므로, 위 코드의 전체 <code>iter.next()</code>를 대체할 수 있습니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> value <span class="keyword">of</span> iter) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 첫 번째 이터레이팅 과정 중에 출력되는 로그 생략</span></span><br><span class="line"><span class="comment">// 결과) 4</span></span><br><span class="line"><span class="comment">// ... 두 번째 이터레이팅 과정 중에 출력되는 로그 생략</span></span><br><span class="line"><span class="comment">// 결과) 16</span></span><br><span class="line"><span class="comment">// ... 세 번째 이터레이팅 과정 중에 출력되는 로그 생략</span></span><br></pre></td></tr></table></figure>

<p>펼치기 문법(Spread Syntax, <code>...</code>)은 연속된 <code>iter.next()</code>의 각 <code>value</code>를 나열하므로, 마찬가지로 전체 <code>iter.next()</code>를 대체할 수 있습니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resultArray = [...iter]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(resultArray)</span><br><span class="line"><span class="comment">// ... 전체 이터레이팅 과정 중에 출력되는 로그 생략</span></span><br><span class="line"><span class="comment">// 결과) [4, 16]</span></span><br></pre></td></tr></table></figure>

<p>혹은, 다음과 같이 메서드 체이닝을 활용하는 방안도 좋습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Iterator</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_toArray</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="variable language_">this</span>) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> iter = arr</span><br><span class="line">  .<span class="title function_">values</span>()</span><br><span class="line">  .<span class="title function_">_filter</span>(<span class="function"><span class="params">v</span> =&gt;</span> v % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line marked">  .<span class="title function_">_map</span>(<span class="function"><span class="params">v</span> =&gt;</span> v ** <span class="number">2</span>)</span><br><span class="line">  .<span class="title function_">_toArray</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter)</span><br><span class="line"><span class="comment">// ... 전체 이터레이팅 과정 중에 출력되는 로그 생략</span></span><br><span class="line"><span class="comment">// 결과) [4, 16]</span></span><br></pre></td></tr></table></figure>


<h2 id="이터레이터-헬퍼-1"><a href="#이터레이터-헬퍼-1" class="headerlink" title="이터레이터 헬퍼"></a>이터레이터 헬퍼</h2><p>사실 앞서 <code>Iterator.prototype</code>에 추가한 여러 메서드(<code>_filter</code>, <code>_map</code>, <code>_toArray</code>)에서 접두어 <code>_</code>를 제거하면, ES2025에 추가될 이터레이터 헬퍼 메서드(<code>filter</code>, <code>map</code>, <code>toArray</code>)와 동일합니다. 지금 브라우저 개발자 도구의 콘솔 탭에서 다음 코드를 실행해 보세요. 이미 주요 브라우저(크롬 및 크롬 기반 브라우저, 파이어폭스, 사파리)가 이터레이터 헬퍼 메서드를 지원하고 있습니다. (브라우저 및 OS 업데이트가 필요할 수 있습니다.)</p>
<blockquote>
<p>각 메서드에 대한 정확한 지원 여부는 <a target="_blank" rel="noopener" href="https://caniuse.com/?search=iterator%20map">Can I Use - Iterator.map</a>에서 확인하시기 바랍니다.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> iter = arr</span><br><span class="line">  .<span class="title function_">values</span>()</span><br><span class="line marked">  .<span class="title function_">filter</span>(<span class="function"><span class="params">v</span> =&gt;</span> v % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line marked">  .<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> v ** <span class="number">2</span>)</span><br><span class="line marked">  .<span class="title function_">toArray</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter)</span><br><span class="line"><span class="comment">// [4, 16]</span></span><br></pre></td></tr></table></figure>

<p>아래 그림은 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator/Iterator">MDN - Iterator() constructor</a> 페이지의 스크린숏입니다. 그림의 좌측 목록에 보이는 모든 항목이 2025년 3월에 새롭게 <a target="_blank" rel="noopener" href="https://web-platform-dx.github.io/web-features/">Baseline</a>에 추가된 기능들입니다.</p>
<img src="./4.png" style="border: 1px solid #0003" alt="MDN - Iterator() contrutor" />

<p>추가된 이터레이터 헬퍼 기능들을 간략히 살펴보겠습니다.</p>
<h3 id="1-이터레이터를-소비하지-않는-메서드"><a href="#1-이터레이터를-소비하지-않는-메서드" class="headerlink" title="1. 이터레이터를 소비하지 않는 메서드"></a>1. 이터레이터를 소비하지 않는 메서드</h3><p>여기서 소개하는 이터레이터 헬퍼 메서드는 모두 실행 결과로 새로운 이터레이터를 반환합니다. 즉, 이 메서드들을 호출하는 것만으로는 평가가 이루어지지 않습니다. 평가를 위해서는 뒤에 등장할 <strong>이터레이터를 소비하는 메서드</strong>를 체이닝하거나, 이터레이터의 <code>next</code> 메서드를 호출해야 합니다.</p>
<h4 id="1-1-map-mapperFn-•-Iterator-prototype-map"><a href="#1-1-map-mapperFn-•-Iterator-prototype-map" class="headerlink" title="1-1. .map(mapperFn) • Iterator.prototype.map"></a>1-1. <code>.map(mapperFn)</code> • <code>Iterator.prototype.map</code></h4><p><code>map</code> 메서드는 이터레이터(<code>this</code>)의 각 요소에 대해 인자로 받은 함수(<code>mapperFn</code>)를 실행하여, 실행 결과들로 구성된 새로운 이터레이터를 반환합니다. 배열의 <code>Array.prototype.map</code> 메서드와 유사합니다.</p>
<h4 id="1-2-filter-filtererFn-•-Iterator-prototype-filter"><a href="#1-2-filter-filtererFn-•-Iterator-prototype-filter" class="headerlink" title="1-2. .filter(filtererFn) • Iterator.prototype.filter"></a>1-2. <code>.filter(filtererFn)</code> • <code>Iterator.prototype.filter</code></h4><p><code>filter</code> 메서드는 이터레이터(<code>this</code>)의 각 요소에 대해 인자로 받은 함수(<code>filtererFn</code>)를 실행하여, 실행 결과가 <code>true</code>인 요소들만으로 구성된 새로운 이터레이터를 반환합니다. 배열의 <code>Array.prototype.filter</code> 메서드와 유사합니다.</p>
<h4 id="1-3-take-limit-•-Iterator-prototype-take"><a href="#1-3-take-limit-•-Iterator-prototype-take" class="headerlink" title="1-3. .take(limit) • Iterator.prototype.take"></a>1-3. <code>.take(limit)</code> • <code>Iterator.prototype.take</code></h4><p><code>take</code> 메서드는 이터레이터(<code>this</code>)의 요소 중 처음부터 인자로 받은 수(<code>limit</code>)만큼의 요소만 포함하는 새로운 이터레이터를 반환합니다. 배열에서 <code>arr.slice(0, limit)</code>를 실행하는 것과 유사합니다.</p>
<h4 id="1-4-drop-limit-•-Iterator-prototype-drop"><a href="#1-4-drop-limit-•-Iterator-prototype-drop" class="headerlink" title="1-4. .drop(limit) • Iterator.prototype.drop"></a>1-4. <code>.drop(limit)</code> • <code>Iterator.prototype.drop</code></h4><p><code>drop</code> 메서드는 이터레이터(<code>this</code>)의 요소 중 처음부터 인자로 받은 수(<code>limit</code>)만큼의 요소를 제외한 나머지 요소들로 구성된 새로운 이터레이터를 반환합니다. 배열에서 <code>arr.slice(limit)</code>를 실행하는 것과 유사합니다.</p>
<h4 id="1-5-flatMap-mapperFn-•-Iterator-prototype-flatMap"><a href="#1-5-flatMap-mapperFn-•-Iterator-prototype-flatMap" class="headerlink" title="1-5. .flatMap(mapperFn) • Iterator.prototype.flatMap"></a>1-5. <code>.flatMap(mapperFn)</code> • <code>Iterator.prototype.flatMap</code></h4><p><code>flatMap</code> 메서드는 이터레이터(<code>this</code>)의 각 요소에 대해 인자로 받은 함수(<code>mapperFn</code>)를 실행하여, 실행 결과를 단일 깊이로 평탄화(flatten) 한 새로운 이터레이터를 반환합니다. 배열의 <code>Array.prototype.flatMap</code> 메서드와 유사합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nestedArray = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>]]</span><br><span class="line"><span class="keyword">const</span> flattened = nestedArray</span><br><span class="line">  .<span class="title function_">values</span>()</span><br><span class="line">  .<span class="title function_">flatMap</span>(<span class="function"><span class="params">arr</span> =&gt;</span> arr.<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>))</span><br><span class="line">  .<span class="title function_">toArray</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flattened)</span><br><span class="line"><span class="comment">// [2, 4, 6, 8, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> words = [<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;iterator helpers&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> result = words</span><br><span class="line">  .<span class="title function_">values</span>()</span><br><span class="line">  .<span class="title function_">flatMap</span>(<span class="function"><span class="params">word</span> =&gt;</span> word.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>))</span><br><span class="line">  .<span class="title function_">toArray</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, &quot;world&quot;, &quot;iterator&quot;, &quot;helpers&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="2-이터레이터를-소비하는-메서드"><a href="#2-이터레이터를-소비하는-메서드" class="headerlink" title="2. 이터레이터를 소비하는 메서드"></a>2. 이터레이터를 소비하는 메서드</h3><p>여기서 소개하는 이터레이터 헬퍼 메서드는 모두 실행 시 이터레이터를 소비하여, 그 결과로 이터레이터가 아닌 값을 반환합니다. 이터레이터를 소비하므로, 이후로는 이터레이터 헬퍼 메서드를 체이닝할 수 없습니다.</p>
<h4 id="2-1-reduce-reducer-initialValue-•-Iterator-prototype-reduce"><a href="#2-1-reduce-reducer-initialValue-•-Iterator-prototype-reduce" class="headerlink" title="2-1. .reduce(reducer [, initialValue ]) • Iterator.prototype.reduce"></a>2-1. <code>.reduce(reducer [, initialValue ])</code> • <code>Iterator.prototype.reduce</code></h4><p><code>reduce</code> 메서드는 이터레이터(<code>this</code>)의 각 요소에 대해 인자로 받은 함수(<code>reducer</code>)를 실행한 결과를 누적하여 최종 값을 반환합니다.</p>
<h4 id="2-2-toArray-•-Iterator-prototype-toArray"><a href="#2-2-toArray-•-Iterator-prototype-toArray" class="headerlink" title="2-2. .toArray() • Iterator.prototype.toArray"></a>2-2. <code>.toArray()</code> • <code>Iterator.prototype.toArray</code></h4><p><code>toArray</code> 메서드는 이터레이터(<code>this</code>)의 각 요소로 구성된 배열을 반환합니다.</p>
<h4 id="2-3-forEach-fn-•-Iterator-prototype-forEach"><a href="#2-3-forEach-fn-•-Iterator-prototype-forEach" class="headerlink" title="2-3. .forEach(fn) • Iterator.prototype.forEach"></a>2-3. <code>.forEach(fn)</code> • <code>Iterator.prototype.forEach</code></h4><p><code>forEach</code> 메서드는 이터레이터(<code>this</code>)의 각 요소에 대해 인자로 받은 함수(<code>fn</code>)를 실행합니다. 배열의 <code>Array.prototype.forEach</code> 메서드와 유사합니다.</p>
<h4 id="2-4-some-fn-•-Iterator-prototype-some"><a href="#2-4-some-fn-•-Iterator-prototype-some" class="headerlink" title="2-4. .some(fn) • Iterator.prototype.some"></a>2-4. <code>.some(fn)</code> • <code>Iterator.prototype.some</code></h4><p><code>some</code> 메서드는 이터레이터(<code>this</code>)의 요소 중 인자로 받은 함수(<code>fn</code>)를 실행한 결과가 하나라도 <code>true</code>이면 <code>true</code>를, 그렇지 않으면 <code>false</code>를 반환합니다. 배열의 <code>Array.prototype.some</code> 메서드와 유사합니다.</p>
<h4 id="2-5-every-fn-•-Iterator-prototype-every"><a href="#2-5-every-fn-•-Iterator-prototype-every" class="headerlink" title="2-5. .every(fn) • Iterator.prototype.every"></a>2-5. <code>.every(fn)</code> • <code>Iterator.prototype.every</code></h4><p><code>every</code> 메서드는 <code>some</code> 메서드와 반대로, 이터레이터(<code>this</code>)의 요소 중 인자로 받은 함수(<code>fn</code>)를 실행한 결과가 모두 <code>true</code>이면 <code>true</code>를, 그렇지 않으면 <code>false</code>를 반환합니다. 배열의 <code>Array.prototype.every</code> 메서드와 유사합니다.</p>
<h4 id="2-6-find-fn-•-Iterator-prototype-find"><a href="#2-6-find-fn-•-Iterator-prototype-find" class="headerlink" title="2-6. .find(fn) • Iterator.prototype.find"></a>2-6. <code>.find(fn)</code> • <code>Iterator.prototype.find</code></h4><p><code>find</code> 메서드는 이터레이터(<code>this</code>)의 요소 중 인자로 받은 함수(<code>fn</code>)를 실행한 결과가 <code>true</code>인 첫 번째 요소를 반환합니다. 결괏값이 <code>true</code>인 요소가 하나도 없다면 <code>undefined</code>를 반환합니다. 배열의 <code>Array.prototype.find</code> 메서드와 유사합니다.</p>
<h3 id="3-정적-메서드"><a href="#3-정적-메서드" class="headerlink" title="3. 정적 메서드"></a>3. 정적 메서드</h3><h4 id="3-1-Iterator-from-object"><a href="#3-1-Iterator-from-object" class="headerlink" title="3-1. Iterator.from(object)"></a>3-1. <code>Iterator.from(object)</code></h4><p><code>Iterator.from</code>은 이터레이터 또는 이터러블 객체를 인자로 받아 <code>Iterator</code> 클래스의 인스턴스를 반환합니다.</p>
<p>이터러블 객체란, 이터레이터를 반환하는 <code>[Symbol.iterator]</code> 메서드를 보유한 객체를 의미합니다. <code>[Symbol.iterator]</code>는 이터레이터 프로토콜을 따르는 객체를 반환해야 합니다. 이터레이터 프로토콜이란 ‘이터레이터’로 인정받기 위한 최소한의 규약으로, <code>next</code> 메서드를 소유하고, <code>next</code> 메서드는 호출 시 불리언 <code>done</code> 프로퍼티를 포함한 객체를 반환해야 합니다.</p>
<p>이 규약만 충족하면 내용은 개발자가 자유롭게 구현할 수 있습니다. 따라서 <code>[Symbol.iterator]</code> 메서드는 제너레이터일 수도 있고, <code>Iterator</code> 인스턴스를 반환하는 함수일 수도 있으며, 커스텀 객체를 반환하는 함수일 수도 있습니다. 앞의 두 방식은 이터레이터 헬퍼 메서드를 사용할 수 있습니다(제너레이터는 <code>Iterator</code>를 상속받음). 그러나 마지막 방식은 이터레이터 프로토콜을 충족했을 뿐, <code>Iterator</code> 클래스를 상속한 인스턴스는 아니므로 헬퍼 메서드를 사용할 수 없습니다. 이런 경우 <code>Iterator.from</code>은 원본 이터레이터를 <code>Iterator</code> 인스턴스로 변환하여 반환합니다.</p>
<p>정리하면, <code>Iterator.from</code>은 다음과 같은 동작을 수행합니다.</p>
<ol>
<li><p>대상이 <code>Iterator</code> 인스턴스라면, 대상을 그대로 반환합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatedIterator = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">&#125;)() <span class="comment">// 제너레이터(Iterator의 서브 클래스)의 인스턴스</span></span><br><span class="line"><span class="keyword">const</span> newIter1 = <span class="title class_">Iterator</span>.<span class="title function_">from</span>(generatedIterator)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatedIterator <span class="keyword">instanceof</span> <span class="title class_">Iterator</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newIter1 === generatedIterator) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>대상이 이터레이터 프로토콜을 따르는 일반 객체라면, 이를 <code>Iterator</code> 인스턴스로 변환하여 반환합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> normalIterator = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">value</span>: i, <span class="attr">done</span>: i++ &gt; <span class="number">3</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)() <span class="comment">// Iterator의 인스턴스가 아님</span></span><br><span class="line"><span class="keyword">const</span> newIter2 = <span class="title class_">Iterator</span>.<span class="title function_">from</span>(normalIterator)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(normalIterator <span class="keyword">instanceof</span> <span class="title class_">Iterator</span>) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newIter2 <span class="keyword">instanceof</span> <span class="title class_">Iterator</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>대상이 이터러블 객체라면, <code>[Symbol.iterator]</code> 메서드를 실행하여 반환된 값(이터레이터)에 위의 1번 또는 2번 항목의 동작을 적용합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatedIterableObject = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> generatedIterator</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> normalIterableObject = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> normalIterator</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newIter1 = <span class="title class_">Iterator</span>.<span class="title function_">from</span>(generatedIterableObject)</span><br><span class="line"><span class="keyword">const</span> newIter2 = <span class="title class_">Iterator</span>.<span class="title function_">from</span>(normalIterableObject)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newIter1 === generatedIterator) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(normalIterator <span class="keyword">instanceof</span> <span class="title class_">Iterator</span>) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newIter2 <span class="keyword">instanceof</span> <span class="title class_">Iterator</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="성능"><a href="#성능" class="headerlink" title="성능"></a>성능</h2><p>여기서는 성능 측정을 위한 함수를 작성하여 공통적으로 사용하겠습니다. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">test</span> = (<span class="params">title, initTarget, func, trial = <span class="number">10</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> tryCount = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">call</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="title function_">initTarget</span>()</span><br><span class="line">    <span class="keyword">const</span> t0 = performance.<span class="title function_">now</span>()</span><br><span class="line">    <span class="title function_">func</span>(target)</span><br><span class="line">    <span class="keyword">const</span> t1 = performance.<span class="title function_">now</span>()</span><br><span class="line">    result.<span class="title function_">push</span>(t1 - t0)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(tryCount++ &lt; trial) &#123;</span><br><span class="line">    <span class="title function_">call</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;title&#125;</span>: <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">    (result.reduce((r, c) =&gt; r + c) / trial).toFixed(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="subst"><span class="string">  &#125;</span> ms`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>모든 테스트는 다음 환경에서 실행하였습니다.</p>
<pre style="background-color:#ddd; padding: 10px">
- MacBook Pro (M1, 2021)
- macOS Sequoia 15.4.1
- Node.js v22.12.0
- Chrome 138.0.7158.0
- Firefox 138.0.1
- Safari 18.4
</pre>

<p>브라우저에 따라 대규모 데이터에 대한 <strong>단일 순회</strong>에서의 처리 속도가 다른데, 전반적으로 현재까지는 이터레이터가 기존 메서드에 비해 다소 느린 편입니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">50_000_000</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> [i, i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;배열&#x27;</span>, <span class="function">() =&gt;</span> arr, <span class="function"><span class="params">target</span> =&gt;</span> </span><br><span class="line">  target.<span class="title function_">forEach</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123; count++ &#125;)</span><br><span class="line">)</span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;이터레이터&#x27;</span>, <span class="function">() =&gt;</span> arr.<span class="title function_">values</span>(), <span class="function"><span class="params">target</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> v <span class="keyword">of</span> target) &#123; count++ &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-- 크롬 브라우저에서 실행한 결과 --</span></span><br><span class="line"><span class="comment">배열 307.480 ms</span></span><br><span class="line"><span class="comment">이터레이터 380.080 ms</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-- 파이어폭스 브라우저에서 실행한 결과 --</span></span><br><span class="line"><span class="comment">배열 327.800 ms</span></span><br><span class="line"><span class="comment">이터레이터 183.600 ms</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-- 사파리 브라우저에서 실행한 결과 --</span></span><br><span class="line"><span class="comment">배열 744.800 ms</span></span><br><span class="line"><span class="comment">이터레이터 873.200 ms</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-- node.js에서 실행한 결과 --</span></span><br><span class="line"><span class="comment">배열 326.346 ms</span></span><br><span class="line"><span class="comment">이터레이터 1056.682 ms</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>데이터 크기가 작은 경우에는 유의미한 성능 차이가 없습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10_000</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> [i, i])</span><br><span class="line"><span class="comment">// 이하 코드 생략</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-- 크롬 브라우저에서 실행한 결과 --</span></span><br><span class="line"><span class="comment">배열 0.100 ms</span></span><br><span class="line"><span class="comment">이터레이터 0.180 ms</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-- 파이어폭스 브라우저에서 실행한 결과 --</span></span><br><span class="line"><span class="comment">배열 0.200 ms</span></span><br><span class="line"><span class="comment">이터레이터 0.100 ms</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-- 사파리 브라우저에서 실행한 결과 --</span></span><br><span class="line"><span class="comment">배열 0.200 ms</span></span><br><span class="line"><span class="comment">이터레이터 0.200 ms</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-- node.js에서 실행한 결과 --</span></span><br><span class="line"><span class="comment">배열 0.103 ms</span></span><br><span class="line"><span class="comment">이터레이터 0.235 ms</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>위 결과와 같이, 단일 순회에서는 (일부 브라우저에서) 이터레이터가 배열의 <code>forEach</code> 메서드보다 느립니다. 하지만 이는 단일 순회에 한정된 문제일 뿐이며, 그 차이도 크지 않습니다. 오히려 다음과 같이 메서드 체이닝을 사용하는 경우, 이터레이터가 훨씬 더 효율적일 수 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pageSize = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(</span><br><span class="line">  &#123; <span class="attr">length</span>: <span class="number">50_000_000</span> &#125;, </span><br><span class="line">  <span class="function">(<span class="params">_, i</span>) =&gt;</span> (&#123; <span class="attr">isVisible</span>: i % <span class="number">3</span> !== <span class="number">0</span>, <span class="attr">index</span>: i &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getPageDataArray</span> = (<span class="params">offset = -<span class="number">1</span></span>) =&gt; <span class="function"><span class="params">target</span> =&gt;</span> </span><br><span class="line">  target</span><br><span class="line">    .<span class="title function_">slice</span>(offset + <span class="number">1</span>)</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="function"><span class="params">v</span> =&gt;</span> v.<span class="property">isVisible</span>)</span><br><span class="line">    .<span class="title function_">slice</span>(<span class="number">0</span>, pageSize)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> v.<span class="property">index</span>)</span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;배열&#x27;</span>, <span class="function">() =&gt;</span> arr, <span class="title function_">getPageDataArray</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getPageDataIterator</span> = (<span class="params">offset = -<span class="number">1</span></span>) =&gt; <span class="function"><span class="params">target</span> =&gt;</span> </span><br><span class="line">  target</span><br><span class="line">    .<span class="title function_">drop</span>(offset + <span class="number">1</span>)</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="function"><span class="params">v</span> =&gt;</span> v.<span class="property">isVisible</span>)</span><br><span class="line">    .<span class="title function_">take</span>(pageSize)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> v.<span class="property">index</span>)</span><br><span class="line">    .<span class="title function_">toArray</span>()</span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;이터레이터&#x27;</span>, <span class="function">() =&gt;</span> arr.<span class="title function_">values</span>(), <span class="title function_">getPageDataIterator</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-- 크롬 브라우저에서 실행한 결과 --</span></span><br><span class="line"><span class="comment">배열 665.720 ms</span></span><br><span class="line"><span class="comment">이터레이터 0.010 ms</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-- 파이어폭스 브라우저에서 실행한 결과 --</span></span><br><span class="line"><span class="comment">배열 826.900 ms</span></span><br><span class="line"><span class="comment">이터레이터 0.100 ms</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-- 사파리 브라우저에서 실행한 결과 --</span></span><br><span class="line"><span class="comment">배열 1160.100 ms</span></span><br><span class="line"><span class="comment">이터레이터 0.800 ms</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-- node.js에서 실행한 결과 --</span></span><br><span class="line"><span class="comment">배열 0.010 ms</span></span><br><span class="line"><span class="comment">이터레이터 0.004 ms</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>배열은 <code>filter</code> 단계에서 이미 5백만 개의 데이터를 처리하느라 메모리 사용량이 급증하거나, 연산 시간이 길어질 수 있습니다. 반면, 이터레이터는 지연 평가 덕분에 필요한 데이터만 처리하므로 훨씬 빠르고 효율적입니다. 이처럼 단일 순회에서의 성능 저하보다, 순회 횟수를 줄임으로써 얻는 이점이 훨씬 큽니다. 또한, 대규모 데이터 처리 시 메모리 초과로 인해 서비스가 중단되는 위험을 줄일 수 있다는 점도 큰 장점입니다.</p>
<p>더 나아가, 주요 브라우저 벤더들은 자바스크립트 성능 최적화를 위해 지속적으로 노력하고 있습니다. 예를 들어, ES2015 도입 초기에는 <code>let</code>, <code>const</code> 및 블록 스코프의 성능 문제가 제기되었지만, 몇 년 사이에 이러한 논란은 사라졌고, 경우에 따라 더 빠른 성능을 보이기도 했습니다. 이러한 흐름을 고려할 때, 이터레이터의 성능도 시간이 지남에 따라 개선될 가능성이 높습니다.</p>
<h2 id="데이터-타입별-이터레이터-도입-기법"><a href="#데이터-타입별-이터레이터-도입-기법" class="headerlink" title="데이터 타입별 이터레이터 도입 기법"></a>데이터 타입별 이터레이터 도입 기법</h2><p>이터레이터 헬퍼는 기존에 사용하던 모든 순회 문법을 대체할 만큼 강력한 기능을 제공합니다. 아래에서는 다양한 데이터 타입에 대해 이터레이터를 활용하는 실용적인 방법을 소개합니다.</p>
<h3 id="1-배열-Array"><a href="#1-배열-Array" class="headerlink" title="1. 배열(Array)"></a>1. 배열(Array)</h3><p>배열은 <code>Symbol.iterator</code>가 구현된 이터러블 객체입니다. 따라서 <code>[Symbol.iterator]</code> 메서드를 통해 이터레이터로 변환할 수 있습니다. <code>Iterator.from</code> 및 <code>values</code> 메서드도 동일하게 동작합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pageSize = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(</span><br><span class="line">  &#123; <span class="attr">length</span>: <span class="number">5_000_000</span> &#125;,</span><br><span class="line">  <span class="function">(<span class="params">_, i</span>) =&gt;</span> (&#123; <span class="attr">isVisible</span>: i % <span class="number">3</span> !== <span class="number">0</span>, <span class="attr">index</span>: i &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getPageData</span> = (<span class="params">iter, offset = -<span class="number">1</span></span>) =&gt;</span><br><span class="line">  iter</span><br><span class="line">    .<span class="title function_">drop</span>(offset + <span class="number">1</span>)</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="function"><span class="params">v</span> =&gt;</span> v.<span class="property">isVisible</span>)</span><br><span class="line">    .<span class="title function_">take</span>(pageSize)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> v.<span class="property">index</span>)</span><br><span class="line">    .<span class="title function_">toArray</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">getPageData</span>(arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]())</span><br><span class="line"><span class="comment">// [1, 2, 4, 5, 7]</span></span><br><span class="line"><span class="title function_">getPageData</span>(<span class="title class_">Iterator</span>.<span class="title function_">from</span>(arr), <span class="number">7</span>)</span><br><span class="line"><span class="comment">// [8, 10, 11, 13, 14]</span></span><br><span class="line"><span class="title function_">getPageData</span>(arr.<span class="title function_">values</span>(), <span class="number">14</span>)</span><br><span class="line"><span class="comment">// [16, 17, 19, 20, 22]</span></span><br></pre></td></tr></table></figure>

<h3 id="2-맵-Map-셋-Set"><a href="#2-맵-Map-셋-Set" class="headerlink" title="2. 맵(Map), 셋(Set)"></a>2. 맵(Map), 셋(Set)</h3><p>맵과 셋은 처음부터 이터레이터를 사용할 목적으로 설계된 자료구조입니다. 복잡한 연산이 필요할 때 <code>entries</code>, <code>keys</code>, 또는 <code>values</code> 메서드를 사용해 이터레이터로 변환한 뒤 연산을 수행하고, 마지막에 다시 맵 또는 셋으로 변환하면 됩니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>],</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filteredMap = <span class="keyword">new</span> <span class="title class_">Map</span>(</span><br><span class="line">  map.<span class="title function_">entries</span>().<span class="title function_">filter</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> v % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filteredMap)</span><br><span class="line"><span class="comment">// Map &#123; &#x27;b&#x27; =&gt; 2, &#x27;d&#x27; =&gt; 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> droppedValueSet = <span class="keyword">new</span> <span class="title class_">Set</span>(</span><br><span class="line">  map.<span class="title function_">values</span>().<span class="title function_">drop</span>(<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(droppedValueSet)</span><br><span class="line"><span class="comment">// Set &#123; 3, 4, 5 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"><span class="keyword">const</span> reducedKeys = set.<span class="title function_">values</span>().<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, c</span>) =&gt;</span> a + c, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reducedKeys)</span><br><span class="line"><span class="comment">// abcde</span></span><br></pre></td></tr></table></figure>

<p><code>[Symbol.iterator]</code> 메서드와 <code>Iterator.from</code>은 <code>entries</code> 메서드와 동일하게 동작합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filteredArray = map[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> v % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">  .<span class="title function_">toArray</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filteredArray)</span><br><span class="line"><span class="comment">// [[&#x27;b&#x27;, 2], [&#x27;d&#x27;, 4]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filteredSet = <span class="keyword">new</span> <span class="title class_">Set</span>(</span><br><span class="line">  <span class="title class_">Iterator</span>.<span class="title function_">from</span>(set).<span class="title function_">filter</span>(<span class="function"><span class="params">v</span> =&gt;</span> v !== <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filteredSet)</span><br><span class="line"><span class="comment">// Set &#123; &#x27;a&#x27;, &#x27;b&#x27;, &#x27;d&#x27;, &#x27;e&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-객체-Object"><a href="#3-객체-Object" class="headerlink" title="3. 객체(Object)"></a>3. 객체(Object)</h3><p>객체는 원래 순회에 적합하지 않은 자료구조입니다. 내부를 순회하는 방법이 몇 가지 있긴 하지만, 모두 한계가 있습니다.</p>
<p>우선 객체의 <code>for ... in</code> 문법은 프로토타입 체인 상의 상위 프로퍼티까지 모두 열거하여 순회합니다. 따라서 대상 객체의 프로퍼티만 출력하려면 <code>hasOwn</code>으로 필터링해야 합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Rectangle</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;사각형&#x27;</span>,</span><br><span class="line">  <span class="title function_">getSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">width</span> * <span class="variable language_">this</span>.<span class="property">height</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> square = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Rectangle</span>, &#123;</span><br><span class="line">  <span class="attr">width</span>: &#123; <span class="attr">value</span>: <span class="number">10</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">height</span>: &#123; <span class="attr">value</span>: <span class="number">10</span>, <span class="attr">enumerable</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> square) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, square[key])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// width 10</span></span><br><span class="line"><span class="comment">// name 사각형</span></span><br><span class="line"><span class="comment">// getSize() &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> square) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(square, key)) <span class="variable language_">console</span>.<span class="title function_">log</span>(key, square[key])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// width 10</span></span><br></pre></td></tr></table></figure>

<p><code>Object.entries</code>, <code>Object.keys</code>, <code>Object.values</code>는 <code>hasOwn</code> 필터링이 필요하지 않습니다. 하지만 이들은 하위 호환성을 위해 <strong>배열</strong>을 반환합니다. (배열, Map, Set의 <code>entries</code>, <code>keys</code>, <code>values</code> 메서드는 이터레이터를 반환합니다.)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(square)) <span class="comment">// [[&#x27;width&#x27;, 10]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(square))    <span class="comment">// [&#x27;width&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(square))  <span class="comment">// [10]</span></span><br></pre></td></tr></table></figure>

<p>일반 객체 자체로는 <code>for ... of</code>를 사용할 수 없습니다. 필요할 때마다 <code>Object.entries</code>, <code>Object.keys</code>, <code>Object.values</code> 등을 사용해 변환할 수 있지만, 이터레이터 변환 메서드를 적용하면 더 편리합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">IterableObject</span> = &#123;</span><br><span class="line">  <span class="title function_">entries</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Iterator</span>.<span class="title function_">from</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(<span class="variable language_">this</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">keys</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Iterator</span>.<span class="title function_">from</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">values</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Iterator</span>.<span class="title function_">from</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="variable language_">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">toIterable</span> = (<span class="params">obj</span>) =&gt; &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, <span class="title class_">IterableObject</span>)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> idols = &#123;</span><br><span class="line">  <span class="attr">rwice</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;르와이스&#x27;</span>, <span class="attr">company</span>: <span class="string">&#x27;jyb&#x27;</span> &#125;,</span><br><span class="line">  itze : &#123; <span class="attr">name</span>: <span class="string">&#x27;잇제&#x27;</span>, <span class="attr">company</span>: <span class="string">&#x27;jyb&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">btx</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;비티엑스&#x27;</span>, <span class="attr">company</span>: <span class="string">&#x27;hype&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">nuzinse</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;누진세&#x27;</span>, <span class="attr">company</span>: <span class="string">&#x27;hype&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterableIdols = <span class="title function_">toIterable</span>(idols)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...iterableIdols.<span class="title function_">entries</span>()])</span><br><span class="line"><span class="comment">// [[&#x27;rwice&#x27;, &#123; ... &#125;], [&#x27;itze&#x27;, &#123; ... &#125;], [&#x27;btx&#x27;, &#123; ... &#125;], [&#x27;nuzinse&#x27;, &#123; ... &#125;]]</span></span><br></pre></td></tr></table></figure>

<p>이제 <code>Object.entries</code>, <code>Object.keys</code>, <code>Object.values</code> 대신 이터러블 객체에서 직접 <code>entries</code>, <code>keys</code>, 또는 <code>values</code> 메서드를 호출해 이터레이터를 사용할 수 있습니다. 필요에 따라 Map이나 Set으로 변환할 수도 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jybIdols = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(</span><br><span class="line">  iterableIdols</span><br><span class="line">    .<span class="title function_">entries</span>()</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="function">(<span class="params">[, &#123; company &#125;]</span>) =&gt;</span> company === <span class="string">&#x27;jyb&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jybIdols)</span><br><span class="line"><span class="comment">// &#123;itze: &#123;name: &#x27;잇제&#x27;, company: &#x27;jyb&#x27;&#125;, rwice: &#123;name: &#x27;르와이스&#x27;, company: &#x27;jyb&#x27;&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jybIdols.<span class="property">rwice</span> === idols.<span class="property">rwice</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> idolSetEndsWithS = <span class="keyword">new</span> <span class="title class_">Set</span>(</span><br><span class="line">  iterableIdols</span><br><span class="line">    .<span class="title function_">values</span>()</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> name.<span class="title function_">endsWith</span>(<span class="string">&#x27;스&#x27;</span>))</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> name)</span><br><span class="line">)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(idolSetEndsWithS)</span><br><span class="line"><span class="comment">// Set &#123;&#x27;르와이스&#x27;, &#x27;비티엑스&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-문자열"><a href="#4-문자열" class="headerlink" title="4. 문자열"></a>4. 문자열</h3><p>문자열은 배열과 마찬가지로 <code>Symbol.iterator</code>가 구현된 이터러블 객체입니다. 따라서 <code>[Symbol.iterator]</code> 메서드나 <code>Iterator.from</code>으로 이터레이터로 변환할 수 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">crypt</span> = adder =&gt; <span class="function"><span class="params">str</span> =&gt;</span></span><br><span class="line">  <span class="title class_">Iterator</span>.<span class="title function_">from</span>(str).<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, c</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ascii = c.<span class="title function_">charCodeAt</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;<span class="built_in">String</span>.fromCharCode(ascii + adder)&#125;</span>`</span></span><br><span class="line">  &#125;, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> encrypt = <span class="title function_">crypt</span>(-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> decrypt = <span class="title function_">crypt</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> originalString = <span class="string">&#x27;Hello, World! This is iterator helpers.&#x27;</span></span><br><span class="line"><span class="keyword">const</span> encrypted = <span class="title function_">encrypt</span>(originalString)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(encrypted)</span><br><span class="line"><span class="comment">// Gdkkn+Vnqkc Sghrhrhsdq`snqgdkodqr-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decrypted = <span class="title function_">decrypt</span>(encrypted)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(decrypted)</span><br><span class="line"><span class="comment">// Hello, World! This is iterator helpers.</span></span><br></pre></td></tr></table></figure>

<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이제 이터레이터 헬퍼의 도입으로 순회 작업이 더욱 간결하고 효율적으로 개선되고 있습니다. ES2025에서는 동기(sync) 이터레이터 헬퍼가 도입되었으며, <a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-async-iterator-helpers?tab=readme-ov-file">비동기(async) 헬퍼는 별도의 제안으로 분리</a>되어 현재 Stage 2에 올라 있습니다. 동시성 관련 문제가 해결되면, 머지않아 비동기 이터레이터 헬퍼도 정식으로 도입될 것입니다.</p>
<p>단일 순회에서는 <em>아직</em> 이터레이터가 기존 메서드나 명령어보다 다소 느린 경향이 있습니다. 하지만 성능이 극도로 중요한 경우가 아니라면, 이터레이터로 전환할 때 얻는 실익이 더 크다고 생각합니다. 게다가 앞서 살펴보았듯, 단일 순회를 제외한 대부분의 복잡한 연산에서 이터레이터는 성능과 안정성 측면에서 탁월한 결과를 보여줍니다.</p>
<p>본문에서 자세히 다루지는 않았지만, 이터레이터 헬퍼는 함수형 프로그래밍과도 매우 잘 어울립니다. 앞서 직접 구현한 <code>_filter</code>, <code>_map</code> 등과 같이, 필요한 메서드들을 차곡차곡 쌓아 자신만의 함수형 프로그래밍 체계를 만들어 보는 것도 좋은 방법입니다. <strike>Lodash로부터의 해방?!</strike></p>
<p>사파리 브라우저는 2025년 3월 말에야 이터레이터 헬퍼를 정식으로 지원하기 시작했기 때문에, 당장은 일부 오류를 발견하거나 성능 저하를 경험할 가능성이 있습니다. 하지만 몇 달 내로 안정성이 크게 향상될 것이라고 기대합니다.</p>
<p>혹시 제가 빠뜨리거나 잘못 소개한 내용이 있다면 댓글로 알려주세요. 실용적인 예시를 공유해 주신다면 더욱 감사하겠습니다. 다양한 의견과 정보 교류를 통해 함께 성장하는 기회가 될 수 있다면 좋겠습니다.</p>
<hr>
<h3 id="참고-문헌"><a href="#참고-문헌" class="headerlink" title="참고 문헌"></a>참고 문헌</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-iterator-helpers">TC39 Proposal - Iterator Helpers</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator">MDN - Iterator</a></li>
</ul>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/ecmascript/">ecmascript</a><a class="article__tags__item" href="/tags/javascript/">javascript</a><a class="article__tags__item" href="/tags/es2025/">es2025</a><a class="article__tags__item" href="/tags/iterator-helper/">iterator helper</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="https://www.gravatar.com/avatar/02e9f56a3202da2e6e0e36a5a23facbb" alt="Jaenam Jung"><a class="article__author__link" title="About Jaenam Jung" rel="author">Jaenam Jung</a><p class="article__author__desc">할 수 있는걸 합니다.</p><div class="article__author__socials"><a class="article__author__socials__item" href="http://github.com/roy-jung" title="github" target="_blank"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="Jaenam Jung"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><!-- Giscus Code--><script src="https://giscus.app/client.js" data-repo="roy-jung/roy-jung.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkzMDcyNDQyMDk=" data-category="General" data-category-id="DIC_kwDOElAssc4Cs9i2" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light_protanopia" data-lang="ko" data-loading="lazy" crossorigin="anonymous" async></script><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2025-05-15T03:48:33.008Z"><meta itemprop="articleBody" content="이터레이터 헬퍼?이터레이터 헬퍼(Iterator Helper)는 ECMAScript 2025(ES2025)에 새롭게 추가될 기능으로, 이터레이터를 더욱 편리하게 사용할 수 있도록 돕는 다양한 인터페이스의 집합입니다.
ES2015에서 이터레이터 프로토콜이 도입된 이후, 필요한 기능을 직접 구현하거나 배열로 변환하여 배열 메서드를 사용하는 방법 외에는..."><meta itemprop="url" content="http://roy-jung.github.io/iterator-helper-overview/"><meta itemprop="mainEntityOfPage" content="http://roy-jung.github.io/iterator-helper-overview/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="FE재남"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="http://roy-jung.github.io/images/logo.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="http://roy-jung.github.io/iterator-helper-overview/iterator-helpers.png"><meta itemprop="url" content="http://roy-jung.github.io/iterator-helper-overview/iterator-helpers.png"><meta itemprop="width" content="200"><meta itemprop="height" content="200"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/161127_how-to-make-private-member/"><div class="related-posts__item__background" style="background-image:url('/images/category-es.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">ES6 Class에서 private member를 정의하는 방법</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/161007_is-class-only-a-syntactic-sugar/"><div class="related-posts__item__background" style="background-image:url('/images/category-es.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">ES6 Class는 단지 prototype 상속의 문법설탕일 뿐인가?</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/161128_es6-for-react/"><div class="related-posts__item__background" style="background-image:url('/images/category-es.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">ReactJS를 작성할 때에 알아두면 좋은 ES6 문법들</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/250701-history-of-js/">간략한 자바스크립트 역사</a></li><li class="recent-posts__item"><a href="/iterator-helper-overview/">이터레이터 헬퍼 맛보기</a></li><li class="recent-posts__item"><a href="/250414-react-reconciliation-deep-dive/">React Reconciliation: 컴포넌트 뒤에 숨겨진 엔진</a></li><li class="recent-posts__item"><a href="/250323-react-server-components/">리액트 서버 컴포넌트 톺아보기 (번역)</a></li><li class="recent-posts__item"><a href="/211231-review-2021/">2021 회고</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">2025 7월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">2025 5월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">2025 4월</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">2022 1월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">2020 11월</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">2020 10월</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">2017 1월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">2016 12월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">2016 11월</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">2016 10월</a><span class="archive-list-count">2</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ecmascript/">ECMAScript</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fe/">FE</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/fe/react-js/">React.js</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/fe/react-js/next-js/">Next.js</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/fe/javascript/">javascript</a><span class="category-list-count">6</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/etc/">etc</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><span class="category-list-count">1</span></li></ul></div></div></div><p class="copyright"><small>© 2025 Jaenam Jung<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>