<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RoyJung _ dev blog</title>
  
  
  <link href="http://roy-jung.github.io/atom.xml" rel="self"/>
  
  <link href="http://roy-jung.github.io/"/>
  <updated>2020-11-29T13:07:53.905Z</updated>
  <id>http://roy-jung.github.io/</id>
  
  <author>
    <name>Jaenam Jung</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>infinite scroll 구현하기 (2) swr-graphql</title>
    <link href="http://roy-jung.github.io/201130_swr-graphql-infinite-scroll/"/>
    <id>http://roy-jung.github.io/201130_swr-graphql-infinite-scroll/</id>
    <published>2020-11-29T12:07:08.000Z</published>
    <updated>2020-11-29T13:07:53.905Z</updated>
    
    <content type="html"><![CDATA[<img src="/201130_swr-graphql-infinite-scroll/0.png"/><p>최근 <a href="https://swr.vercel.app/">swr</a>이라는 fetch 전용 라이브러리가 핫합니다. 내용을 살펴보았는데, apollo-graphql을 이용할 때와 뭐가 얼마나 다를지가 잘 그려지지 않아서 이참에 연습을 좀 해보았습니다. 전체 코드는 <a href="https://github.com/roy-jung/swr-gql/tree/swr">제 깃헙</a>에 올려 놓았습니다.</p><p>1부에서는 apollo-graphql로 간단한 앱을 하나 만들었습니다. 이번 편에서는 이를 토대로 swr로 migration 해보겠습니다.</p><h2 id="lastMsgId-gt-page"><a href="#lastMsgId-gt-page" class="headerlink" title="lastMsgId -&gt; page"></a>lastMsgId -&gt; page</h2><p>1부에서 데이터의 실시간 정합성 등의 이유를 들어 fetchMore에 page 대신 lastMsgId를 활용한 방법을 소개하였습니다. 그런데 만약 데이터의 정합성을 라이브러리가 알아서 어느정도 해결해준다면 어떨까요? swr은 <code>refreshInterval</code>, <code>revalidateOnFocus</code>, <code>revalidateOnReconnect</code> 등 화면상의 데이터와 DB 데이터 간의 차이를 없애주는 다양한 옵션이 제공되고 있습니다. 그렇다면 이 부분을 크게 고려하지 않고도 충분히 신뢰할 수 있는 실시간 서비스 제공이 가능할 것 같아, 과감하게 lastMsgId를 제거하고 대신 page 단위의 fetchMore를 도입하기로 결정했습니다. 이 결정으로 많은 부분에서 코드가 상당히 가벼워졌습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  back/src/resolvers/message.js </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line">messages: <span class="function">(<span class="params">parent, &#123; lastMsgId = <span class="string">&#x27;&#x27;</span>, limit = <span class="number">15</span> &#125;, &#123; models &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> messageIds = <span class="built_in">Object</span>.keys(models.messages).reverse()</span><br><span class="line">  <span class="keyword">const</span> nextIndex = messageIds.indexOf(lastMsgId)</span><br><span class="line">  <span class="keyword">return</span> (nextIndex === -<span class="number">1</span> ? messageIds.slice(<span class="number">0</span>, limit) : messageIds.slice(nextIndex, nextIndex + limit + <span class="number">1</span>)).map(</span><br><span class="line">    id =&gt; models.messages[id],</span><br><span class="line">  )</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// to</span></span><br><span class="line">messages: <span class="function">(<span class="params">parent, &#123; page = <span class="number">0</span>, limit = <span class="number">15</span> &#125;, &#123; models &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> messageIds = <span class="built_in">Object</span>.keys(models.messages).reverse()</span><br><span class="line">  <span class="keyword">return</span> messageIds.slice(page * limit, (page + <span class="number">1</span>) * limit).map(<span class="function"><span class="params">id</span> =&gt;</span> models.messages[id])</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="mutation시-cache-update를-직접-제어-gt-swr에게-맡기기"><a href="#mutation시-cache-update를-직접-제어-gt-swr에게-맡기기" class="headerlink" title="mutation시 cache update를 직접 제어 -&gt; swr에게 맡기기"></a>mutation시 cache update를 직접 제어 -&gt; swr에게 맡기기</h2><p>apollo 체계에서는 글의 생성/수정/삭제 등의 mutation시 실제 리스트에 반영하기 위해 각각의 상황에 맞게 cache를 udpate해주는 동작에 대한 정의가 필요했습니다. swr을 쓰면 이런 부분을 모두 과감히 걷어내도 됩니다. 서비스의 성격에 따라 실시간성이 엄청나게 크리티컬하지 않은 경우라면 refreshInterval의 수치를 적절하게 조절하는 것만으로 충분합니다. 예를 들어 refreshInterval 값을 30초로 설정했다면, 어떤 변경이 있은 후 최대 30초 후에는 변경사항이 반영될 것입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/components/MsgInput.js </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line">mutate(&#123;</span><br><span class="line">  variables: &#123; ...variables, text &#125;,</span><br><span class="line">  update: <span class="function">(<span class="params">cache, &#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!variables.id) &#123;</span><br><span class="line">      cache.writeQuery(&#123;</span><br><span class="line">        query: updateQuery,</span><br><span class="line">        data: &#123; [updateTarget]: [data[mutationTarget]] &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = cache.readQuery(&#123; <span class="attr">query</span>: updateQuery &#125;)</span><br><span class="line">    <span class="keyword">const</span> source = [...res[updateTarget]]</span><br><span class="line">    <span class="keyword">const</span> targetIndex = source.findIndex(<span class="function"><span class="params">m</span> =&gt;</span> m.id === variables.id)</span><br><span class="line">    <span class="keyword">if</span> (targetIndex &lt; <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">    source[targetIndex] = data[mutationTarget]</span><br><span class="line">    cache.writeQuery(&#123;</span><br><span class="line">      query: updateQuery,</span><br><span class="line">      data: &#123; [updateTarget]: source &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// to</span></span><br><span class="line">mutate(&#123; <span class="attr">variables</span>: getVariablesFromArray([...variables, <span class="string">&#x27;text&#x27;</span>, text]) &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/components/MsgItem.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">const</span> onDelete = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.stopPropagation()</span><br><span class="line">  deleteMessage(&#123;</span><br><span class="line">    variables: &#123; id &#125;,</span><br><span class="line">    update: <span class="function">(<span class="params">cache, &#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = cache.readQuery(&#123; <span class="attr">query</span>: updateQuery &#125;)</span><br><span class="line">      cache.writeQuery(&#123;</span><br><span class="line">        query: updateQuery,</span><br><span class="line">        data: &#123; [updateTarget]: res[target].filter(<span class="function"><span class="params">m</span> =&gt;</span> m.id !== id) &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to</span></span><br><span class="line"><span class="keyword">const</span> onDelete = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.stopPropagation()</span><br><span class="line">  deleteMessage(&#123; <span class="attr">variables</span>: &#123; id &#125; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="useSWR"><a href="#useSWR" class="headerlink" title="useSWR"></a>useSWR</h2><p>본격적으로 useSWR 문법을 살펴봅시다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetcher = <span class="function">(<span class="params">...args</span>) =&gt;</span> fetch(...args)</span><br><span class="line"><span class="keyword">const</span> &#123; data, error &#125; = useSWR(<span class="string">&#x27;/api/user&#x27;</span>, fetcher, options)</span><br></pre></td></tr></table></figure><p>이게 기본입니다. 만약 추가로 id를 넘겨줘야 하는 경우에는 다음과 같이 템플릿 리터럴을 이용하길 권장하고 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; data, error &#125; = useSWR(<span class="string">`/api/user/<span class="subst">$&#123;id&#125;</span>`</span>, fetcher, options)</span><br></pre></td></tr></table></figure><p>여러개의 params를 넘겨줘야 하는 경우 fetcher를 변형하여 첫번째 인자를 배열로 넘기는 방법도 제안하고 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchUser = <span class="function">(<span class="params">url, id, page</span>) =&gt;</span> fetch(url, &#123; id, page &#125;)</span><br><span class="line"><span class="keyword">const</span> &#123; data, error &#125; = useSWR([<span class="string">&#x27;/api/user&#x27;</span>, id, page], fetchUser)</span><br></pre></td></tr></table></figure><p>useSWR은 얕은비교만을 수행하기 때문에, 다음과 같이 배열 안에 객체를 전달하면 안된다고 합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchUser = <span class="function">(<span class="params">url, params</span>) =&gt;</span> fetch(url, params)</span><br><span class="line"><span class="keyword">const</span> &#123; data, error &#125; = useSWR([<span class="string">&#x27;/api/user&#x27;</span>, &#123; id, page &#125;], fetchUser) <span class="comment">// DON&quot;T DO THIS!</span></span><br></pre></td></tr></table></figure><p>그렇다면 param 값들을 한 데 모아 객체로 전달하지 않으면서도 실제 fetch시에는 객체로 만들어줘야 한다는게 관건이겠네요. 공식문서는 이 문제를 최대한 단순하게 소개하기 위해 각 상황에 맞는 fetcher 함수를 만드는 방식을 취하고 있지만, 저는 이런걸 원하지 않습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetcher = <span class="function">(<span class="params">url, ...variables</span>) =&gt;</span> fetch(url, variables)</span><br></pre></td></tr></table></figure><p>대충 이런 형태로 동작할 수 있다면 가장 좋을 것 같은데, 그러자니 나머지 인자로 취합한 variables는 배열이고, 실제 api 호출에 필요한 variables는 객체입니다. 배열을 객체로 전환하려면 각각의 ‘key’값도 전달해야 하겠습니다. 그러기 위해 우선적으로 떠오르는건 key-value pair로 이루어진 배열 형태입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; data, error &#125; = useSWR([<span class="string">&#x27;/api/user&#x27;</span>, [<span class="string">&#x27;id&#x27;</span>, id], [<span class="string">&#x27;page&#x27;</span>, page]], fetcher)</span><br></pre></td></tr></table></figure><p>그런데 이 방식은 앞서 언급한 ‘shallow compare’의 문제를 그대로 안게 되므로 사용할 수 없습니다. 따라서 다음과 같이 할 수밖에 없겠습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetcher = <span class="function">(<span class="params">url, ...variableArr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> variables = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; variableArr.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">    variables[variableArr[i]] = variableArr[i + <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fetch(url, variables)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; data, error &#125; = useSWR([<span class="string">&#x27;/api/user&#x27;</span>, <span class="string">&#x27;id&#x27;</span>, id, <span class="string">&#x27;page&#x27;</span>, page], fetcher)</span><br></pre></td></tr></table></figure><p>이 함수를 graphql에서 사용하려면 아주 살짝만 바꿔주면 됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetcher = <span class="function">(<span class="params">query, ...variableArr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> variables = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; variableArr.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">    variables[variableArr[i]] = variableArr[i + <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> request(<span class="string">&#x27;/graphql&#x27;</span>, query, variables)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="useSWRInfinite"><a href="#useSWRInfinite" class="headerlink" title="useSWRInfinite"></a>useSWRInfinite</h2><p>infinite scroll을 구현하기 위해 가장 중요한 부분입니다. useSWR 대신 useSWRInfinite를 씁니다. useSWRInfinite의 문법은 기본적으로는 useSWR과 동일하고, infinite loading을 위한 페이징 처리 및 revalidate 관련한 옵션 몇개가 추가되어 있습니다. 그런데 이 ‘page’를 처리하기 위해서, 첫번쨰 인자로 url string이나 배열을 넘기는 대신 getKey라는 함수를 이용하도록 정의되어 있습니다.</p><p>getKey 함수에는 현재 페이지의 index값과 마지막으로 불러온 데이터 정보가 들어옵니다. 이 둘을 잘 이용해서 ‘다음 페이지’의 정보를 만들어 배열로 반환하도록 함수를 작성하면 됩니다. 즉 다음과 같은 결과를 얻을 수 있으면 됩니다. useSWRInfinite 함수는 자동으로 getKey함수를 호출하여 배열 또는 문자열을 받고, 이를 바탕으로 useSWR과 동일한 요청을 수행하도록 구현되어 있는 것 같습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getKey = <span class="function">(<span class="params">prevIndex, prevData</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">console</span>.log(prevIndex, prevData)</span><br><span class="line">  <span class="keyword">return</span> [query, ...variables]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; data, error &#125; = useSWRInfinite(getKey, fetcher, options)</span><br></pre></td></tr></table></figure><p>getKey가 어떤 방식으로 동작하는지 확인해보기 위해 콘솔로 출력을 해보았습니다. 그 결과는 다음과 같습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 null</span><br></pre></td></tr></table></figure><p>이 상태에서는 최초의 fetch 이후로는 아무리 스크롤을 내려도 다음 데이터를 로드하지 않습니다. 0페이지만 불러오기 때문인 것 같습니다. 그래서 공식문서를 다시 살펴보니, <code>size, setSize</code>가 보입니다. 현재는 size가 1인 상태인데, intersecting에 이 값을 변경해줘야만 fetchMore가 수행되는 방식인 것 같습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; data, error, size, setSize &#125; = useSWRInfinite(getKey, fetcher, options)</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (intersecting) setSize(size + <span class="number">1</span>)</span><br><span class="line">&#125;, [intersecting])</span><br></pre></td></tr></table></figure><p>이렇게 바꾸니 다음과 같은 데이터를 얻을 수 있었습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 첫번쨰 intersecting</span><br><span class="line">1 &#123;messages: Array(15)&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 두번쨰 intersecting</span><br><span class="line">1 &#123;messages: Array(15)&#125;</span><br><span class="line">2 &#123;messages: Array(15)&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 세번째 intersecting</span><br><span class="line">1 &#123;messages: Array(15)&#125;</span><br><span class="line">2 &#123;messages: Array(15)&#125;</span><br><span class="line">3 &#123;messages: Array(15)&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>결과를 보니 getKey 함수는 이전 데이터의 페이지별로 호출되는 방식인 것 같습니다. 그렇다면 useSWRInfinite 역시 getKey의 개수만큼 query를 날리겠네요. 첫번째 intersecting시에는 2번을(page 0, 1), 3번쨰 intersecting 시에는 4번을 호출하는 식일 것입니다(page 0, 1, 2, 3). 확인해보니 실제로도 network상에 쿼리요청이 다만 swr의 컨셉 자체가 서버에의 요청을 받고 나서만 화면에 보여주는 것이 아닌 cache를 먼저 보낸 다음 나중에 revalidate하는 방식이므로, 이미 불러온 페이지들에 대해서는 캐시가 동작하여 성능상의 문제는 크지 않으리란 추측이 가능합니다.</p><figure>  <image src="./1.png" alt="">  <figcaption style="text-align: center">[ 최초 요청시 vs. 첫 intersecting시 ]</figcaption></figure><p>추가로 모든 데이터가 로드된 시점에는 size가 더이상 늘어나지 않도록 처리해야 하겠습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getKey = <span class="function">(<span class="params">prevIndex, prevData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevData &amp;&amp; prevData.messages.length &lt; <span class="number">15</span>) &#123;</span><br><span class="line">    setLoadFinished()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [query, ...variables]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!loadFinished &amp;&amp; intersecting) setSize(size + <span class="number">1</span>)</span><br><span class="line">&#125;, [intersecting, loadFinished])</span><br></pre></td></tr></table></figure><p>나아가 서버로부터 전달받은 data 객체의 구조도 조금 살펴볼 필요가 있겠습니다. 일반적인 useQuery 또는 useSWR에 의한 결과는 data 내부에 바로 messages 객체가 들어있습니다. 그런데 useSWRInfinite는 페이지 단위로 나뉜 배열 형태를 띕니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; data: [ &#123;messages: Array(15)&#125;, &#123;messages: Array(15)&#125;, &#123;messages: Array(15)&#125;, ...] &#125;</span><br></pre></td></tr></table></figure><p>이들 각 데이터를 하나의 배열로 취합하여 처리하기로 합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeMsgs = <span class="function"><span class="params">data</span> =&gt;</span> data.flatMap(<span class="function"><span class="params">d</span> =&gt;</span> d.messages)</span><br></pre></td></tr></table></figure><p>이상의 내용을 반영하여 Migration한 MsgList 코드는 다음과 같습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/components/MsgList.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">const</span> MsgList = <span class="function">(<span class="params">&#123; updateQuery, updateTarget, variables = &#123;&#125;, smsgs &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [lastMsgId, setLastMsgId] = useState(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> [editingMsgId, setEditingMsgId] = useState(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> [msgs, setMsgs] = useState(smsgs || [])</span><br><span class="line">  <span class="keyword">const</span> &#123; data, error, fetchMore &#125; = useQuery(updateQuery, &#123; variables &#125;)</span><br><span class="line">  <span class="keyword">const</span> fetchMoreEl = useRef(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> [intersecting, loadFinished, setLoadFinished] = useInfiniteScroll(fetchMoreEl, !!smsgs)</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">id</span>: incomingId &#125; = msgs[msgs.length - <span class="number">1</span>] || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> messages = data?.[updateTarget]</span><br><span class="line">    <span class="keyword">if</span> (messages) setMsgs(messages)</span><br><span class="line">  &#125;, [data?.[updateTarget]])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!intersecting || loadFinished || !incomingId) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: fetchMoreData &#125; = <span class="keyword">await</span> fetchMore(&#123;</span><br><span class="line">      variables: &#123; ...variables, <span class="attr">lastMsgId</span>: incomingId &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    setLastMsgId(incomingId)</span><br><span class="line">    <span class="keyword">if</span> (fetchMoreData[updateTarget].length &lt; <span class="number">15</span>) setLoadFinished(<span class="literal">true</span>)</span><br><span class="line">  &#125;, [intersecting])</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// to</span></span><br><span class="line"><span class="keyword">const</span> MsgList = <span class="function">(<span class="params">&#123; updateQuery, updateTarget, variables = [], smsgs &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [editingMsgId, setEditingMsgId] = useState(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> [msgs, setMsgs] = useState(smsgs || [])</span><br><span class="line">  <span class="keyword">const</span> fetchMoreEl = useRef(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> [intersecting, loadFinished, setLoadFinished] = useInfiniteScroll(fetchMoreEl, !!smsgs)</span><br><span class="line">  <span class="keyword">const</span> getKey = <span class="function">(<span class="params">pageIndex, prevData</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevData &amp;&amp; prevData[updateTarget].length &lt; <span class="number">15</span>) &#123;</span><br><span class="line">      setLoadFinished()</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [updateQuery, ...variables, <span class="string">&#x27;page&#x27;</span>, pageIndex]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, error, size, setSize &#125; = useSWRInfinite(getKey, fetcher)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data?.length) setMsgs(mergeMsgs(data, updateTarget))</span><br><span class="line">  &#125;, [data])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!loadFinished &amp;&amp; intersecting) setSize(size + <span class="number">1</span>)</span><br><span class="line">  &#125;, [intersecting, loadFinished])</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>여기까지만 하고 구동시켜보면 동작은 잘 되지만, 아직 한가지 문제가 남아 있습니다. useSWRInfinite 역시 useSWR을 그대로 사용하기 때문인지, 기본적으로는 revalidate이 오직 0페이지에 대해서만 이뤄집니다. 이 상태로는 오래전 글이 수정/삭제되어도 화면에는 반영되지 않는 결과가 초래될 수 있습니다. 옵션 하나만 추가해주면 간단하게 해결됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; data, error, size, setSize &#125; = useSWRInfinite(getKey, fetcher, &#123;</span><br><span class="line">  revalidateAll: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="mutation-to-server"><a href="#mutation-to-server" class="headerlink" title="mutation to server"></a>mutation to server</h2><p>fetcher 함수가 graphql-request 라이브러리를 이용하고 있으니, 꼭 ‘query’에만 국한지어 사용할 이유가 없을 것 같습니다. mutation을 모두 fetcher로 대체하면 apollo-client를 아예 걷어낼 수 있겠네요.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/components/MsgInput.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">const</span> [mutate, &#123; data &#125;] = useMutation(mutationQuery)</span><br><span class="line"><span class="keyword">const</span> onSubmit = <span class="keyword">async</span> e =&gt; &#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  <span class="keyword">const</span> text = textRef.current.value</span><br><span class="line">  mutate(&#123; <span class="attr">variables</span>: &#123; ...variables, text &#125; &#125;)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// to</span></span><br><span class="line"><span class="keyword">const</span> onSubmit = <span class="keyword">async</span> e =&gt; &#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  <span class="keyword">const</span> text = textRef.current.value</span><br><span class="line">  fetcher(mutationQuery, ...variables, <span class="string">&#x27;text&#x27;</span>, text)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/components/MsgItem.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">const</span> [deleteMessage] = useMutation(DELETE_MESSAGE)</span><br><span class="line"><span class="keyword">const</span> onDelete = <span class="keyword">async</span> e =&gt; &#123;</span><br><span class="line">  deleteMessage(&#123; <span class="attr">variables</span>: &#123; id &#125; &#125;)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// to</span></span><br><span class="line"><span class="keyword">const</span> onDelete = <span class="keyword">async</span> e =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> fetcher(DELETE_MESSAGE, <span class="string">&#x27;id&#x27;</span>, id)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h2 id="apollo-setting"><a href="#apollo-setting" class="headerlink" title="apollo setting"></a>apollo setting</h2><p>이제 모든 graphql request를 swr 및 fetcher가 담당하게 되었으니, apollo는 필요가 없습니다.</p><h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p>getServerSideProps 내부도 상당히 단순해집니다. 앞서 만들어둔 fetcher 함수를 그대로 사용하면 됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/pages/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getServerSideProps = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> apolloClient = <span class="keyword">await</span> getStandaloneApolloClient()</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> apolloClient.query(&#123; <span class="attr">query</span>: GET_MESSAGES &#125;)</span><br><span class="line">  <span class="keyword">const</span> initialState = apolloClient.cache.extract()</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      initialState,</span><br><span class="line">      smsgs: res.data?.[msgTarget],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getServerSideProps = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> msgData = <span class="keyword">await</span> fetcher(GET_MESSAGES)</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">props</span>: &#123; <span class="attr">smsgs</span>: msgData?.[msgTarget] &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mutation-gt-revalidate"><a href="#mutation-gt-revalidate" class="headerlink" title="mutation -&gt; revalidate"></a>mutation -&gt; revalidate</h2><p>타인의 수정/삭제/추가에 대한 반영은 refreshInterval, revalidateOnFocus 등의 옵션만 적절히 지정해주면 충분하겠지만, 현재 화면에서 이뤄진 동작은 즉시 반영하지 않으면 난감할 수 있습니다. 삭제하라고 명령했는데 화면상에선 그대로라면 난감하겠죠. apollo에서는 이런 상황을 처리하기 위해서 useQuery 내부에 update 메서드를 두었던 것인데, 지금은 이걸 제거하였으니 대신하여 처리할 무언가가 필요합니다. useSWR, useSWRInfinite에는 이 역할을 수행해줄 ‘mutate’라는 함수가 마련되어 있습니다. useSWR은 하나의 데이터를 처리하고, useSWRInfinite는 배열의 각 요소를 처리합니다.</p><p>mutate 함수는 두 군데에서 존재하는데, 하나는 swr에서 직접 import할 수 있는 함수이고, 다른 하나는 useSWR의 실행 결과로 얻을 수 있는 것입니다. 전자는 mutation이 발생한 key와 변경된 value를 넘겨주면 해당 key로 등록된 모든 useSWR 함수들에 broadcast 되는 함수이고, 후자는 호출한 useSWR 하나의 변경에만 국한된(bounded) 함수입니다. 두 함수 모두 그 자체로 서버에의 put / post / patch / delete 등의 요청을 수행하는 함수가 아닌, 어디까지나 화면상의 ‘데이터 갱신’에 관련한 함수입니다(필자가 공식문서를 잘못 이해한 것일지도 모르겠습니다. 만약 그렇다면 알려주시면 감사하겠습니다).</p><p>그런데 rest api의 경우 key는 곧 문자열이기 때문에 broadcast가 의미가 있겠으나, 아쉽게도 graphql의 경우에는 그렇지가 못합니다. query문 자체가 참조형 데이터이다 보니 각 useSWR에서 생성한 query는 모두 다르기 때문입니다. (이 역시 제가 이해하는 한에서는 그렇다는 것입니다. 틀렸기를 바랍니다 ㅠ)</p><p>하여 현재로서는 몹시 아쉽지만 mutation을 catch하여 변경사항을 반영하거나 revalidate하는 로직은 별도의 처리가 필요합니다. 전역에서 쓰일 context를 생성하여 mutate시에 updateTarget을 지정해주고, 각 컴포넌트에서 지정된 target과 일치할 때에 useSWR에 있는 mutate를 호출해주는 방식을 떠올렸습니다. mutate를 호출하자마자 context에 지정된 target을 지워주면 될 것 같습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/contexts/mutationObserver.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createContext, useContext, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MutationObserverContext = createContext(&#123; <span class="attr">target</span>: <span class="string">&#x27;&#x27;</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> MutationObserverProvider = <span class="function">(<span class="params">&#123; children &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [mutated, setMutated] = useState(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;MutationObserverContext.Provider</span><br><span class="line">      value=&#123;&#123;</span><br><span class="line">        mutated,</span><br><span class="line">        setMutated,</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/MutationObserverContext.Provider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> useMutationObserver = <span class="function">() =&gt;</span> useContext(MutationObserverContext)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/component/MsgInput.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; setMutated &#125; = useMutationObserver()</span><br><span class="line"><span class="keyword">const</span> textRef = useRef(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> onSubmit = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  <span class="keyword">const</span> text = textRef.current.value</span><br><span class="line">  fetcher(mutationQuery, ...variables, <span class="string">&#x27;text&#x27;</span>, text)</span><br><span class="line">  setMutated(updateTarget)</span><br><span class="line">  textRef.current.value = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  doneEdit &amp;&amp; doneEdit()</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/component/MsgList.js</span></span><br><span class="line"><span class="keyword">const</span> [intersecting, loadFinished, setLoadFinished] = useInfiniteScroll(fetchMoreEl, !!smsgs)</span><br><span class="line"><span class="keyword">const</span> &#123; mutated, setMutated &#125; = useMutationObserver()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getKey = <span class="function">(<span class="params">pageIndex, prevData</span>) =&gt;</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">const</span> &#123; data, error, mutate, size, setSize &#125; = useSWRInfinite(getKey, fetcher, &#123;</span><br><span class="line">  revalidateAll: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (mutated === updateTarget) &#123;</span><br><span class="line">    mutate()</span><br><span class="line">    setMutated(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [mutated])</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이상으로 마이그레이션을 모두 마쳤습니다. 전체 변경사항은 <a href="https://github.com/roy-jung/swr-gql/compare/graphql...swr?diff=split">PR</a>을 보시면 더 용이하겠네요.</p><p>‘swr이라는 라이브러리를 한 번 써보기나 하자’ 라는 취지로 시작했던 것이 어쩌다보니 일이 커져버렸는데, 그래도 어떻게든 끝마쳐서 다행이네요. 실제로 사용해보니 swr은 생각보다 강력한 녀석 같습니다. 당장 실무에 적용해도 아무런 문제가 없을 것 같고, 기존 대비 상당히 적은 노력으로 더욱 훌륭한 퍼포먼스를 기대할 수 있을 것 같네요.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/201130_swr-graphql-infinite-scroll/0.png&quot;/&gt;&lt;p&gt;최근 &lt;a href=&quot;https://swr.vercel.app/&quot;&gt;swr&lt;/a&gt;이라는 fetch 전용 라이브러리가 핫합니다. 내용을 살펴보았는데, a</summary>
      
    
    
    
    <category term="FE" scheme="http://roy-jung.github.io/categories/fe/"/>
    
    <category term="React.js" scheme="http://roy-jung.github.io/categories/fe/react-js/"/>
    
    
    <category term="React.js" scheme="http://roy-jung.github.io/tags/react-js/"/>
    
    <category term="graphQL" scheme="http://roy-jung.github.io/tags/graphql/"/>
    
    <category term="swr" scheme="http://roy-jung.github.io/tags/swr/"/>
    
  </entry>
  
  <entry>
    <title>infinite scroll 구현하기 (1) apollo-graphql</title>
    <link href="http://roy-jung.github.io/201129_apollo-graphql-infinite-scroll/"/>
    <id>http://roy-jung.github.io/201129_apollo-graphql-infinite-scroll/</id>
    <published>2020-11-28T11:07:08.000Z</published>
    <updated>2020-11-29T12:50:37.156Z</updated>
    
    <content type="html"><![CDATA[<img src="/201129_apollo-graphql-infinite-scroll/0.png"/><p>최근 <a href="https://swr.vercel.app/">swr</a>이라는 fetch 전용 라이브러리가 핫합니다. 내용을 살펴보았는데, apollo-graphql을 이용할 때와 뭐가 얼마나 다를지가 잘 그려지지 않아서 이참에 연습을 좀 해보았습니다. 원래는 swr을 연습하기 위한 것이었는데 막상 작업을 착수하고 보니 2020년 7월에 Apollo Client v3.이 릴리즈되었더군요. 기존 2.x대와 달라진 내용이 많아 이 부분에서 더 오랜 시간을 할애했습니다. 아직 Apollo Client v3. 환경에서 GraphQL로 무한스크롤을 구현한 예제가 거의 없는 것 같아, 겸사겸사 공유하고자 블로깅 합니다.</p><p>전체 코드는 <a href="https://github.com/roy-jung/swr-gql/tree/graphql">제 깃헙</a>에 올려 놓았습니다.</p><p>우선 apollo-graphql로 간단한 앱을 하나 만들고(1부), 이를 토대로 swr로 migration 해보는 것(2부)이 목표입니다.</p><h2 id="back-end"><a href="#back-end" class="headerlink" title="back-end"></a>back-end</h2><p>back-end 파트는 graphql의 동작을 확인할 수만 있으면 되기에, 최대한 간단한 방법을 이용했습니다. query는 단순히 json 파일을 불러오고, mutation은 node.js의 fs.writeFile을 이용하여 로컬 json을 계속 덮어씌우는 방식으로 구현했습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./writeModel.js</span></span><br><span class="line"><span class="keyword">const</span> filenames = &#123;</span><br><span class="line">  user: resolve(__dirname, <span class="string">&#x27;../models/user.js&#x27;</span>),</span><br><span class="line">  message: resolve(__dirname, <span class="string">&#x27;../models/message.js&#x27;</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">target, data</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.writeFile(filenames[target], <span class="string">`module.exports = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>`</span>, <span class="function">(<span class="params">...err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./resolver/message.js</span></span><br><span class="line"><span class="keyword">const</span> messageResolvers = &#123;</span><br><span class="line">  Query: &#123;</span><br><span class="line">    messages: <span class="function">(<span class="params">parent, &#123; lastMsgId = <span class="string">&#x27;&#x27;</span>, limit = <span class="number">15</span> &#125;, &#123; models &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> messageIds = <span class="built_in">Object</span>.keys(models.messages).reverse()</span><br><span class="line">      <span class="keyword">const</span> nextIndex = messageIds.indexOf(lastMsgId)</span><br><span class="line">      <span class="keyword">return</span> (nextIndex === -<span class="number">1</span> ? messageIds.slice(<span class="number">0</span>, limit) : messageIds.slice(nextIndex, nextIndex + limit + <span class="number">1</span>)).map(</span><br><span class="line">        id =&gt; models.messages[id],</span><br><span class="line">      )</span><br><span class="line">    &#125;,</span><br><span class="line">    message: <span class="function">(<span class="params">parent, &#123; id &#125;, &#123; models &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> models.messages[id]</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  Mutation: &#123;</span><br><span class="line">    createMessage: <span class="function">(<span class="params">parent, &#123; text &#125;, &#123; me, models &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> id = uuidv4()</span><br><span class="line">      <span class="keyword">const</span> message = &#123;</span><br><span class="line">        id,</span><br><span class="line">        text,</span><br><span class="line">        userId: me.id,</span><br><span class="line">        timestamp: <span class="built_in">String</span>(<span class="built_in">Date</span>.now()),</span><br><span class="line">      &#125;</span><br><span class="line">      models.messages[id] = message</span><br><span class="line">      writeModel(<span class="string">&#x27;message&#x27;</span>, models.messages)</span><br><span class="line">      <span class="keyword">return</span> message</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...생략</span></span><br><span class="line">  &#125;,</span><br><span class="line">  Message: &#123;</span><br><span class="line">    user: <span class="function">(<span class="params">message, args, &#123; models &#125;</span>) =&gt;</span> models.users[message.userId],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>message list를 무한스크롤 방식으로 fetch하기 위해 가장 중요한 부분이 바로 pagination 처리일텐데, 최소한의 실시간성이 보장되어야 하는 환경, 즉 트위터나 페이스북 같은 경우를 상정했을 때엔 단순히 ‘페이지’ 단위로 리스트를 불러오는 것은 리스크가 있을 것입니다. 예를 들어 DB의 변화가 없는 경우라면 최초 1페이지의 메시지ID 목록이 최신순으로 <code>[40, 39, 38, 37, 36]</code>라고 했을 때 2페이지는 <code>[35, 34, 33, 32, 31]</code>이 되어야 맞겠지만, 그 사이 누군가 ID가 37인 글을 삭제하여 DB상에는 ID 37에 해당하는 글이 사라진 상태인 경우 2페이지는 <code>[34, 33, 32, 31, 30]</code>가 되어버립니다. 새 글이 추가된 경우에도 역시 페이지네이션은 꼬여버릴 수밖에 없습니다. 따라서 저는 화면상의 마지막 ID(lastMsgId)를 기준으로 다음 리스트를 불러오는 방식을 취했습니다. 그밖엔 백엔드 파트에선 특별히 언급할 내용이 없네요. 빠르게 프론트엔드 파트로 넘어가겠습니다.</p><h2 id="front-end"><a href="#front-end" class="headerlink" title="front-end"></a>front-end</h2><p>front-end는 react.js, next.js, apollo-client를 기반으로 작업하였습니다.</p><h3 id="apollo-setting"><a href="#apollo-setting" class="headerlink" title="apollo setting"></a>apollo setting</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./apollo.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ApolloClient, InMemoryCache &#125; <span class="keyword">from</span> <span class="string">&#x27;@apollo/client&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; withApollo &#125; <span class="keyword">from</span> <span class="string">&#x27;next-with-apollo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mergeItems = <span class="function">(<span class="params">a = [], b = []</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b].map(<span class="function"><span class="params">m</span> =&gt;</span> m.__ref))).map(<span class="function"><span class="params">r</span> =&gt;</span> (&#123; <span class="attr">__ref</span>: r &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> messagePolicies = &#123;</span><br><span class="line">  <span class="function"><span class="title">read</span>(<span class="params">existing</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> existing</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">merge</span>(<span class="params">existing = [], incoming = [], &#123; args: &#123; lastMsgId &#125;, readField &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> extIndex = existing.findIndex(<span class="function"><span class="params">e</span> =&gt;</span> readField(<span class="string">&#x27;id&#x27;</span>, e) === lastMsgId)</span><br><span class="line">    <span class="keyword">if</span> (extIndex &gt; -<span class="number">1</span>) <span class="keyword">return</span> mergeItems(existing, incoming)</span><br><span class="line">    <span class="keyword">return</span> mergeItems(incoming, existing)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> initializeApollo = <span class="function"><span class="params">props</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> ApolloClient(&#123;</span><br><span class="line">    uri: <span class="string">&#x27;http://localhost:8000/graphql&#x27;</span>,</span><br><span class="line">    cache: <span class="keyword">new</span> InMemoryCache(&#123;</span><br><span class="line">      typePolicies: &#123;</span><br><span class="line">        Query: &#123;</span><br><span class="line">          fields: &#123;</span><br><span class="line">            messages: messagePolicies,</span><br><span class="line">            userMessages: messagePolicies,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;).restore(props?.initialState || &#123;&#125;),</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getStandaloneApolloClient = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; ApolloClient, InMemoryCache, HttpLink &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;@apollo/client&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> initializeApollo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> withApolloClient = withApollo(initializeApollo)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withApolloClient</span><br></pre></td></tr></table></figure><p>ApolloClient v3.에서 가장 달라진 점은 뭐니뭐니해도 <code>typePolicies</code> 부분일 것입니다. 이 부분만 요구사항에 맞게 잘 구현해 놓으면 컴포넌트에서 제어해야 하는 부분이 상당히 줄어드는 것 같습니다. 그런데 그런것치고는 제가 느끼기에는 공식 문서가 좀 빈약하여 애를 많이 먹었습니다.<br>각 필드별로 정책을 달리 할 수 있는데, query가 호출될 때마다 해당 정책 내의 모든 메서드가 실행됩니다. 제 코드상에서는 read와 merge가 실행됩니다. 공식문서에는 merge 부분에서 단순히 <code>return [...existing, ...incoming]</code> 식으로 처리하라고 되어있는데, 이러면 상황에 따라 데이터가 중복되어 버립니다. 중복을 제거하기 위해 <code>mergeItems</code>라는 메서드를 따로 만들어야 했습니다. read 없이 merge만 있는 경우, fetchMore시 새로 불러온 데이터만 화면에 노출되게 됩니다.</p><h3 id="graphql"><a href="#graphql" class="headerlink" title="graphql"></a>graphql</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># .&#x2F;graphql&#x2F;message.gql</span><br><span class="line">query GET_MESSAGES($lastMsgId: ID &#x3D; &quot;&quot;, $limit: Int) &#123;</span><br><span class="line">  messages(lastMsgId: $lastMsgId, limit: $limit) &#123;</span><br><span class="line">    id</span><br><span class="line">    text</span><br><span class="line">    user &#123;</span><br><span class="line">      id</span><br><span class="line">      nickname</span><br><span class="line">      fullname</span><br><span class="line">    &#125;</span><br><span class="line">    timestamp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 이하 생략</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># .&#x2F;graphql&#x2F;user.gql</span><br><span class="line">query GET_USER($id: ID!) &#123;</span><br><span class="line">  user(id: $id) &#123;</span><br><span class="line">    id</span><br><span class="line">    fullname</span><br><span class="line">    nickname</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">query GET_USER_MESSAGES($id: ID!, $lastMsgId: ID, $limit: Int) &#123;</span><br><span class="line">  userMessages(id: $id, lastMsgId: $lastMsgId, limit: $limit) &#123;</span><br><span class="line">    id</span><br><span class="line">    text</span><br><span class="line">    timestamp</span><br><span class="line">    user &#123;</span><br><span class="line">      nickname</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>user/[id] 페이지에서는 해당 유저의 글목록을 노출하고자 했습니다. <code>GET_USER_MESSAGES</code>는 userId가 필요하다는 점을 제외하곤 모든 면에서 <code>GET_MESSAGES</code>와 동일합니다.</p><h3 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./pages/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; CREATE_MESSAGE, GET_MESSAGES &#125; <span class="keyword">from</span> <span class="string">&#x27;../graphql/message.gql&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> msgTarget = <span class="string">&#x27;messages&#x27;</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">(<span class="params">&#123; smsgs &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;MsgInput</span><br><span class="line">      updateQuery=&#123;GET_MESSAGES&#125;</span><br><span class="line">      updateTarget=&#123;msgTarget&#125;</span><br><span class="line">      mutationQuery=&#123;CREATE_MESSAGE&#125;</span><br><span class="line">      mutationTarget=<span class="string">&quot;createMessage&quot;</span></span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;MsgList updateTarget=&#123;msgTarget&#125; updateQuery=&#123;GET_MESSAGES&#125; smsgs=&#123;smsgs&#125; /&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getServerSideProps = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> apolloClient = <span class="keyword">await</span> getStandaloneApolloClient()</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> apolloClient.query(&#123; <span class="attr">query</span>: GET_MESSAGES &#125;)</span><br><span class="line">  <span class="keyword">const</span> initialState = apolloClient.cache.extract()</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      initialState,</span><br><span class="line">      smsgs: res.data?.[msgTarget],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MsgList 컴포넌트를 뒤이어 나올 <code>user/[id]</code> 에서도 활용하기 위해, ‘updateQuery, updateTarget’의 두 개의 프로퍼티를 작성했습니다. <code>/</code>(root)에서는 <code>GET_MESSAGE</code>(updateQuery)로 쿼리를 보내고, 그 결과는 <code>&#123;data: messages: [MSG] &#125;</code>가 되는 반면(updateTarget), <code>/user/[id]</code>에서는 <code>GET_USER_MESSAGES</code>(updateQuery)로 쿼리를 보내고, 그 결과는 <code>&#123;data: userMessages: [MSG] &#125;</code>가 됩니다(updateTarget).</p><p>한편 MsgInput은 새 글을 작성할 때도 사용하고, 이미 작성한 글을 수정할 때도 사용합니다. 새 글 작성시에는 mutation으로 <code>CREATE_MESSAGE</code>(mutationQuery)를 보내고, 그 결과는 <code>&#123;data: createMessage: MSG &#125;</code>가 되며(mutationTarget), 이를 <code>messages</code>에 반영(udpateTarget)하기 위해 기존 메시지 리스트를 불러와야(updateQuery) 합니다. 글 수정은 <code>/</code>(root)에서도 할 수 있고, <code>/user/[id]</code>에서도 할 수 있어야 합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/user/[id].js</span></span><br><span class="line"><span class="keyword">import</span> &#123; GET_USER, GET_USER_MESSAGES &#125; <span class="keyword">from</span> <span class="string">&#x27;../../graphql/user.gql&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> msgsTarget = <span class="string">&#x27;userMessages&#x27;</span></span><br><span class="line"><span class="keyword">const</span> User = <span class="function">(<span class="params">&#123; suser, smsgs &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> router = useRouter()</span><br><span class="line">  <span class="keyword">const</span> id = router.query.id</span><br><span class="line">  <span class="keyword">const</span> [getUser, &#123; <span class="attr">data</span>: userData &#125;] = useLazyQuery(GET_USER)</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(suser || &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!suser) getUser(&#123; <span class="attr">variables</span>: &#123; id &#125; &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (userData?.user) setUser(userData.user)</span><br><span class="line">  &#125;, [userData])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; nickname, fullname &#125; = user</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &#123;nickname&#125; &#123;fullname&#125;</span><br><span class="line">      &lt;MsgList updateTarget=&#123;msgsTarget&#125; updateQuery=&#123;GET_USER_MESSAGES&#125; variables=&#123;&#123; id &#125;&#125; smsgs=&#123;smsgs&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getServerSideProps = <span class="keyword">async</span> (&#123; <span class="attr">query</span>: &#123; id &#125; &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> apolloClient = <span class="keyword">await</span> getStandaloneApolloClient()</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    apolloClient.query(&#123; <span class="attr">query</span>: GET_USER, <span class="attr">variables</span>: &#123; id &#125; &#125;),</span><br><span class="line">    apolloClient.query(&#123; <span class="attr">query</span>: GET_USER_MESSAGES, <span class="attr">variables</span>: &#123; id &#125; &#125;),</span><br><span class="line">  ])</span><br><span class="line">  <span class="keyword">const</span> initialState = apolloClient.cache.extract()</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      initialState,</span><br><span class="line">      suser: res[<span class="number">0</span>].data?.user,</span><br><span class="line">      smsgs: res[<span class="number">1</span>].data?.[msgsTarget],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/user/[id] 에서는 SSR로 user정보와 userMessages를 모두 호출했습니다. SSR이 호출되는 경우도 있고 그렇지 않은 경우도 있는데, 그렇지 않은 경우에는 LazyQuery로 최초 render시 한 번만 호출하게끔 했습니다.</p><h3 id="components"><a href="#components" class="headerlink" title="components"></a>components</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./components/MsgInput.js</span></span><br><span class="line"><span class="keyword">const</span> MsgInput = (&#123;</span><br><span class="line">  mutationQuery,</span><br><span class="line">  mutationTarget,</span><br><span class="line">  updateQuery,</span><br><span class="line">  updateTarget,</span><br><span class="line">  text = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  doneEdit,</span><br><span class="line">  variables = &#123;&#125;,</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [mutate, &#123; data &#125;] = useMutation(mutationQuery)</span><br><span class="line">  <span class="keyword">const</span> textRef = useRef(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> onSubmit = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">    <span class="keyword">const</span> text = textRef.current.value</span><br><span class="line">    mutate(&#123;</span><br><span class="line">      variables: &#123; ...variables, text &#125;,</span><br><span class="line">      update: <span class="function">(<span class="params">cache, &#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!variables.id) &#123;</span><br><span class="line">          cache.writeQuery(&#123;</span><br><span class="line">            query: updateQuery,</span><br><span class="line">            data: &#123; [updateTarget]: [data[mutationTarget]] &#125;,</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> res = cache.readQuery(&#123; <span class="attr">query</span>: updateQuery &#125;)</span><br><span class="line">        <span class="keyword">const</span> source = [...res[updateTarget]]</span><br><span class="line">        <span class="keyword">const</span> targetIndex = source.findIndex(<span class="function"><span class="params">m</span> =&gt;</span> m.id === variables.id)</span><br><span class="line">        <span class="keyword">if</span> (targetIndex &lt; <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">        source[targetIndex] = data[mutationTarget]</span><br><span class="line">        cache.writeQuery(&#123;</span><br><span class="line">          query: updateQuery,</span><br><span class="line">          data: &#123; [updateTarget]: source &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    textRef.current.value = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    doneEdit &amp;&amp; doneEdit()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form className=<span class="string">&quot;messages_input&quot;</span> onSubmit=&#123;onSubmit&#125;&gt;</span><br><span class="line">      &lt;textarea maxLength=<span class="string">&quot;140&quot;</span> ref=&#123;textRef&#125; defaultValue=&#123;text&#125; /&gt;</span><br><span class="line">      &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;전송&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MsgInput 컴포넌트는 인덱스 최상단의 ‘새글작성’ 및 각 메시지의 ‘수정’ 모두에서 활용합니다. 때문에 onSubmit 함수의 <code>mutate</code> 부분이 조금 길어졌습니다. 새 글은 writeQuery만으로 충분하지만, 수정의 경우 로딩된 글목록에 대상 메시지가 존재할 경우에만 cache를 업데이트해주어야 합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useInfiniteScroll = <span class="function">(<span class="params">targetEl, ssr = <span class="literal">false</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> observerRef = useRef(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> isFirstRender = useRef(!ssr)</span><br><span class="line">  <span class="keyword">const</span> [isIntersecting, setIntersecting] = useState(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> [loadFinished, setLoadFinished] = useState(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getObserver = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!observerRef.current) &#123;</span><br><span class="line">      observerRef.current = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">entries</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> intersecting = entries.some(<span class="function"><span class="params">entry</span> =&gt;</span> entry.isIntersecting)</span><br><span class="line">        <span class="keyword">if</span> (isFirstRender.current &amp;&amp; intersecting) &#123;</span><br><span class="line">          isFirstRender.current = <span class="literal">false</span></span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        setIntersecting(intersecting)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> observerRef.current</span><br><span class="line">  &#125;, [observerRef.current])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> stopObserving = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    getObserver().disconnect()</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (targetEl.current) getObserver().observe(targetEl.current)</span><br><span class="line">    <span class="keyword">return</span> stopObserving</span><br><span class="line">  &#125;, [targetEl.current])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (loadFinished) stopObserving()</span><br><span class="line">  &#125;, [loadFinished])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [isIntersecting, loadFinished, setLoadFinished]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>intersectionObserver를 이용한 hook입니다. targetEl이 intersecting된 경우에 isIntersecting이 true가 됩니다. 더이상 불러올 데이터가 없을 경우 setLoadFinished를 호출하여 loadFinished 값이 true가 되도록 했습니다. SSR 값이 있는 경우에는 isFirstRender가 처음부터 false가 되도록 했습니다. SSR 값이 없을 경우에는 useInfiniteScroll이 처음 렌더되는 시점이 query data가 로딩되기 전이기 때문에, isFirstRender를 true로 하여 isIntersecting에 의한 fetchmore 트리거가 동작하지 않게끔 처리했습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/components/MsgList</span></span><br><span class="line"><span class="keyword">const</span> MsgList = <span class="function">(<span class="params">&#123; updateQuery, updateTarget, variables = &#123;&#125;, smsgs &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [lastMsgId, setLastMsgId] = useState(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> [editingMsgId, setEditingMsgId] = useState(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> [msgs, setMsgs] = useState(smsgs || [])</span><br><span class="line">  <span class="keyword">const</span> &#123; data, error, fetchMore &#125; = useQuery(updateQuery, &#123; variables &#125;)</span><br><span class="line">  <span class="keyword">const</span> fetchMoreEl = useRef(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> [intersecting, loadFinished, setLoadFinished] = useInfiniteScroll(fetchMoreEl, !!smsgs)</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">id</span>: incomingId &#125; = msgs[msgs.length - <span class="number">1</span>] || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> doneEdit = <span class="function">() =&gt;</span> setEditingMsgId(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> messages = data?.[updateTarget]</span><br><span class="line">    <span class="keyword">if</span> (messages) setMsgs(messages)</span><br><span class="line">  &#125;, [data?.[updateTarget]])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!intersecting || loadFinished || !incomingId) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: fetchMoreData &#125; = <span class="keyword">await</span> fetchMore(&#123;</span><br><span class="line">      variables: &#123; ...variables, <span class="attr">lastMsgId</span>: incomingId &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    setLastMsgId(incomingId)</span><br><span class="line">    <span class="keyword">if</span> (fetchMoreData[updateTarget].length &lt; <span class="number">15</span>) setLoadFinished(<span class="literal">true</span>)</span><br><span class="line">  &#125;, [intersecting])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (error) <span class="built_in">console</span>.error(error)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;ul className=<span class="string">&quot;messages&quot;</span>&gt;</span><br><span class="line">        &#123;msgs.map(<span class="function"><span class="params">msg</span> =&gt;</span> (</span><br><span class="line">          &lt;MsgItem</span><br><span class="line">            &#123;...msg&#125;</span><br><span class="line">            key=&#123;msg.id&#125;</span><br><span class="line">            updateQuery=&#123;updateQuery&#125;</span><br><span class="line">            updateTarget=&#123;updateTarget&#125;</span><br><span class="line">            editing=&#123;editingMsgId === msg.id&#125;</span><br><span class="line">            startEdit=&#123;<span class="function">() =&gt;</span> setEditingMsgId(msg.id)&#125;</span><br><span class="line">            doneEdit=&#123;doneEdit&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">      &lt;div ref=&#123;fetchMoreEl&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>앞서 apollo.js에서 typePolicies를 정의해두었기 때문에 fethMore에서 cache에 관여할 필요가 없습니다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>다음 파트에서 본격적으로 swr로 바꿔보겠습니다. (<a href="https://github.com/roy-jung/swr-gql/tree/swr">깃헙</a>에는 이미 코드를 올려놓긴 헀습니다..)</p><p>뭘 더 적어야 좋을지 모르겠네요…하하 (도망)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/201129_apollo-graphql-infinite-scroll/0.png&quot;/&gt;&lt;p&gt;최근 &lt;a href=&quot;https://swr.vercel.app/&quot;&gt;swr&lt;/a&gt;이라는 fetch 전용 라이브러리가 핫합니다. 내용을 살펴보았는데</summary>
      
    
    
    
    <category term="FE" scheme="http://roy-jung.github.io/categories/fe/"/>
    
    <category term="React.js" scheme="http://roy-jung.github.io/categories/fe/react-js/"/>
    
    
    <category term="React.js" scheme="http://roy-jung.github.io/tags/react-js/"/>
    
    <category term="Apollo" scheme="http://roy-jung.github.io/tags/apollo/"/>
    
    <category term="graphQL" scheme="http://roy-jung.github.io/tags/graphql/"/>
    
  </entry>
  
  <entry>
    <title>redux-saga를 간결하게 사용해보자!</title>
    <link href="http://roy-jung.github.io/201111-concise-redux-saga/"/>
    <id>http://roy-jung.github.io/201111-concise-redux-saga/</id>
    <published>2020-11-11T01:26:03.000Z</published>
    <updated>2020-11-11T17:26:52.553Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post-cover4.jpg"/><p>React.js에 redux 및 redux-saga를 얹어 사용하면서 느낀 피로감을 최소화하고자 노력한 결과가 제 나름으론 만족스럽게 나와 공유하고자 합니다.</p><h2 id="패키지-구조"><a href="#패키지-구조" class="headerlink" title="패키지 구조"></a>패키지 구조</h2><p>redux-saga를 보다 쉽게 사용하고자 하는 데에 포커스를 맞춘 연습용 프로젝트로, 디펜던시는 다음과 같습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;react&quot;</span>: <span class="string">&quot;^17.0.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;react-dom&quot;</span>: <span class="string">&quot;^17.0.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;redux&quot;</span>: <span class="string">&quot;^4.0.5&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;react-redux&quot;</span>: <span class="string">&quot;^7.2.2&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;redux-saga&quot;</span>: <span class="string">&quot;^1.1.3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;immer&quot;</span>: <span class="string">&quot;^7.0.14&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;axios&quot;</span>: <span class="string">&quot;^0.21.0&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-action"><a href="#1-action" class="headerlink" title="1. action"></a>1. action</h2><h3 id="1-비동기-상태관리에-대한-불만-요소"><a href="#1-비동기-상태관리에-대한-불만-요소" class="headerlink" title="1) 비동기 상태관리에 대한 불만 요소"></a>1) 비동기 상태관리에 대한 불만 요소</h3><p>리덕스를 사용하다 보면 액션명을 생성하는 데에 반복이 너무나 많아 불만이었습니다. 무엇보다 비동기처리를 위해서 동일한 액션명에 대해 ‘_REQUEST’, ‘_SUCCESS’, ‘_FAILURE’와 같이 요청과 응답성공, 응답실패의 세가지 케이스를 모두 만들어야 한다는 점이 가장 힘들었습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* actions.js */</span></span><br><span class="line"><span class="keyword">const</span> userActions = &#123;</span><br><span class="line">  LOGIN_REQUEST: <span class="string">&#x27;LOGIN_REQUEST&#x27;</span>,</span><br><span class="line">  LOGIN_SUCCESS: <span class="string">&#x27;LOGIN_SUCCESS&#x27;</span>,</span><br><span class="line">  LOGIN_FAILURE: <span class="string">&#x27;LOGIN_FAILURE&#x27;</span>,</span><br><span class="line">  LOGOUT_REQUEST: <span class="string">&#x27;LOGOUT_REQUEST&#x27;</span>,</span><br><span class="line">  LOGOUT_SUCCESS: <span class="string">&#x27;LOGOUT_SUCCESS&#x27;</span>,</span><br><span class="line">  LOGOUT_FAILURE: <span class="string">&#x27;LOGOUT_FAILURE&#x27;</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reducer/user.js */</span></span><br><span class="line"><span class="keyword">const</span> userReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">switch</span>(<span class="params">action.type</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> userActions.LOGIN_REQUEST: ...</span><br><span class="line">    <span class="keyword">case</span> userActions.LOGIN_SUCCESS: ...</span><br><span class="line">    <span class="keyword">case</span> userActions.LOGIN_FAILURE: ...</span><br><span class="line">    <span class="keyword">case</span> userActions.LOGOUT_REQUEST: ...</span><br><span class="line">    <span class="keyword">case</span> userActions.LOGOUT_SUCCESS: ...</span><br><span class="line">    <span class="keyword">case</span> userActions.LOGOUT_FAILURE: ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-status-프로퍼티로-관리"><a href="#2-status-프로퍼티로-관리" class="headerlink" title="2) status 프로퍼티로 관리"></a>2) status 프로퍼티로 관리</h3><p>이에 가장 먼저 생각한 방법은 action은 하나만 둔 상태에서 ‘status’ 프로퍼티로 비동기 처리의 상태를 관리하는 것이었습니다. 그랬더니 이번에는 reducer가 골치입니다. 최상단에서는 간결해졌지만 그래봤자 내부에서는 다시 switch case를 태워야 하나? 좀 아닌 것 같지만, 해보고 나서 생각하자 싶어 일단은 진행합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* actions.js */</span></span><br><span class="line"><span class="keyword">const</span> userActions = &#123;</span><br><span class="line">  LOGIN: <span class="string">&#x27;LOGIN&#x27;</span>,</span><br><span class="line">  LOGOUT: <span class="string">&#x27;LOGOUT&#x27;</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reducer/user.js */</span></span><br><span class="line"><span class="keyword">const</span> userReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">switch</span>(<span class="params">action.type</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> userActions.LOGIN: &#123;</span><br><span class="line">      <span class="keyword">switch</span> (action.data.status) &#123;</span><br><span class="line">        <span class="keyword">case</span> REQUEST: ...</span><br><span class="line">        <span class="keyword">case</span> SUCCESS: ...</span><br><span class="line">        <span class="keyword">case</span> FAILURE: ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> userActions.LOGOUT: &#123;</span><br><span class="line">      <span class="keyword">switch</span> (action.data.status) &#123;</span><br><span class="line">        <span class="keyword">case</span> REQUEST: ...</span><br><span class="line">        <span class="keyword">case</span> SUCCESS: ...</span><br><span class="line">        <span class="keyword">case</span> FAILURE: ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>역시나 이건 아니다 싶네요. 반복되는 REQUEST, SUCCESS, FAILURE에 대한 처리를 보다 효율적으로 할 수 있는 방안이 필요해 보입니다. 고민 끝에 적절한 방안을 찾아내긴 했습니다만 이에 대해서는 reducer 파트에서 자세히 소개하기로 하고, 지금은 일단 action 파트에 집중하겠습니다. 어쩄든 action명의 뒷부분을 과감히 덜어내고 reducer 쪽의 고민도 해결하고 보니, 이번엔 또 전혀 새로운 단점이 눈에 들어왔습니다. redux를 사용할 때 얻는 가장 큰 이점 중 하나는 뭐니뭐니 해도 redux-devtool일텐데요,</p><img src="./1.png" width="360" alt="디버깅이 망했어요!" /><p>action명만 보고는 이게 어떤 동작인지를 유추조차 할 수가 없습니다. 일일이 액션 하나하나를 열어보아야만이 요청인지 성공인지 실패인지를 알 수 있어 몹시 불편합니다. 역시나 아니다 싶네요. 단순반복을 ‘아주 약간’ 피하는 대신 디버깅에서는 치명적인 단점으로 보이기까지 합니다. </p><h3 id="3-suffix-자동-부여"><a href="#3-suffix-자동-부여" class="headerlink" title="3) suffix 자동 부여"></a>3) suffix 자동 부여</h3><p>‘결국은 하나의 동작에 대해 여러개의 액션을 만드는 수밖에 없나’ 하며 풀 죽어 있다가, (<a href="https://pburtchaell.gitbook.io/redux-promise-middleware/guides/custom-suffixes">redux-promise-middleware</a>)에서 힌트를 얻었습니다. 생각해보면 사용자 입장에서 직접 action을 dispatch해야 하는 경우는 오직 ‘REQUEST’할 때 뿐이고, 나머지는 서버의 응답에 따라 <strong>자동으로</strong> 동작하게끔 처리해줘야 하는 것들입니다. 이를 위해서 redux-saga를 사용하는 것이니, 이들에 대해서까지 action 명을 굳이 직접 만들어야 할 이유가 없는 셈이기도 하죠! 자동으로 동작할 액션들은 자동으로 부여하도록 해주면 될 일이었습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* actions.js */</span></span><br><span class="line"><span class="keyword">const</span> userActions = &#123;</span><br><span class="line">  LOGIN: <span class="string">&#x27;LOGIN&#x27;</span>,</span><br><span class="line">  LOGOUT: <span class="string">&#x27;LOGOUT&#x27;</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* saga/user.js */</span></span><br><span class="line"><span class="keyword">import</span> &#123; all, put, takeLatest &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> login = <span class="function"><span class="keyword">function</span>*(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">yield</span> axios.post(<span class="string">&#x27;/user/login&#x27;</span>, action.data)</span><br><span class="line">    <span class="keyword">yield</span> put(&#123;</span><br><span class="line">      type: <span class="string">`LOGIN__success`</span>,</span><br><span class="line">      data: result.data,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">yield</span> put(&#123;</span><br><span class="line">      type: <span class="string">`LOGIN__failure`</span>,</span><br><span class="line">      data: result.data,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">userSaga</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> all([ takeLatest(userActions.LOGIN, login) ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reducer/user.js */</span></span><br><span class="line"><span class="keyword">const</span> userReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">switch</span>(<span class="params">action.type</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> userActions.LOGIN: ...</span><br><span class="line">    <span class="keyword">case</span> userActions.LOGIN__success: ...</span><br><span class="line">    <span class="keyword">case</span> userActions.LOGIN__failure: ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>대충 이런 식으로 하면 처음보다는 그래도 숨통이 트이는 느낌이네요. reducer는 변화가 없긴 하지만, 이 부분은 따로 처리하면 될 일이니까요. 나아가 굳이 action은 별도의 ‘action’ 폴더에 두지 않고 root로 옮겨 actions.js 파일 하나로 관리하도록 하였습니다. store 프로퍼티명에 대응하는 actions 변수 안에 각 액션명들로 구성된 배열들을 만들고, 이들을 한 데 모아 <code>&#123; LOGIN: &#39;LOGIN&#39;, ...&#125;</code>와 같이 하나의 객체로 export 하도록 처리하였습니다. 규모가 커져서 액션이 많을 수밖에 없다면 action 폴더를 만드는 편이 낫겠지만, 지금으로선 이정도로 충분해 보입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* actions.js */</span></span><br><span class="line"><span class="keyword">const</span> userActions = [</span><br><span class="line">  <span class="string">&#x27;LOGIN&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;LOGOUT&#x27;</span>,</span><br><span class="line">  ...</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> postActions = [</span><br><span class="line">  <span class="string">&#x27;ADD_POST&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;REMOVE_POST&#x27;</span>,</span><br><span class="line">  ...</span><br><span class="line">]</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  ...userActions,</span><br><span class="line">  ...postActions</span><br><span class="line">].reduce(<span class="function">(<span class="params">a, c</span>) =&gt;</span> &#123;</span><br><span class="line">  a[c] = c</span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-saga"><a href="#2-saga" class="headerlink" title="2. saga"></a>2. saga</h2><h3 id="1-saga-파일에-대한-불만-요소"><a href="#1-saga-파일에-대한-불만-요소" class="headerlink" title="1) saga 파일에 대한 불만 요소"></a>1) saga 파일에 대한 불만 요소</h3><p>saga 파트에서 가장 불만스러운 부분은, try catch로 감싸는 처리가 매번 반복된다는 점입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* saga/user.js */</span></span><br><span class="line"><span class="keyword">import</span> &#123; all, put, takeLatest &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Actions <span class="keyword">from</span> <span class="string">&#x27;../actions&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> login = <span class="function"><span class="keyword">function</span>*(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">yield</span> axios.post(<span class="string">&#x27;/user/login&#x27;</span>, action.data)</span><br><span class="line">    <span class="keyword">yield</span> put(&#123;</span><br><span class="line">      type: <span class="string">`<span class="subst">$&#123;Actions.LOGIN&#125;</span>__success`</span>,</span><br><span class="line">      data: result.data,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">yield</span> put(&#123;</span><br><span class="line">      type: <span class="string">`<span class="subst">$&#123;Actions.LOGIN&#125;</span>__failure`</span>,</span><br><span class="line">      data: err.response.data,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> logout = <span class="function"><span class="keyword">function</span>*(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">yield</span> axios.post(<span class="string">&#x27;/user/logout&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> put(&#123;</span><br><span class="line">      type: <span class="string">`<span class="subst">$&#123;Actions.LOGOUT&#125;</span>__success`</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">yield</span> put(&#123;</span><br><span class="line">      type: <span class="string">`<span class="subst">$&#123;Actions.LOGOUT&#125;</span>__failure`</span>,</span><br><span class="line">      data: err.response.data,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">userSaga</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> all([</span><br><span class="line">    takeLatest(Actions.LOGIN, login),</span><br><span class="line">    takeLatest(Actions.LOGOUT, logout),</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-taker-함수로-공통요소-처리"><a href="#2-taker-함수로-공통요소-처리" class="headerlink" title="2) taker 함수로 공통요소 처리"></a>2) taker 함수로 공통요소 처리</h3><p>가만 보니 ‘LOGIN’에 대한 대응 액션은 ‘LOGIN__success’, ‘LOGIN__failure’이고, try catch는 모든 경우에 공통으로 이루어집니다. 그렇다면 함수로 좀 더 편리하게 처리할 수 있을 것 같습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* saga/taker.js */</span></span><br><span class="line"><span class="keyword">import</span> &#123; put &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> taker = <span class="function">(<span class="params">actionType, func</span>) =&gt;</span> <span class="function"><span class="keyword">function</span>* (<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">yield</span> func(action)</span><br><span class="line">    <span class="keyword">yield</span> put(&#123;</span><br><span class="line">      type: <span class="string">`<span class="subst">$&#123;actionType&#125;</span>__success`</span>,</span><br><span class="line">      data: result.data</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">yield</span> put(&#123;</span><br><span class="line">      type: <span class="string">`<span class="subst">$&#123;actionType&#125;</span>__failure`</span>,</span><br><span class="line">      data: err.response.data</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> taker</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* saga/user.js */</span></span><br><span class="line"><span class="keyword">import</span> &#123; all, takeLatest &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> taker <span class="keyword">from</span> <span class="string">&#x27;./taker&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Actions <span class="keyword">from</span> <span class="string">&#x27;../actions&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> login = <span class="function"><span class="keyword">function</span>*(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> axios.post(<span class="string">&#x27;/user/login&#x27;</span>, action.data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> logout = <span class="function"><span class="keyword">function</span>*(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> axios.post(<span class="string">&#x27;/user/logout&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">userSaga</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> all([</span><br><span class="line">    takeLatest(Actions.LOGIN, taker(Actions.LOGIN, login)),</span><br><span class="line">    takeLatest(Actions.LOGOUT, taker(Actions.LOGOUT, logout)),</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이것만으로 이미 만족도가 꽤 높아졌습니다. 제너레이터 함수들은 오직 비동기 요청만을 수행하고, 나머지는 모두 taker가 도맡아 처리합니다. 다만 마지막의 userSaga 부분에서 같은 액션이 두 번씩 등장하고, taker를 호출하는 내용이 계속 반복되니 이 것도 줄여볼 수 있을 것 같습니다. 주로 takeLatest가 많이 쓰이므로 디폴트로 설정하고, 그밖의 메소드를 지정할 수 있게 하면서 나아가 throttle 등을 사용하는 경우를 위한 option까지 받도록 해보겠습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* saga/taker.js */</span></span><br><span class="line"><span class="keyword">import</span> &#123; takeLatest, put &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> taker = <span class="function">(<span class="params">actionType, func, takeMethod = takeLatest, takeOption</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> params = [</span><br><span class="line">    actionType,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>* (<span class="params">action</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">yield</span> func(action)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 결과가 없는 경우에도 failure 처리</span></span><br><span class="line">        <span class="keyword">if</span> (!result || !result.data) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;no data&#x27;</span>, actionType)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> put(&#123;</span><br><span class="line">          type: <span class="string">`<span class="subst">$&#123;actionType&#125;</span>__success`</span>,</span><br><span class="line">          data: result.data,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err)</span><br><span class="line">        <span class="keyword">yield</span> put(&#123;</span><br><span class="line">          type: <span class="string">`<span class="subst">$&#123;actionType&#125;</span>__failure`</span>,</span><br><span class="line">          error: err.response.data,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// throttle 등의 옵션값은 맨 앞으로.</span></span><br><span class="line">  <span class="keyword">if</span> (takeOption) params.unshift(takeOption)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> method(...params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> taker</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* saga/user.js */</span></span><br><span class="line"><span class="keyword">import</span> &#123; throttle &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span></span><br><span class="line"><span class="keyword">import</span> taker <span class="keyword">from</span> <span class="string">&#x27;./taker&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Actions <span class="keyword">from</span> <span class="string">&#x27;../actions&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 중략</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> checkConnection = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> axios.get(<span class="string">&#x27;/connection&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">userSaga</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> all([</span><br><span class="line">    taker(Actions.LOGIN, login),</span><br><span class="line">    taker(Actions.LOGOUT, logout),</span><br><span class="line">    taker(Actions.CONNECTED, checkConnection, throttle, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span>),</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* saga/index.js */</span></span><br><span class="line"><span class="keyword">import</span> &#123; all &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span></span><br><span class="line"><span class="keyword">import</span> postSaga <span class="keyword">from</span> <span class="string">&#x27;./post&#x27;</span></span><br><span class="line"><span class="keyword">import</span> userSaga <span class="keyword">from</span> <span class="string">&#x27;./user&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">rootSaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> all([postSaga, userSaga])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-보다-더-간결하게"><a href="#3-보다-더-간결하게" class="headerlink" title="3) 보다 더 간결하게!"></a>3) 보다 더 간결하게!</h3><p>상당히 간결해 졌습니다. 그런데 기왕 하는 김에 각각의 saga 파일들에서 공통으로 처리하는 마지막 요소를 조금 더 다듬을 수 있을 것 같습니다. 반복되는 내용들은 모조리 saga/index.js에서 처리하도록 하고, 개별 saga 파일들에서는 작업량을 최소화 하도록 해보죠.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* saga/user.js */</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Actions <span class="keyword">from</span> <span class="string">&#x27;../actions&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> login = <span class="function"><span class="keyword">function</span>*(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> axios.post(<span class="string">&#x27;/user/login&#x27;</span>, action.data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> logout = <span class="function"><span class="keyword">function</span>*(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> axios.post(<span class="string">&#x27;/user/logout&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> checkConnection = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> axios.get(<span class="string">&#x27;/connection&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  [Actions.LOGIN, login],</span><br><span class="line">  [Actions.LOGOUT, logout],</span><br><span class="line">  [Actions.CONNECTED, checkConnection, throttle, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* saga/index.js */</span></span><br><span class="line"><span class="keyword">import</span> &#123; all &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span></span><br><span class="line"><span class="keyword">import</span> postSaga <span class="keyword">from</span> <span class="string">&#x27;./post&#x27;</span></span><br><span class="line"><span class="keyword">import</span> userSaga <span class="keyword">from</span> <span class="string">&#x27;./user&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> taker = <span class="function">(<span class="params">...</span>) =&gt;</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">const</span> takesAll = <span class="function"><span class="params">sagaItems</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> all(sagaItems.map(<span class="function"><span class="params">saga</span> =&gt;</span> taker(...saga)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">rootSaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> all([</span><br><span class="line">    takesAll(postSaga),</span><br><span class="line">    takesAll(userSaga),</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 saga 폴더 각 파일 내에서는 비동기 ‘요청’에 대한 것만 신경쓰면 됩니다. 각 파일의 마지막에 watch할 내용들을 배열로 묶어서 saga/index.js로 전달하기만 하면 됩니다. index에서는 받은 배열들을 바탕으로 이쁘게 말아서 rootSaga로 통합합니다.</p><h2 id="3-reducer"><a href="#3-reducer" class="headerlink" title="3. reducer"></a>3. reducer</h2><h3 id="1-비동기-상태-관리에-대한-시행착오"><a href="#1-비동기-상태-관리에-대한-시행착오" class="headerlink" title="1) 비동기 상태 관리에 대한 시행착오"></a>1) 비동기 상태 관리에 대한 시행착오</h3><p>reducer는 사람마다 각양 각색으로 관리하는 것 같지만, 프론트엔드 개발자의 입장에서는 상태변화를 감지하여 뷰에 노출할지 여부를 판단하는 것이 생각보다 많이 중요하다보니, 비동기 처리시마다 해당 정보를 reducer에 남기는 방법을 고민해 왔습니다. 그 중 제가 아는 한에서 대중적으로 많이 쓰이는 방식은 다음과 같았습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reducer/user.js */</span></span><br><span class="line"><span class="keyword">import</span> &#123; produce &#125; <span class="keyword">from</span> <span class="string">&#x27;immer&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Actions <span class="keyword">from</span> <span class="string">&#x27;../actions&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  loginLoading: <span class="literal">false</span>,</span><br><span class="line">  loginDone: <span class="literal">false</span>,</span><br><span class="line">  loginError: <span class="literal">false</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> userReducer = produce(<span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> Actions.LOGIN:</span><br><span class="line">      draft.loginLoading = <span class="literal">true</span></span><br><span class="line">      draft.loginDone = <span class="literal">false</span></span><br><span class="line">      draft.loginError = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Actions.LOGIN__success: &#123;</span><br><span class="line">      <span class="keyword">const</span> loggedId = action.data.id</span><br><span class="line">      draft.loggedId = loggedId</span><br><span class="line">      draft[loggedId] = action.data</span><br><span class="line">      draft.loginLoading = <span class="literal">false</span></span><br><span class="line">      draft.loginDone = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Actions.LOGIN__failure:</span><br><span class="line">      draft.loginLoading = <span class="literal">false</span></span><br><span class="line">      draft.loginDone = <span class="literal">false</span></span><br><span class="line">      draft.loginError = action.error</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하나의 액션에 대해 오직 뷰에서의 처리를 위해 3개씩의 상태를 들고 있어야 한다는 점이 매우 몹시 마음에 들지 않습니다. 그래서 예전부터 다양한 방법을 시도해 보았는데, 결국에는 다시 여기로 돌아오게 되더군요. 다음 코드는 제가 몇 년 전에 시도했다가 크게 실패헀던 방안입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LOADING = <span class="string">&#x27;LOADING&#x27;</span></span><br><span class="line"><span class="keyword">const</span> DONE = <span class="string">&#x27;DONE&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ERROR = <span class="string">&#x27;ERROR&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  actionTarget: <span class="literal">null</span>,</span><br><span class="line">  actionStatus: <span class="literal">null</span>,</span><br><span class="line">  loggedId: <span class="literal">null</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> userReducer = produce(<span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> Actions.LOGIN:</span><br><span class="line">      draft.actionTarget = <span class="string">&#x27;login&#x27;</span></span><br><span class="line">      draft.actionStatus = LOADING</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Actions.LOGIN__success:</span><br><span class="line">      draft.actionTarget = <span class="string">&#x27;login&#x27;</span></span><br><span class="line">      draft.actionStatus = DONE</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Actions.LOGIN__failure:</span><br><span class="line">      draft.actionTarget = <span class="string">&#x27;login&#x27;</span></span><br><span class="line">      draft.actionStatus = action.error</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Actions.LOGOUT:</span><br><span class="line">      draft.actionTarget = <span class="string">&#x27;logout&#x27;</span></span><br><span class="line">      draft.actionStatus = LOADING</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Actions.LOGOUT__success:</span><br><span class="line">      draft.actionTarget = <span class="string">&#x27;logout&#x27;</span></span><br><span class="line">      draft.actionStatus = DONE</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Actions.LOGOUT__failure:</span><br><span class="line">      draft.actionTarget = <span class="string">&#x27;logout&#x27;</span></span><br><span class="line">      draft.actionStatus = action.error</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Actions.NICKNAME_CHANGE:</span><br><span class="line">      draft.actionTarget = <span class="string">&#x27;nicknameChange&#x27;</span></span><br><span class="line">      draft.actionStatus = LOADING</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Actions.NICKNAME_CHANGE__success:</span><br><span class="line">      draft.actionTarget = <span class="string">&#x27;nicknameChange&#x27;</span></span><br><span class="line">      draft.actionStatus = DONE</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Actions.NICKNAME_CHANGE__failure:</span><br><span class="line">      draft.actionTarget = <span class="string">&#x27;nicknameChange&#x27;</span></span><br><span class="line">      draft.actionStatus = action.error</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 방법은 그때 당시의 제 생각에는 효율적이어서 좋을 줄 알았지만, 실은 사용자가 화면에서 여러가지 동작을 하다 보면 금방 꼬여버리기 십상이더군요.</p><table><thead><tr><th align="left">type</th><th align="left">actionTarget</th><th align="left">result</th><th align="left">actionStatus</th></tr></thead><tbody><tr><td align="left">1 REQUEST</td><td align="left">‘login’</td><td align="left"></td><td align="left">LOADING</td></tr><tr><td align="left">2 RESPONSE</td><td align="left">‘login’</td><td align="left">SUCCESS</td><td align="left">DONE</td></tr><tr><td align="left">3 REQUEST</td><td align="left">‘nicknameChange’</td><td align="left"></td><td align="left">LOADING</td></tr><tr><td align="left">4 REQUEST</td><td align="left">‘logout’</td><td align="left"></td><td align="left">LOADING</td></tr><tr><td align="left">5 RESPONSE</td><td align="left">‘nicknameChange’</td><td align="left">FAILURE</td><td align="left">ERROR</td></tr><tr><td align="left">6 RESPONSE</td><td align="left">‘logout’</td><td align="left">SUCCESS</td><td align="left">DONE</td></tr></tbody></table><p>3번과 4번 요청에 대하여 서버에서 어떤 이유에서인지 4번을 먼저 처리한 경우, 그럼에도 응답은 순서대로 도착한 경우의 시나리오입니다. 근소한 차이로 도달한 5번 6번에 의해 화면상에는 ‘닉네임 변경 실패’를 노출할 타이밍을 놓쳐버리거나, 혹은 5번에 대한 처리는 정상적으로 이루어졌음에도 불구하고 6번에 대한 정책인 화면 전환(Router.replace)으로 인해 노티를 육안으로 확인하지 못하는 경우가 발생합니다. 이런 경우 Redux devtool의 히스토리를 뒤져보면 현상은 파악할 수 있긴 하지만, devtool을 비활성화 시킨 배포환경에서는 유추하기가 쉽지 않습니다.</p><p>다른 문제도 있습니다. actionTarget, asyncStatus라는 두 상태의 변화를 구독해야 하는 컴포넌트가 계속해서 늘어난다는 점입니다. 각 컴포넌트에서 useEffect를 이용하여 두 상태를 감시하고 asyncTarget이 목적하는 문자열과 일치하는 경우에 대해 부가적인 작업을 수행할텐데, 이 두 값은 사용자의 사소한 동작들 하나하나에 수시로 변경될 것입니다. 성능상에 부정적인 영향을 줄 가능성을 배제할 수 없겠습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Component1 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (actionTarget === <span class="string">&#x27;login&#x27;</span>) ...</span><br><span class="line">  &#125;, [actionTarget, actionStatus])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Component2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (actionTarget === <span class="string">&#x27;nicknameChange&#x27;</span>) ...</span><br><span class="line">  &#125;, [actionTarget, actionStatus])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Component3 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (actionTarget === <span class="string">&#x27;logout&#x27;</span>) ...</span><br><span class="line">  &#125;, [actionTarget, actionStatus])</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>반면 redux store가 비대해지는 자체로는 컴포넌트의 성능에 큰 영향을 줄 소지가 없습니다. 아무리 거대한 객체구조가 이루어져 있더라도 컴포넌트에 해당 값이 전달되지 않는 이상은 렌더링에 부하를 줄 일 자체가 없습니다. 그러니까 관건은 store의 각 상태값들이 특정 컴포넌트에서 <strong>실제로 필요한 경우에만</strong> 변경이 이뤄지도록 하는 것입니다. </p><h3 id="2-상태값-줄이기"><a href="#2-상태값-줄이기" class="headerlink" title="2) 상태값 줄이기"></a>2) 상태값 줄이기</h3><p>다시 원래의 코드로 돌아옵시다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  loginLoading: <span class="literal">false</span>,</span><br><span class="line">  loginDone: <span class="literal">false</span>,</span><br><span class="line">  loginError: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> userReducer = produce(<span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> Actions.LOGIN:</span><br><span class="line">      draft.loginLoading = <span class="literal">true</span></span><br><span class="line">      draft.loginDone = <span class="literal">false</span></span><br><span class="line">      draft.loginError = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Actions.LOGIN__success:</span><br><span class="line">      draft.loginLoading = <span class="literal">false</span></span><br><span class="line">      draft.loginDone = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Actions.LOGIN__failure:</span><br><span class="line">      draft.loginLoading = <span class="literal">false</span></span><br><span class="line">      draft.loginDone = <span class="literal">false</span></span><br><span class="line">      draft.loginError = action.error</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>가만 보니까 ‘login’과 관련한 동작은 무조건 <code>LOADING / DONE / ERROR</code>의 셋 중 하나로 귀결됩니다. 어떤 하나의 상태가 truthy하면 나머지 둘은 무조건 falsy합니다. <em><code>null</code>은 사용자가 login 관련 동작을 한 번이라도 수행하면 영원히 볼 수 없는 값이므로 무의미한 것 같습니다.</em></p><table><thead><tr><th align="center">action</th><th align="center">loading</th><th align="center">done</th><th align="center">error</th></tr></thead><tbody><tr><td align="center">LOGIN REQUEST</td><td align="center">true</td><td align="center">false</td><td align="center">false</td></tr><tr><td align="center">LOGIN SUCCESS</td><td align="center">false</td><td align="center">true</td><td align="center">false</td></tr><tr><td align="center">LOGIN FAILURE</td><td align="center">false</td><td align="center">false</td><td align="center">errorMsg(truthy)</td></tr></tbody></table><p>그렇다면 다음과 같이 상태를 하나로 압축해도 되겠네요.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  loginStatus: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> userReducer = produce(<span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> Actions.LOGIN:</span><br><span class="line">      draft.loginStatus = LOADING</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Actions.LOGIN__success:</span><br><span class="line">      draft.loginStatus = DONE</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Actions.LOGIN__failure:</span><br><span class="line">      draft.loginStatus = action.error</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Component = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!loginStatus) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">switch</span> (loginStatus) &#123;</span><br><span class="line">      <span class="keyword">case</span> DONE: <span class="keyword">return</span> setDone()</span><br><span class="line">      <span class="keyword">case</span> LOADING: <span class="keyword">return</span> setLoading()</span><br><span class="line">      <span class="keyword">default</span>: <span class="keyword">return</span> setError(loginStatus)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [loginStatus])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LOADING과 DONE은 상수를 활용하고, ERROR의 경우에는 에러메시지 자체를 상태값에 저장합니다. 이제는 store가 ‘그렇게까지’ 비대해지지는 않으면서도 로그인 상태를 잘 유지할 수 있겠습니다. 하나의 액션에 대해 하나의 상태값만을 지니므로 견딜만 한 수준이네요.</p><h3 id="3-공통요소와-추가요소-분리"><a href="#3-공통요소와-추가요소-분리" class="headerlink" title="3) 공통요소와 추가요소 분리"></a>3) 공통요소와 추가요소 분리</h3><p>그렇지만 여전히 불만은 있습니다. 리덕스를 쓰면 어디서나 반복이 많지만, 리듀서는 특히나 심합니다. 위와 같은 상태 관리를 매 액션별로 하나하나 전부 ‘똑같이’ 처리해줘야 하는데, 이걸 어떻게든 하고 싶네요. 우선 리듀서 전체를 아우르는 switch case를 객체 형태로 바꿔보면 방법이 보일지도 모르겠습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  loginStatus: <span class="literal">null</span>,</span><br><span class="line">  logoutStatus: <span class="literal">null</span>,</span><br><span class="line">  nicknameStatus: <span class="literal">null</span>,</span><br><span class="line">  loggedId: <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> userReducerMap = &#123;</span><br><span class="line">  [Actions.LOGIN]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    draft.loginStatus = LOADING</span><br><span class="line">  &#125;,</span><br><span class="line">  [Actions.LOGIN__success]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> loggedId = action.data.id</span><br><span class="line">    draft.loggedId = loggedId</span><br><span class="line">    draft[loggedId] = action.data</span><br><span class="line">    draft.loginStatus = DONE</span><br><span class="line">  &#125;,</span><br><span class="line">  [Actions.LOGIN__failure]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    draft.loginStatus = action.error</span><br><span class="line">    draft.loggedId = <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [Actions.LOGOUT]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    draft.logoutStatus = LOADING</span><br><span class="line">  &#125;,</span><br><span class="line">  [Actions.LOGOUT__success]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    draft.logoutStatus = DONE</span><br><span class="line">  &#125;,</span><br><span class="line">  [Actions.LOGOUT__failure]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    draft.logoutStatus = action.error</span><br><span class="line">  &#125;,</span><br><span class="line">  [Actions.NICKNAME_CHANGE]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    draft.nicknameStatus = LOADING</span><br><span class="line">  &#125;,</span><br><span class="line">  [Actions.NICKNAME_CHANGE__success]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> loggedId = action.data.id</span><br><span class="line">    <span class="keyword">if</span> (loggedId &amp;&amp; draft[loggedId]) &#123;</span><br><span class="line">      draft[loggedId].nickname = action.data.nickname</span><br><span class="line">    &#125;</span><br><span class="line">    draft.nicknameStatus = DONE</span><br><span class="line">  &#125;,</span><br><span class="line">  [Actions.NICKNAME_CHANGE__failure]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    draft.nicknameStatus = action.error</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> userReducer = produce(<span class="function">(<span class="params">draft = initialState, action</span>) =&gt;</span></span><br><span class="line">  userReducerMap[action.type] </span><br><span class="line">    ? userReducerMap[action.type](draft, action)</span><br><span class="line">    : state</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>모든 액션에 대해 다음이 공통됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  [SOME_ACTION]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    draft.someStatus = LOADING</span><br><span class="line">  &#125;,</span><br><span class="line">  [SOME_ACTION__success]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    draft.someStatus = DONE</span><br><span class="line">  &#125;,</span><br><span class="line">  [SOME_ACTION__failure]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    draft.someStatus = action.error</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>공통요소를 제외하면 다음만 남습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userReducerMap = &#123;</span><br><span class="line">  [Actions.LOGIN__success]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> loggedId = action.data.id</span><br><span class="line">    draft.loggedId = loggedId</span><br><span class="line">    draft[loggedId] = action.data</span><br><span class="line">  &#125;,</span><br><span class="line">  [Actions.LOGIN__failure]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    draft.loggedId = <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [Actions.NICKNAME_CHANGE__success]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> loggedId = action.data.id</span><br><span class="line">    <span class="keyword">if</span> (loggedId &amp;&amp; draft[loggedId]) &#123;</span><br><span class="line">      draft[loggedId].nickname = action.data.nickname</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-구조-변경-함수화"><a href="#4-구조-변경-함수화" class="headerlink" title="4) 구조 변경, 함수화"></a>4) 구조 변경, 함수화</h3><p>경우에 따라 어떤 액션은 success시에만, 어떤 액션은 failure에도 추가 처리가 필요합니다. 그렇다면 공통요소는 별도로 처리하기로 하고, 추가 처리가 필요한 부분에 대해서는 다음과 같은 구조로 바꾸면 좀 더 간결하게 만들 수 있을 것 같습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> commonReducerMap = &#123;</span><br><span class="line">  request: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    draft.actionStatus = LOADING</span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    draft.actionStatus = DONE</span><br><span class="line">  &#125;,</span><br><span class="line">  failure: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">    draft.actionStatus = action.error</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userReducerMap = &#123;</span><br><span class="line">  [Actions.LOGIN]: &#123;</span><br><span class="line">    success: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> loggedId = action.data.id</span><br><span class="line">      draft.loggedId = loggedId</span><br><span class="line">      draft[loggedId] = action.data</span><br><span class="line">    &#125;,</span><br><span class="line">    failure: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">      draft.loggedId = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  [Actions.LOGOUT]: &#123;&#125;,</span><br><span class="line">  [Actions.NICKNAME_CHANGE]: &#123;</span><br><span class="line">    success: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> loggedId = action.data.id</span><br><span class="line">      <span class="keyword">if</span> (loggedId &amp;&amp; draft[loggedId]) &#123;</span><br><span class="line">        draft[loggedId].nickname = action.data.nickname</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>구상은 이런 겁니다. 액션명이 기본적으로 ‘ACTION’ / ‘ACTION__success’ / ‘ACTION__failure’ 세가지로 이루어져 있으니, 이걸 하나로 뭉쳐서 처리하는 겁니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reduceFunc = <span class="function">(<span class="params">draft = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [actionType, status = <span class="string">&#x27;request&#x27;</span>] = action.type.split(<span class="string">&#x27;__&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> source = reducerMap[actionType]</span><br><span class="line">  source[status] &amp;&amp; source[status](draft, action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 바꾸고 보니 공통요소인 ‘someStatus’는 앞서 추출한 actionType을 활용하는 방식으로 바꾸면 간단하게 처리할 수 있겠네요. actionStatus 라는 객체 안에 각각의 actionType의 상태를 할당하는 방식으로 구현해 봅니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reducer/user.js */</span></span><br><span class="line"><span class="keyword">import</span> &#123; produce &#125; <span class="keyword">from</span> <span class="string">&#x27;immer&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> REQUEST = <span class="string">&#x27;request&#x27;</span></span><br><span class="line"><span class="keyword">const</span> SUCCESS = <span class="string">&#x27;success&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FAILURE = <span class="string">&#x27;failure&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  actionStatus: &#123;&#125;,</span><br><span class="line">  loggedId: <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> userReducerMap = &#123;</span><br><span class="line">  [Actions.LOGIN]: &#123;</span><br><span class="line">    [SUCCESS]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> loggedId = action.data.id</span><br><span class="line">      draft.loggedId = loggedId</span><br><span class="line">      draft[loggedId] = action.data</span><br><span class="line">    &#125;,</span><br><span class="line">    [FAILURE]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">      draft.loggedId = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  [Actions.LOGOUT]: &#123;&#125;, <span class="comment">// 추가 처리요소가 없는 경우 빈 객체로.</span></span><br><span class="line">  [Actions.NICKNAME_CHANGE]: &#123;</span><br><span class="line">    [SUCCESS]: <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> loggedId = action.data.id</span><br><span class="line">      <span class="keyword">if</span> (loggedId &amp;&amp; draft[loggedId]) &#123;</span><br><span class="line">        draft[loggedId].nickname = action.data.nickname</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reduceFunc = <span class="function">(<span class="params">draft = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; error, type &#125; = action</span><br><span class="line">  <span class="keyword">const</span> [actionType, status = REQUEST] = type.split(<span class="string">&#x27;__&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> source = userReducerMap[actionType]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 존재하지 않는 액션 처리</span></span><br><span class="line">  <span class="keyword">if</span> (!source) <span class="keyword">return</span> draft</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 공통요소(status) 처리</span></span><br><span class="line">  draft.actionStatus[actionType] = status === FAILURE ? error : status</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 추가요소 처리</span></span><br><span class="line">  source[status] &amp;&amp; source[status](draft, action)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userReducer = produce(reduceFunc);</span><br></pre></td></tr></table></figure><p>reducerFunc를 고차함수로 변환하여 userReducerMap 및 initialState의 종속성을 제거해 봅시다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reducer/reduceFunc.js */</span></span><br><span class="line"><span class="keyword">const</span> reduceFunc = <span class="function">(<span class="params">reducerMap, initialState</span>) =&gt;</span> </span><br><span class="line">  (draft = initialState, action) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; error, type &#125; = action</span><br><span class="line">    <span class="keyword">const</span> [actionType, status = REQUEST] = type.split(<span class="string">&#x27;__&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> source = reducerMap[actionType]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!source) <span class="keyword">return</span> draft</span><br><span class="line">    draft.actionStatus[actionType] = status === FAILURE ? error : status</span><br><span class="line">    source[status] &amp;&amp; source[status](draft, action)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reduceFunc</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reducer/user.js */</span></span><br><span class="line"><span class="keyword">import</span> &#123; produce &#125; <span class="keyword">from</span> <span class="string">&#x27;immer&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reduceFunc <span class="keyword">from</span> <span class="string">&#x27;./reduceFunc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; ... &#125;</span><br><span class="line"><span class="keyword">const</span> userReducerMap = &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userReducer = produce(reduceFunc(userReducerMap, initialState));</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> userReducer</span><br></pre></td></tr></table></figure><h3 id="5-동기-액션에-대한-처리-보완"><a href="#5-동기-액션에-대한-처리-보완" class="headerlink" title="5) 동기 액션에 대한 처리 보완"></a>5) 동기 액션에 대한 처리 보완</h3><p>이제 REQUEST, SUCCESS, FAILURE로 구성된 비동기 액션들에 대한 처리는 완벽해 보입니다. 그러나 이대로는 일회성에 그치는 동기 액션은 제대로 처리하지 못합니다. 이 부분을 보완해 보겠습니다. 동기 액션은 하나만 존재하므로 객체가 아닌 ‘함수’일 것입니다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reducer/reduceFunc.js */</span></span><br><span class="line"><span class="keyword">const</span> reduceFunc = <span class="function">(<span class="params">reducerMap, initialState</span>) =&gt;</span> </span><br><span class="line">  (draft = initialState, action) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; error, type &#125; = action</span><br><span class="line">    <span class="keyword">const</span> [actionType, status = REQUEST] = type.split(<span class="string">&#x27;__&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> source = reducerMap[actionType]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 존재하지 않는 액션 처리</span></span><br><span class="line">    <span class="keyword">if</span> (!source) <span class="keyword">return</span> draft</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 동기 처리</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> source === <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span> source(draft, action)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 비동기 처리</span></span><br><span class="line">    draft.actionStatus[actionType] = status === FAILURE ? error : status</span><br><span class="line">    source[status] &amp;&amp; source[status](draft, action)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reducer/post.js */</span></span><br><span class="line"><span class="keyword">import</span> &#123; produce &#125; <span class="keyword">from</span> <span class="string">&#x27;immer&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reduceFunc <span class="keyword">from</span> <span class="string">&#x27;./reduceFunc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  images: [],</span><br><span class="line">  list: [],</span><br><span class="line">  actionStatus: &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> postReducerMap = &#123;</span><br><span class="line">  <span class="comment">// 동기 액션: 함수로 구성</span></span><br><span class="line">  [Actions.REMOVE_IMAGE]: <span class="function">(<span class="params">draft, &#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    draft.images = draft.images.filter(<span class="function">(<span class="params">v, i</span>) =&gt;</span> i !== data)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 비동기 액션: 객체로 구성</span></span><br><span class="line">  [Actions.LOAD_POSTS]: &#123;</span><br><span class="line">    [SUCCESS]: <span class="function">(<span class="params">draft, &#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      draft.list = data</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  [Actions.ADD_POST]: &#123;</span><br><span class="line">    [SUCCESS]: <span class="function">(<span class="params">draft, &#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      draft.list.unshift(data)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> postReducer = produce(reduceFunc(postReducerMap, initialState))</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> postReducer</span><br></pre></td></tr></table></figure><h3 id="6-보다-더-간결하게"><a href="#6-보다-더-간결하게" class="headerlink" title="6) 보다 더 간결하게!"></a>6) 보다 더 간결하게!</h3><p>각 reducer 파일에서 매 번 produce, reduceFunc를 import에서 쓰기보다는, 각 파일에서는 initialState와 reducerMap을 export하고, 이들을 combine하는 <code>reducer/index.js</code>에서 한 번에 처리하는 편이 더 나을 것 같네요. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reducer/user.js */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  loggedId: <span class="literal">null</span>,</span><br><span class="line">  actionStatus: &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  [Actions.LOGIN]: &#123;</span><br><span class="line">    [SUCCESS]: <span class="function">(<span class="params">draft, &#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      draft.loggedId = data.id</span><br><span class="line">      draft[data.id] = data</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reducer/post.js */</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  images: [],</span><br><span class="line">  list: [],</span><br><span class="line">  actionStatus: &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> postReducerMap = &#123;</span><br><span class="line">  [Actions.REMOVE_IMAGE]: <span class="function">(<span class="params">draft, &#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    draft.images = draft.images.filter(<span class="function">(<span class="params">v, i</span>) =&gt;</span> i !== data)</span><br><span class="line">  &#125;,</span><br><span class="line">  [Actions.LOAD_POSTS]: &#123;</span><br><span class="line">    [SUCCESS]: <span class="function">(<span class="params">draft, &#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      draft.list = data</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기왕 reduceFunc를 index.js로 옮기는 김에 produce도 함수 내부에서 호출하면 더 간결할 것 같습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reducer/index.js */</span></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; produce &#125; <span class="keyword">from</span> <span class="string">&#x27;immer&#x27;</span></span><br><span class="line"><span class="keyword">import</span> userReducerMap, &#123; initialState <span class="keyword">as</span> userInitialState &#125; <span class="keyword">from</span> <span class="string">&#x27;./user&#x27;</span></span><br><span class="line"><span class="keyword">import</span> postReducerMap, &#123; initialState <span class="keyword">as</span> postInitialState &#125; <span class="keyword">from</span> <span class="string">&#x27;./post&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reduceFunc = <span class="function">(<span class="params">reducerMap, initialState</span>) =&gt;</span> </span><br><span class="line">  produce(<span class="function">(<span class="params">draft = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; error, type &#125; = action</span><br><span class="line">    <span class="keyword">const</span> [actionType, status = REQUEST] = type.split(<span class="string">&#x27;__&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> source = reducerMap[actionType]</span><br><span class="line">    <span class="keyword">if</span> (!source) <span class="keyword">return</span> draft</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> source === <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span> source(draft, action)</span><br><span class="line">    draft.actionStatus[actionType] = status === FAILURE ? error : status</span><br><span class="line">    source[status] &amp;&amp; source[status](draft, action)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">  user: reduceFunc(userReducerMap, userInitialState),</span><br><span class="line">  post: reduceFunc(postReducerMap, postInitialState),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> rootReducer</span><br></pre></td></tr></table></figure><h2 id="4-useRedux-hook"><a href="#4-useRedux-hook" class="headerlink" title="4. useRedux hook"></a>4. useRedux hook</h2><p>컴포넌트 쪽은 간단하게 소개해 보겠습니다. 우선적으로 react만으로 작성한 컴포넌트에서 redux store로의 접근을 보다 편리하게 하고자 useRedux 훅을 제작했습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useRedux = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = useDispatch()</span><br><span class="line">  <span class="keyword">const</span> select = <span class="function">(<span class="params">...keys</span>) =&gt;</span> </span><br><span class="line">    useSelector(<span class="function"><span class="params">state</span> =&gt;</span> keys.reduce(<span class="function">(<span class="params">a, k</span>) =&gt;</span> a[k] || a, state))</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">type, data</span>) =&gt;</span> dispatcher(&#123; type, data &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    select,</span><br><span class="line">    dispatch,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useRedux</span><br></pre></td></tr></table></figure><p>select는 파라미터로 여러개의 문자열을 넘기면, 이로부터 redux store의 해당 키값에 해당하는 프로퍼티를 반환합니다. 다만 문자열에 해당하는 프로퍼티가 없는 경우에는 그대로 이어서 상위 프로퍼티로부터 다음 키를 조회하게 되므로, 예상과 다른 depth에 속한 프로퍼티가 반환되거나, 혹은 실패하기 이전 마지막 프로퍼티가 반환될 가능성이 있습니다. 이 부분만 주의하면 그 외의 문제점은 없는 것 같습니다. <strike>오타는 논외로 하고요</strike> 사용법은 다음과 같습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useRedux <span class="keyword">from</span> <span class="string">&#x27;/hooks/useRedux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Actions <span class="keyword">from</span> <span class="string">&#x27;/actions&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ChangeNickname = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; select, dispatch &#125; = useRedux()</span><br><span class="line">  <span class="keyword">const</span> &#123; loggedId &#125; = select(<span class="string">&#x27;user&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> &#123; nickname &#125; = select(<span class="string">&#x27;user&#x27;</span>, loggedId)</span><br><span class="line">  <span class="keyword">const</span> handleSubmit = <span class="function"><span class="params">e</span> =&gt;</span> dispatch(Actions.CHANGE_NICKNAME, e.target.value)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> defaultValue=&#123;nickname&#125; onSubmit=&#123;handleSubmit&#125; /&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Comment</span><br></pre></td></tr></table></figure><h2 id="5-최종-코드"><a href="#5-최종-코드" class="headerlink" title="5. 최종 코드"></a>5. 최종 코드</h2><p>마무리로 전체 구조를 정리해 보겠습니다.</p><h3 id="actions-js"><a href="#actions-js" class="headerlink" title="actions.js"></a>actions.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userActions = [</span><br><span class="line">  <span class="string">&#x27;LOGIN&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;LOGOUT&#x27;</span>,</span><br><span class="line">  <span class="comment">// 생략</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> postActions = [</span><br><span class="line">  <span class="comment">// 생략</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  ...userActions,</span><br><span class="line">  ...postActions</span><br><span class="line">].reduce(<span class="function">(<span class="params">a, c</span>) =&gt;</span> &#123;</span><br><span class="line">  a[c] = c</span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="saga-user-js"><a href="#saga-user-js" class="headerlink" title="saga/user.js"></a>saga/user.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Actions <span class="keyword">from</span> <span class="string">&#x27;../actions&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> login = <span class="function"><span class="keyword">function</span>*(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> axios.post(<span class="string">&#x27;/user/login&#x27;</span>, action.data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> checkConnection = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> axios.get(<span class="string">&#x27;/connection&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 생략</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  [Actions.LOGIN, login],</span><br><span class="line">  <span class="comment">// 생략</span></span><br><span class="line">  [Actions.CONNECTED, checkConnection, throttle, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="saga-index-js"><a href="#saga-index-js" class="headerlink" title="saga/index.js"></a>saga/index.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; all &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span></span><br><span class="line"><span class="keyword">import</span> postSaga <span class="keyword">from</span> <span class="string">&#x27;./post&#x27;</span></span><br><span class="line"><span class="keyword">import</span> userSaga <span class="keyword">from</span> <span class="string">&#x27;./user&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> taker = <span class="function">(<span class="params">actionType, func, takeMethod = takeLatest, takeOption</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> params = [</span><br><span class="line">    actionType,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>* (<span class="params">action</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">yield</span> func(action)</span><br><span class="line">        <span class="keyword">if</span> (!result || !result.data) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;no data&#x27;</span>, actionType)</span><br><span class="line">        <span class="keyword">yield</span> put(&#123;</span><br><span class="line">          type: <span class="string">`<span class="subst">$&#123;actionType&#125;</span>__success`</span>,</span><br><span class="line">          data: result.data,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err)</span><br><span class="line">        <span class="keyword">yield</span> put(&#123;</span><br><span class="line">          type: <span class="string">`<span class="subst">$&#123;actionType&#125;</span>__failure`</span>,</span><br><span class="line">          error: err.response.data,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">  <span class="keyword">if</span> (takeOption) params.unshift(takeOption)</span><br><span class="line">  <span class="keyword">return</span> method(...params)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> takesAll = <span class="function"><span class="params">sagaItems</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> all(sagaItems.map(<span class="function"><span class="params">saga</span> =&gt;</span> taker(...saga)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">rootSaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> all([</span><br><span class="line">    takesAll(postSaga),</span><br><span class="line">    takesAll(userSaga),</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reducer-user-js"><a href="#reducer-user-js" class="headerlink" title="reducer/user.js"></a>reducer/user.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  loggedId: <span class="literal">null</span>,</span><br><span class="line">  actionStatus: &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  [Actions.LOGIN]: &#123;</span><br><span class="line">    [SUCCESS]: <span class="function">(<span class="params">draft, &#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      draft.loggedId = data.id</span><br><span class="line">      draft[data.id] = data</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reducer-index-js"><a href="#reducer-index-js" class="headerlink" title="reducer/index.js"></a>reducer/index.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; produce &#125; <span class="keyword">from</span> <span class="string">&#x27;immer&#x27;</span></span><br><span class="line"><span class="keyword">import</span> userReducerMap, &#123; initialState <span class="keyword">as</span> userInitialState &#125; <span class="keyword">from</span> <span class="string">&#x27;./user&#x27;</span></span><br><span class="line"><span class="keyword">import</span> postReducerMap, &#123; initialState <span class="keyword">as</span> postInitialState &#125; <span class="keyword">from</span> <span class="string">&#x27;./post&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reduceFunc = <span class="function">(<span class="params">reducerMap, initialState</span>) =&gt;</span> </span><br><span class="line">  produce(<span class="function">(<span class="params">draft = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; error, type &#125; = action</span><br><span class="line">    <span class="keyword">const</span> [actionType, status = REQUEST] = type.split(<span class="string">&#x27;__&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> source = reducerMap[actionType]</span><br><span class="line">    <span class="keyword">if</span> (!source) <span class="keyword">return</span> draft</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> source === <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span> source(draft, action)</span><br><span class="line">    draft.actionStatus[actionType] = status === FAILURE ? error : status</span><br><span class="line">    source[status] &amp;&amp; source[status](draft, action)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">  user: reduceFunc(userReducerMap, userInitialState),</span><br><span class="line">  post: reduceFunc(postReducerMap, postInitialState),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> rootReducer</span><br></pre></td></tr></table></figure><h3 id="hook-useRedux-js"><a href="#hook-useRedux-js" class="headerlink" title="hook/useRedux.js"></a>hook/useRedux.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useRedux = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = useDispatch()</span><br><span class="line">  <span class="keyword">const</span> select = <span class="function">(<span class="params">...keys</span>) =&gt;</span> </span><br><span class="line">    useSelector(<span class="function"><span class="params">state</span> =&gt;</span> keys.reduce(<span class="function">(<span class="params">a, k</span>) =&gt;</span> a[k] || a, state))</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">type, data</span>) =&gt;</span> dispatcher(&#123; type, data &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    select,</span><br><span class="line">    dispatch,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useRedux</span><br></pre></td></tr></table></figure><h3 id="components-Comment-js"><a href="#components-Comment-js" class="headerlink" title="components/Comment.js"></a>components/Comment.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useRedux <span class="keyword">from</span> <span class="string">&#x27;/hooks/useRedux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Actions <span class="keyword">from</span> <span class="string">&#x27;/actions&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ChangeNickname = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; select, dispatch &#125; = useRedux()</span><br><span class="line">  <span class="keyword">const</span> &#123; loggedId &#125; = select(<span class="string">&#x27;user&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> &#123; nickname &#125; = select(<span class="string">&#x27;user&#x27;</span>, loggedId)</span><br><span class="line">  <span class="keyword">const</span> handleSubmit = <span class="function"><span class="params">e</span> =&gt;</span> dispatch(Actions.CHANGE_NICKNAME, e.target.value)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> defaultValue=&#123;nickname&#125; onSubmit=&#123;handleSubmit&#125; /&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Comment</span><br></pre></td></tr></table></figure><h2 id="6-마치며"><a href="#6-마치며" class="headerlink" title="6. 마치며"></a>6. 마치며</h2><p>코드만 잔뜩이고 글은 거의 없는 긴 글(?) 읽으시느라 수고하셨습니다. 실로 오랜만에 즐거운 코딩을 마치고 흥분된 마음으로 소개해 보았습니다. 이미 한물 간 식상한 방식일 수도 있고, 혹은 더 좋은 방법이 있을지도 모르겠네요. 한동안 코드개선방법(?)이나 최신 트랜드 등에 많이 둔감해진 상태이다보니… 만약 그렇더라도 즐거웠으니 그만이긴 하지만, 혹시라도 더 나은 방안을 알고 계시다면, 혹은 그 어떤 것이든 의견이나 정보 공유해 주시면 정말 좋겠네요.</p><p>피드백 미리 감사합니다!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/post-cover4.jpg&quot;/&gt;&lt;p&gt;React.js에 redux 및 redux-saga를 얹어 사용하면서 느낀 피로감을 최소화하고자 노력한 결과가 제 나름으론 만족스럽게 나와 공유하고자 합니다.&lt;/p&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="FE" scheme="http://roy-jung.github.io/categories/fe/"/>
    
    <category term="React.js" scheme="http://roy-jung.github.io/categories/fe/react-js/"/>
    
    
    <category term="React.js" scheme="http://roy-jung.github.io/tags/react-js/"/>
    
    <category term="redux-saga" scheme="http://roy-jung.github.io/tags/redux-saga/"/>
    
    <category term="refactoring" scheme="http://roy-jung.github.io/tags/refactoring/"/>
    
  </entry>
  
  <entry>
    <title>6. 이제 그만 var는 놓아줍시다.</title>
    <link href="http://roy-jung.github.io/201026-fe-006-leave-var/"/>
    <id>http://roy-jung.github.io/201026-fe-006-leave-var/</id>
    <published>2020-10-26T12:57:51.000Z</published>
    <updated>2020-11-29T12:37:55.907Z</updated>
    
    <content type="html"><![CDATA[<p>앞서 ‘이제 var는 없다고 생각하자’고 했습니다. 왜냐하면 var에는 지금으로서는 이해하기 어려운 특이한 현상들이 다수 존재하고, 이러한 현상들은 자바스크립트를 혼란스럽게 하는 주범이 되곤 하기 때문입니다. 이미 var를 전혀 사용하고 있지 않는 환경에 있는 분은 이번 포스트는 건너뛰어도 괜찮습니다. var의 문제가 무엇인지, 어떤 특이한 현상들이 있는지 궁금한 분들은 재미 삼아 가볍게 읽어보세요.</p><h2 id="1-변수의-유효범위-스코프"><a href="#1-변수의-유효범위-스코프" class="headerlink" title="1. 변수의 유효범위(스코프)"></a>1. 변수의 유효범위(스코프)</h2><p>var로 선언한 변수의 유효범위는 전역스코프를 제외하면 오직 ‘함수스코프’ 뿐입니다. 블록스코프는 var에 아무런 영향을 주지 않습니다. 이 성질은 자바나 C, 파이썬 등 다른 언어에 익숙한 개발자들이 가장 먼저 혼란을 느끼게 되는 포인트입니다.</p><h2 id="2-중복-선언"><a href="#2-중복-선언" class="headerlink" title="2. 중복 선언"></a>2. 중복 선언</h2><p>var로 선언한 변수는 같은 스코프 내에서 다시 선언할 수 있습니다. 이로 인해 문제가 되는 경우는 생각보다 많지는 않습니다. ‘값을 변경하고, 다음 줄에서는 변경된 값을 활용’하는 일반적인 코딩 습관에 따르면 원하는 대로 동작하곤 합니다. 그러나 일단 문제가 생겼을 때엔 원인을 찾아내기가 상당히 까다로운 경우가 많습니다. 특히 블록스코프 내에서 변수를 선언하고는 ‘중복 선언’인 줄 인지하지 못하는 경우가 그렇습니다.</p><h3 id="1-기본-코드"><a href="#1-기본-코드" class="headerlink" title="1) 기본 코드"></a>1) 기본 코드</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getQueryInfo = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> index = url.indexOf(<span class="string">&#x27;query=&#x27;</span>) + <span class="number">6</span></span><br><span class="line">  <span class="keyword">var</span> query = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> lastIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> croppedUrl = url.slice(index)</span><br><span class="line">  <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = croppedUrl.indexOf(<span class="string">&#x27;&amp;&#x27;</span>) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; -<span class="number">1</span>) index = croppedUrl.length - <span class="number">1</span></span><br><span class="line">    query = croppedUrl.substring(<span class="number">0</span>, index + <span class="number">1</span>)</span><br><span class="line">    lastIndex = index</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    query,</span><br><span class="line">    start: index,</span><br><span class="line">    end: lastIndex + index,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getQueryInfo(<span class="string">&#x27;http://abc.com/search?sd=20200720&amp;query=javascript&amp;ed=20200820&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(getQueryInfo(<span class="string">&#x27;http://abcdef.com/search?sd=20200720&amp;query=java&#x27;</span>))</span><br></pre></td></tr></table></figure><p>안티 패턴이긴 하지만 var에 대한 변수의 유효범위 및 중복 선언의 문제점을 확인할 수 있는 예제 코드를 만들어 보았습니다.</p><ul><li>1행의 getQueryInfo는 파라미터로 url 문자열을 받아 ‘query=’ 뒤에 오는 검색어를 찾고, 검색어 정보와 시작 위치, 끝 위치를 반환하는 함수입니다.</li><li>2행에서는 url에서 ‘query=’의 시작 위치를 찾아내어 변수 index에 할당합니다.</li><li>5행에서는 url에서 ‘query=’까지의 문자열을 잘라내고 뒷부분만 croppedUrl에 할당하였습니다.</li><li>6행에서는 만약 이 시작위치가 0 이상인 경우(문자열 내에 ‘query=’가 존재하는 경우) 6행부터 11행까지의 블록스코프 내부를 실행하도록 했습니다.</li><li>7행은 뒷부분에서 다시 ‘&amp;’가 등장하는 위치를 찾아내어 “새로 선언한” 변수 index에 할당합니다.</li><li>8행에서는 뒤에 ‘&amp;’가 없는 경우에는 index에는 문자열의 마지막 위치에 1을 더한 값을 할당하도록 했습니다.</li><li>9행에서는 지금까지 찾아낸 인덱스 정보들로부터 검색어를 특정하여 query 변수에 할당하였습니다.</li><li>10행에서는 블록스코프 내에서 선언한 변수 index의 값을 외부 변수인 nextLastIndex에 할당하였습니다.</li></ul><p>여기까지 보면 코드상으로는 그다지 문제가 없어 보입니다. 그런데 출력을 해보면 결과가 좀 이상합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123; query: &quot;javascript&quot;, start: 9, end: 18 &#125;</span></span><br><span class="line"><span class="comment">// &#123; query: &quot;java&quot;, start: 3, end: 6 &#125;</span></span><br></pre></td></tr></table></figure><p>검색어는 정확하게 잘 찾아내었습니다. 그런데 해당 검색어의 시작 위치 및 끝 위치가 이상합니다. start, end 값을 바탕으로 다시 query의 문자열을 찾아낼 수는 없을 것 같습니다. 자칫 검색어가 잘 나오는 것만 확인하고 안심하며 배포했다가는 큰 일이 날 수도 있겠습니다. 어떠한 에러 메시지도 없이 조용하게 문제를 일으키니 디버깅도 쉽지 않겠네요.</p><p>위 코드의 문제 원인은 독자 모두가 짐작하시듯 var가 블록 스코프의 영향을 받지 않으면서 심지어 중복 선언도 가능하기 때문입니다. 2행의 index와 7행의 index는 동일한 함수스코프 내에 존재하는 동일한 변수입니다. 즉 2행에서 선언한 index 변수를 7행의 index가 덮어버린 것이죠. 그러니까 함수의 마지막에 반환할 start, end에 대입되는 ‘index’는 2행의 index가 아닌 7행 또는 8행에 의해 변경된 index의 값이 되는 것입니다.</p><p>위 문제를 해결하는 방법은 몇 가지가 있는데, 가장 먼저 떠올릴 수 있는 방법은 2행과 7행의 변수명을 서로 다르게 하는 것입니다.</p><h3 id="2-변수명을-서로-다르게-지정"><a href="#2-변수명을-서로-다르게-지정" class="headerlink" title="2) 변수명을 서로 다르게 지정"></a>2) 변수명을 서로 다르게 지정</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getQueryInfo = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> queryIndex = url.indexOf(<span class="string">&#x27;query=&#x27;</span>) + <span class="number">6</span></span><br><span class="line">  <span class="keyword">var</span> query = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> lastIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> croppedUrl = url.slice(queryIndex)</span><br><span class="line">  <span class="keyword">if</span> (queryIndex &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> lastIndex = croppedUrl.indexOf(<span class="string">&#x27;&amp;&#x27;</span>) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (lastIndex &lt; -<span class="number">1</span>) lastIndex = croppedUrl.length - <span class="number">1</span></span><br><span class="line">    query = croppedUrl.substring(<span class="number">0</span>, lastIndex + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    query,</span><br><span class="line">    start: queryIndex,</span><br><span class="line">    end: lastIndex + queryIndex,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getQueryInfo(<span class="string">&#x27;http://abc.com/search?sd=20200720&amp;query=javascript&amp;ed=20200820&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(getQueryInfo(<span class="string">&#x27;http://abcdef.com/search?sd=20200720&amp;query=java&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; query: &quot;javascript&quot;, start: 40, end: 49 &#125;</span></span><br><span class="line"><span class="comment">// &#123; query: &quot;java&quot;, start: 43, end: 46 &#125;</span></span><br></pre></td></tr></table></figure><p>이것만으로 일단 문제는 해결되었지만, if문 내부에서 var 변수를 선언하는 것이 스코프를 착각하게 할 여지가 있으므로 좀 더 고쳐봅시다. var 변수 선언을 모두 함수스코프의 최상단으로 올려둔다면 혼란의 여지가 없어질 것입니다.</p><h3 id="3-var-선언을-스코프-최상단으로-이동"><a href="#3-var-선언을-스코프-최상단으로-이동" class="headerlink" title="3) var 선언을 스코프 최상단으로 이동"></a>3) var 선언을 스코프 최상단으로 이동</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getQueryInfo = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> queryIndex = url.indexOf(<span class="string">&#x27;query=&#x27;</span>) + <span class="number">6</span></span><br><span class="line">  <span class="keyword">var</span> query = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> lastIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> croppedUrl = url.slice(queryIndex)</span><br><span class="line">  <span class="keyword">var</span> lastIndex</span><br><span class="line">  <span class="keyword">if</span> (queryIndex &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    lastIndex = croppedUrl.indexOf(<span class="string">&#x27;&amp;&#x27;</span>) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (lastIndex &lt; -<span class="number">1</span>) lastIndex = croppedUrl.length - <span class="number">1</span></span><br><span class="line">    query = croppedUrl.substring(<span class="number">0</span>, lastIndex + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    query,</span><br><span class="line">    start: queryIndex,</span><br><span class="line">    end: lastIndex + queryIndex,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 스코프를 착각할 여지는 사라졌습니다. 덤으로 변수 선언이 모두 함수 스코프의 최상단에 모여있게 됨으로써 혹시라도 중복 선언된 변수가 있는지를 확인하기가 용이해진 측면이 있네요. 다만 상단에서 선언한 변수와 실제로 할당하려는 변수가 동일한 식별자를 가지고 있는지를 체크하기가 쉽지 않고, 변수명을 수정하고자 할 때에도 마찬가지이겠습니다. 또한 선언과 할당이 분리되어 코드가 다소 길어진 것도 불만스럽네요. 이렇듯 못마땅한 부분이 있긴 하지만, 그럼에도 불구하고 var를 이용하는 한은 이렇게 하는 것이 최선입니다. “변수 선언은 함수스코프 최상단에서만 하라”는 말은 암묵적인 관행 또는 ‘바람직한 코딩 습관’으로 널리 알려져 왔습니다.</p><p>ES5 이하의 자바스크립트에서는 첫 예제에서와 같은 문제가 생각보다 자주 발생하곤 했습니다. 개발자들이 자바스크립트의 여러 규칙을 정확히 이해하지 못한 상태에서 코딩을 했기 때문이라고 볼 수 있습니다. 그러나 이는 자바스크립트가 많은 부분에서 기존 유명 언어(C+, Java 등)와 흡사하기 때문이기도 합니다. 다른 언어에 익숙한 개발자 입장에서는 그 언어의 시선에서 바라보게 되기 마련이니까요.</p><h3 id="4-let-const로-변경"><a href="#4-let-const로-변경" class="headerlink" title="4) let, const로 변경"></a>4) let, const로 변경</h3><p>반면 ES6에서 등장한 블록 스코프와 let 또는 const를 이용하면 위에서 언급한 모든 문제나 불만이 해소됩니다. ‘블록에 의해 스코프가 생긴다’라는 일반적인 예상에 부합하고, 코드가 불필요하게 길어지지 않으며, 중복 선언시 또는 선언 전 호출시 에러가 발생하므로 문제를 즉시 해결할 수 있습니다. 또한 변수 선언을 무조건 맨 위에서 하는 것이 ‘권장’되지 않고, 오히려 정확히 필요한 위치에서 선언하도록 하여 코드를 읽어 내려가다가 다시 위로 올라가서 확인해야 하는 부담이 한결 줄어듭니다. 7행의 index는 getQueryInfo 함수 스코프가 아닌 if문에 의한 블록스코프에 속하는 지역변수로써 2행의 index와 별도로 동작합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getQueryInfo = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> index = url.indexOf(<span class="string">&#x27;query=&#x27;</span>) + <span class="number">6</span></span><br><span class="line">  <span class="keyword">let</span> query = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> lastIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> croppedUrl = url.slice(index)</span><br><span class="line">  <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = croppedUrl.indexOf(<span class="string">&#x27;&amp;&#x27;</span>) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; -<span class="number">1</span>) index = croppedUrl.length - <span class="number">1</span></span><br><span class="line">    query = croppedUrl.substring(<span class="number">0</span>, index + <span class="number">1</span>)</span><br><span class="line">    lastIndex = index</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    query,</span><br><span class="line">    start: index,</span><br><span class="line">    end: lastIndex + index,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>‘var에 대한 스코프와 중복 선언의 문제점’에 대한 소개는 여기까지입니다. 그렇지만 기왕 예시가 나온 김에 한 발 더 나아가 봅시다. url로부터 검색어 정보와 시작 위치, 끝 위치를 가져오는 함수는 다양한 방식으로 구현할 수 있을 것입니다.</p><h3 id="5-split-메서드-활용"><a href="#5-split-메서드-활용" class="headerlink" title="5) split 메서드 활용"></a>5) split 메서드 활용</h3><p>문자열을 정규표현식 없이 분석하는 가장 손쉬운 방법은 split 문자열 메서드를 이용하는 것입니다. split 메서드는 문자열을 지정한 문자를 기준으로 분리하여 배열로 반환해 줍니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getQueryInfo = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> croppedUrl = url.slice(url.indexOf(<span class="string">&#x27;?&#x27;</span>) + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> searchParams = croppedUrl.split(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> queryParam = searchParams.find(<span class="function"><span class="params">param</span> =&gt;</span> param.startsWith(<span class="string">&#x27;query&#x27;</span>))</span><br><span class="line">  <span class="keyword">if</span> (!queryParam) <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;query가 없습니다.&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> query = queryParam.split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">const</span> start = url.indexOf(query)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    query,</span><br><span class="line">    start,</span><br><span class="line">    end: start + query.length - <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2행에서는 url의 ‘?’를 기준으로 뒤에 있는 내용이 모두 ‘searchParam’에 속하므로, ‘?’의 인덱스 바로 다음만을 잘라내었습니다.</li><li>3행에서는 이렇게 잘라낸 문자열을 다시 ‘&amp;’를 기준으로 분리하였습니다.</li><li>4행에서는 분리된 배열에서 ‘query’로 시작하는 요소를 찾아내었습니다. find 메서드는 배열 요소들을 처음부터 하나씩 순회하면서 콜백함수를 실행하여 콜백함수의 반환값이 true인 요소를 찾아냅니다. startsWith는 단어 그대로 해당 문자열(param)이 파라미터에 지정한 값(‘query’)으로 시작하는지 여부를 판단하여 true / false를 반환합니다. 즉 searchParams의 각 요소들 중에 ‘query’로 시작하는 요소가 있다면 그 값이 queryParams에 담길 것입니다.</li><li>만약 ‘query’로 시작하는 요소가 없다면 5행에 의해 에러를 반환할 것입니다.</li><li>6행에서는 4행에서 찾아낸 query로 시작하는 요소를 다시 ‘=’을 기준으로 분리하여, ‘=’ 뒤의 요소를 선택했습니다. 이것이 실제 검색어에 해당할 것입니다.</li><li>이제 검색어의 시작 위치(7행)와 끝 위치를 찾아내어 반환하면 됩니다.</li></ul><p>split을 활용한 방법은 새로운 접근 방식이긴 하지만 근본 원리는 기본 예제와 완전히 같습니다. ‘query’라는 문자열을 찾고, 뒤따르는 ‘=’의 다음부터 그 뒤의 ‘&amp;’ 또는 마지막까지가 실제 검색어에 해당할 것이라는 접근입니다. 5행의 에러 처리 기법도 함께 눈여겨 보시면 좋겠습니다.</p><h3 id="6-정규표현식-활용"><a href="#6-정규표현식-활용" class="headerlink" title="6) 정규표현식 활용"></a>6) 정규표현식 활용</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getQueryInfo = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> regExp = <span class="regexp">/query=([A-z가-힣0-9]&#123;1,&#125;)/</span></span><br><span class="line">  <span class="keyword">const</span> [, query] = regExp.exec(url) || []</span><br><span class="line">  <span class="keyword">if</span> (!query) <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;query가 없습니다.&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> start = url.indexOf(query)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    query,</span><br><span class="line">    start,</span><br><span class="line">    end: start + query.length - <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2행에서 ‘query=’ 다음에 이어서 영어나 한글 또는 숫자로 이뤄진 1개 이상의 문자열을 찾아내어 그룹핑 하는 정규표현식을 만들었습니다. 3행에서 이를 url에 적용하고, 그 결과 중 인덱스가 1인 요소만을 query 변수에 할당하였습니다(해체할당 - 나중에 다룹니다). 정규표현식을 실행한 결과 조건에 맞는 문자열이 없는 경우에는 빈배열을 반환하게 함으로써 query 변수에는 undefined가 할당 되고, 4행에 의해 에러 메시지를 출력하게 했습니다. 5행부터는 위 (5)와 동일합니다. 정규표현식은 자바스크립트 고유의 문법이 아닌 대부분의 프로그래밍 언어에서 제공하는 공통의 형식 언어이므로 정규식 내용에 대해서는 자세한 설명을 하지 않겠습니다.</p><p>필자의 개인적인 의견으로는, 정규표현식은 자바스크립트 학습에 필수적인 요소는 아닌 것 같습니다. 위 코드에서의 <code>[A-z가-힣0-9]</code>와 같은 표현은 영어, 한글을 제외한 다른 언어는 찾아내지 못합니다. 그렇다고 <code>[\w\W]</code>와 같이 모든 문자열을 허용하도록 하면 ‘&amp;’ 마저 검색 조건을 충족해 버리게 되므로 검색어만을 정확히 특정하지 못하게 됩니다. 이런 문제들을 잘 보완하여 일견 잘 동작하는 것처럼 보이는 표현식을 완성한 것 같다가도, 좀 더 테스트를 거치면 또다른 오류가 발견되는 경우가 많습니다. 따라서 충분한 테스트를 거쳐 예외 케이스들을 정밀히 검토하여 수정하는 노력이 필요한데, 예외 사항들을 더 많이 반영할수록 가독성이 떨어지고 난이도가 올라감과 동시에 성능은 저하될 수 밖에 없습니다. 따라서 간단하면서도 정확하게 구현할 수 있는 경우가 아닌 한 가급적 다른 방안을 먼저 고려하고, 정규표현식은 부득이한 경우에 제한적으로 사용하는 것이 바람직할 것입니다.</p><h3 id="7-URLSearchParams-활용"><a href="#7-URLSearchParams-활용" class="headerlink" title="7) URLSearchParams 활용"></a>7) URLSearchParams 활용</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getQueryInfo = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> searchParams = <span class="keyword">new</span> URLSearchParams(url)</span><br><span class="line">  <span class="keyword">const</span> query = searchParams.get(<span class="string">&#x27;query&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (!query) <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;query가 없습니다.&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> start = url.indexOf(query)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    query,</span><br><span class="line">    start,</span><br><span class="line">    end: start + query.length - <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이번에는 이전 포스트에서도 소개했던 URLSearchParams를 활용하였습니다. 전체적으로 앞서 소개했던 내용들과 동일한 로직을 따르므로 설명은 생략합니다. 이 방법이 앞서 소개한 여느 방법(정규표현식 포함)에 비해 더 안전하면서 신뢰도 높은 정보를 얻을 수 있는 좋은 방법입니다. 다만 앞서 기술한 대로 2020년 현재까지도 이를 지원하지 않는 오래된 브라우저 사용자들이 일정 비율 남아있는 실정이라, 사용자 환경에 따라 적용 여부를 달리 판단할 필요가 있겠습니다.</p><h2 id="3-전역공간에서의-이상한-동작들"><a href="#3-전역공간에서의-이상한-동작들" class="headerlink" title="3. 전역공간에서의 이상한 동작들"></a>3. 전역공간에서의 이상한 동작들</h2><p>다시 본론으로 돌아와 보죠. var의 단점을 살펴보던 중이었습니다. 전역스코프에서 선언한 var는 전역객체와의 관계에서 이상하게 동작합니다. 바로 전역스코프에서 var로 선언한 변수는 동시에 전역객체의 프로퍼티가 되는 것입니다. 심지어 이렇게 암묵적으로 추가된 전역객체의 프로퍼티는 삭제할 수도 없습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a, <span class="built_in">window</span>.a) <span class="comment">// 1 1</span></span><br><span class="line"><span class="keyword">delete</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a, <span class="built_in">window</span>.a) <span class="comment">// 1 1</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.a</span><br><span class="line"><span class="built_in">console</span>.log(a, <span class="built_in">window</span>.a) <span class="comment">// 1 1</span></span><br></pre></td></tr></table></figure><p>다행히 let과 const에 대해서는 더이상 이런 이상한 동작을 보이지 않습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a, <span class="built_in">window</span>.a) <span class="comment">// 1 undefined</span></span><br><span class="line"><span class="built_in">window</span>.a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(a, <span class="built_in">window</span>.a) <span class="comment">// 1 2</span></span><br><span class="line"><span class="keyword">delete</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a, <span class="built_in">window</span>.a) <span class="comment">// 1 2</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.a</span><br><span class="line"><span class="built_in">console</span>.log(a, <span class="built_in">window</span>.a) <span class="comment">// 1 undefined</span></span><br></pre></td></tr></table></figure><p>우리는 전역 스코프에서 var는 이상하게 동작하고, let과 const는 그렇지 않다는 점만 알고 넘어가는 것으로 충분합니다. 혹시 더 자세한 내용이 궁금하신 분은 <a href="https://wikibook.co.kr/corejs/">코어 자바스크립트</a>를 참고하세요.</p><h2 id="4-TDZ"><a href="#4-TDZ" class="headerlink" title="4. TDZ"></a>4. TDZ</h2><p>var로 선언한 변수에 대해서는 TDZ가 없습니다.</p><h2 id="5-변수-키워드-생략에-대한-오해"><a href="#5-변수-키워드-생략에-대한-오해" class="headerlink" title="5. 변수 키워드 생략에 대한 오해"></a>5. 변수 키워드 생략에 대한 오해</h2><p>개발자 커뮤니티 상에는 ‘var’ 키워드 없이 처음 등장하는 식별자에 무작정 값을 할당하더라도 자바스크립트 엔진은 이를 ‘전역스코프에서의 var 선언’과 동일시 하여 아무런 문제 없이 통과시켜 버린다는 것이 정설처럼 퍼져 있습니다. 그러나 이는 사실이 아닙니다. 실제로는 ‘선언’ 없이 ‘할당’만 이루어집니다. 관건은 ‘어디에’ 할당이 되는지 이겠죠. 할당은 해당 식별자를 검색하는 과정을 거친 다음, 찾아낸 식별자에 값을 대입하는 과정으로 진행됩니다. 그런데 이 ‘검색’ 과정의 중간에 대상을 찾지 못하는 경우에는 스코프 체이닝을 타고 전역객체까지 올라갑니다. 전역객체에도 해당 식별자(프로퍼티)가 없다면 이제는 전역객체에 새로운 프로퍼티를 만들고, 그 새로운 프로퍼티에 값을 할당하는 것입니다. 즉 선언된 적 없는 식별자에 값을 할당하고자 하면, 해당 명령이 어떤 스코프에서 수행되었건 상관 없이 무조건 전역객체의 프로퍼티에 값을 할당합니다. 이는 스코프 체이닝의 최상단에 있는 전역객체가 ‘객체’이기 때문에 발생하는 현상으로, ‘var의 생략’과는 무관합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">func()</span><br><span class="line"><span class="built_in">console</span>.log(a, <span class="built_in">window</span>.a) <span class="comment">// 1 1</span></span><br><span class="line"><span class="keyword">delete</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a, <span class="built_in">window</span>.a) <span class="comment">// Error: a is not defined</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;앞서 ‘이제 var는 없다고 생각하자’고 했습니다. 왜냐하면 var에는 지금으로서는 이해하기 어려운 특이한 현상들이 다수 존재하고, 이러한 현상들은 자바스크립트를 혼란스럽게 하는 주범이 되곤 하기 때문입니다. 이미 var를 전혀 사용하고 있지 않</summary>
      
    
    
    
    <category term="FE" scheme="http://roy-jung.github.io/categories/fe/"/>
    
    <category term="javascript" scheme="http://roy-jung.github.io/categories/fe/javascript/"/>
    
    <category term="variable" scheme="http://roy-jung.github.io/categories/fe/javascript/variable/"/>
    
    
  </entry>
  
  <entry>
    <title>5. let vs. const</title>
    <link href="http://roy-jung.github.io/201026-fe_005_let-and-const/"/>
    <id>http://roy-jung.github.io/201026-fe_005_let-and-const/</id>
    <published>2020-10-26T12:37:39.000Z</published>
    <updated>2020-11-29T12:37:55.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="let과-const의-차이점"><a href="#let과-const의-차이점" class="headerlink" title="let과 const의 차이점"></a>let과 const의 차이점</h1><h2 id="차이점-1-const는-선언과-할당이-동시에-이루어져야만-한다"><a href="#차이점-1-const는-선언과-할당이-동시에-이루어져야만-한다" class="headerlink" title="차이점 1. const는 선언과 할당이 동시에 이루어져야만 한다."></a>차이점 1. const는 선언과 할당이 동시에 이루어져야만 한다.</h2><p>const로 변수를 선언할 때에는 반드시 할당도 함께 해야만 합니다. 가만 생각해 보면 논리적으로 마땅합니다. let의 경우는 변할 수 있음을 전제로 하고 있으니, 값이 할당되지 않은 상태라 해도 의미가 있을 수 있습니다. 값의 할당 여부에 따라 다르게 동작하는 함수 등 다양한 쓰임새가 있을 것입니다. 반면 값이 할당되지 않은 변경 불가능한 변수는 과연 어디에 쓸 수 있을까요? 실로 존재할 가치가 없이 메모리만 차지하는 부담스러운 존재가 될 뿐입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;   <span class="comment">// OK.</span></span><br><span class="line"><span class="keyword">const</span> b;</span><br><span class="line"><span class="comment">// chrome  | Error: Missing initializer in const declaration</span></span><br><span class="line"><span class="comment">// safari  | Error: const declared variable &#x27;b&#x27; must have an initializer.</span></span><br><span class="line"><span class="comment">// firefox | Error: missing = in const declaration</span></span><br></pre></td></tr></table></figure><p>세 브라우저에서의 에러메시지가 표현은 다르지만 결국 같은 얘기를 하고 있습니다. 크롬과 사파리는 ‘initializer’가 반드시 있어야 하는데 없으니 에러가 났다고 합니다. initializer는 초기값을 지정하는 행위를 말합니다. 즉 const 선언시에는 초기값을 지정이 반드시 필요한데 그러한 행위가 이루어지지 않았음을 알려주는 것입니다. 파이어폭스는 const 선언에 <code>=</code> (할당)이 빠졌다고 알려주네요. 변경 불가능한 변수로써 존재 가치를 지니기 위한 당연한 요구입니다.</p><h2 id="차이점-2-const로-선언한-변수는-재할당이-불가능하다"><a href="#차이점-2-const로-선언한-변수는-재할당이-불가능하다" class="headerlink" title="차이점 2. const로 선언한 변수는 재할당이 불가능하다."></a>차이점 2. const로 선언한 변수는 재할당이 불가능하다.</h2><p>정의 자체가 let은 ‘변경 가능한 변수’이고 const는 ‘변경 불가능한 변수 선언’이니 더이상 설명할 것이 없는 차이점입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="number">1</span> <span class="comment">// OK.</span></span><br><span class="line">c = <span class="number">2</span></span><br><span class="line"><span class="comment">// chrome  | Error: Assignment to constant variable.</span></span><br><span class="line"><span class="comment">// safari  | Error: Attempted to assign to readonly property.</span></span><br><span class="line"><span class="comment">// firefox | Error: invalid assignment to const &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure><p>역시 브라우저들이 모두 같은 얘기를 하고 있습니다. 크롬은 ‘constant variable’에 assign한 자체가 문제라고 하고, 사파리는 ‘readonly property’에 assign하려는 시도가 문제라고 합니다. 파이어폭스는 ‘유효하지 않은 할당’이라고 하네요.</p><p>개인적으로 사파리의 단어 사용은 좀 아쉽네요. ‘readonly property’라는 단어는 문자 그대로 읽기 전용 속성을 부여한 객체의 프로퍼티에 대해서만 쓰는 것이 옳다고 생각합니다. 변수는 변수일 뿐 어떤 객체의 프로퍼티가 아닙니다. 전역공간에서의 ‘var’가 전역객체의 프로퍼티와 동일한 것으로 간주하는 이상한 시스템이 존재하긴 하지만, 이는 오직 ‘var’로 선언하였거나, ‘var’로 선언한 것으로 간주할 수 있는 상황에서만 성립합니다. 오히려 TC39 위원회는 let과 const에 대해서, ‘var’에 관한 이 이상한 시스템으로 인한 문제를 해소하기 위해 전역공간에서도 전역객체의 프로퍼티와 동일시하지 않고 독립적으로 동작하도록 하였습니다. 또한 ECMAScript 명세상으로는 let, const, var로 선언한 변수 모두 LexicalEnvironment의 environmentRecord에 기록된다고 정의되어 있습니다. 그러나 이는 어디까지나 ‘이런 논리 흐름대로 동작하면 된다’는 이론일 뿐입니다. 실제 자바스크립트 엔진들은 이 정의를 저마다 다양한 방식으로 구현하고 최적화하고 있지만, 그 결과물은 결국 엔진 내부 로직일 뿐, 외부에 노출된 코드 상에서까지 객체의 프로퍼티로 간주되거나 그러한 성질을 지닌다고 볼 여지는 없습니다.</p><h1 id="let과-const의-공통점"><a href="#let과-const의-공통점" class="headerlink" title="let과 const의 공통점"></a>let과 const의 공통점</h1><p>차이점보다는 공통점이 더 많고 더 중요합니다. 하나하나 살펴봅시다.</p><h2 id="공통점-1-재선언-불가"><a href="#공통점-1-재선언-불가" class="headerlink" title="공통점 1. 재선언 불가"></a>공통점 1. 재선언 불가</h2><p>재선언은 ‘재할당’과는 다른 개념입니다. 재할당은 이미 선언된 변수에 다른 값을 다시 할당하는 것이고, 재선언은 동일한 변수명에 대해 let, const 등으로 다시 한 번 선언하는 것을 말합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span> <span class="comment">// 재선언. Error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">3</span></span><br><span class="line">b = <span class="number">4</span> <span class="comment">// 재할당. OK</span></span><br></pre></td></tr></table></figure><p>let과 const는 모두 한 번 선언한 변수를 다시 선언할 수 없습니다. 다시 선언하려고 하면 에러가 발생합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span></span><br><span class="line"><span class="comment">// chrome  | Error: Identifier &#x27;a&#x27; has already been declared</span></span><br><span class="line"><span class="comment">// safari  | Error: Cannot declare a let variable twice: &#x27;a&#x27;.</span></span><br><span class="line"><span class="comment">// firefox | Error: redeclaration of let a</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"><span class="comment">// chrome  | Error: Identifier &#x27;b&#x27; has already been declared</span></span><br><span class="line"><span class="comment">// safari  | Error: Cannot declare a const variable twice: &#x27;b&#x27;.</span></span><br><span class="line"><span class="comment">// firefox | Error: redeclaration of const b</span></span><br></pre></td></tr></table></figure><p>크롬은 ‘식별자 a/b가 이미 선언되었다’고 하고, 사파리는 ‘let 변수를 두 번 선언할 수 없다’고 합니다. 파이어폭스는 ‘let/const 변수의 재선언’이라고만 합니다. 사파리의 표현이 가장 직관적이네요.</p><h2 id="공통점-2-TDZ-접근불가구역"><a href="#공통점-2-TDZ-접근불가구역" class="headerlink" title="공통점 2. TDZ: 접근불가구역"></a>공통점 2. TDZ: 접근불가구역</h2><p>let과 const는 선언이 이뤄지기 전까지는 해당 변수에 접근할 수 없습니다. 당연한 말인 것 같지만, 기존 var에 대해서는 그렇게 동작하지 않았습니다.</p><p>자바스크립트 창시자인 Brendan Eich가 의도했는지 여부와 무관하게, 결과적으로 자바스크립트는 ‘개발하기 쉽고 유연한’ 프로그래밍 언어로 어필할 수 있는 특징들을 다수 지닌 채 탄생하였습니다. 함수 및 변수 선언 위치와 무관하게 어디서든 실행할 수 있고(호이스팅), 정수형과 부동소수점형이 별도로 존재하지 않은 채 ‘숫자형’ 하나만 존재하며, 숫자형과 문자형 등의 형변환을 명시적으로 하지 않고도 자동으로 형변환이 이뤄지기도 하고, 0, ‘’, null, undefined 등은 조건문 등에서 false로 동작하는 등이 그렇습니다.</p><p>그러나 마냥 쉽고 유연한 언어를 지향한다고만 할 수는 없게 만드는 예상치 못한 부작용도 상당히 많이 존재했습니다. 각종 버그성 특징은 차치하더라도, 전역스코프를 제외하면 일반적인 스코프가 함수스코프만 존재했다는 점, 산술연산 결과의 오차가 생각보다 크다는 점, 전역변수가 전역객체의 프로퍼티와 동일시되는 점 등이 그렇습니다.</p><p>다른 프로그래밍 언어에 익숙한 사람들이 자바스크립트를 처음 접한 경우 생각보다 손쉽게 프로그램이 의도한 대로 동작하는 것을 경험하곤 합니다. 그러다가 앞서 기술한 특이한 성질들을 접했을 때, 이를 ‘자바스크립트의 고유한 특징’으로 이해하려는 노력을 기울이기보다 ‘이상한 언어’로 취급하려는 경향을 보이는 경우가 많았습니다.</p><p>호이스팅은 개발자로 하여금 자바스크립트가 쉽고 유연하다고 생각하게 하는 측면도 있고, 이상하다거나 어렵다고 느끼게 만들기도 하는 양면성을 보이는 단적인 예입니다. 코드상에서 함수선언문이나 var로 선언한 변수를 선언한 위치보다 더 위에서 접근해도 자바스크립트는 에러 없이 조용히 넘어갑니다. 심지어 함수는 많은 경우 아무런 문제 없이 잘 동작하기도 합니다. 물론 이 때 변수의 경우에는 값이 undefined인 상태여서 문제가 될 소지가 있긴 합니다. 그런데 이런 경우에도 해당 변수에 접근한 자체가 아닌, 해당 변수의 자료형을 undefined 외의 다른 형태로 간주하여 별도의 연산을 처리할 때에 비로소 문제를 야기하곤 합니다. 함수의 경우에도 중복선언이 이뤄진 경우에는 나중에 선언된 함수만 동작하게 되므로 이 역시 문제이죠.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = a + <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(b &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>호이스팅에 의해 변수 a, b는 1행부터 접근이 가능합니다. 1행에서 a의 값은 아직 초기화가 이뤄지기 전 상태라서 undefined입니다. undefined와 10을 더하라는 연산은 자바스크립트가 자동으로 숫자형에 대한 연산으로 여겨, 숫자형이 아닌 값을 숫자형으로 형변환한 다음 실제 연산을 수행합니다. undefined를 숫자형으로 고치면 NaN이 됩니다. 이 상태에서 10을 더하면 여전히 NaN이죠. 따라서 변수 b에는 NaN이 할당됩니다. 2행에서는 b의 값이 0보다 크면 true, 그렇지 않으면 false를 출력하라고 합니다. NaN은 숫자형이긴 하지만 값의 비교에 대해 언제나 false를 반환합니다. 이후 3행에서 a에 5를 할당하고 코드 실행이 종료됩니다.</p><p>위 코드에서 개발자의 원래 의도대로 a에 5가 할당되어 true가 출력되려면 3행을 1행보다 위쪽으로 올렸어야 합니다. 그런데 개발자도 사람인지라 종종 실수를 할 수 있죠. 프로그래밍 세계에서 디버깅이 차지하는 비중은 코딩 자체보다 더 많을 수도 있습니다. 어디서 문제가 되었는지를 파악하는 데에만도 시간이 걸릴 수밖에 없기 때문입니다. 심지어 위 코드는 실행하고 결과를 받아본 후에도 문제가 있는지조차 파악하지 못할 수 있습니다. 어떠한 에러도 발생시키지 않고 조용히 처리하여 false가 ‘잘’ 출력되기 때문입니다. true를 예상했는데 false가 왜 나왔을지를 고민하며 코드 전반을 살펴보다가 a 변수가 3행에서 선언 및 할당된 것을 발견해야만 드디어 코드 수정을 할 수 있습니다. 예제 코드가 짧으니 망정이지, 긴 코드들로 이루어진 일반적인 업무 환경에서 이러한 오류를 찾아내는 데에는 생각보다 많은 시간이 필요할 수 있습니다.</p><p>디버깅 시간을 줄이기 위해서는 예상과 다른 결과의 원인이 무엇인지를 가급적 빨리 파악하는 것이 중요합니다. 그러기 위해서는 1행에서 a에 접근하려 할 때부터 에러 메시지가 노출된다면 개발자에겐 더없이 좋을 것입니다. let과 const가 바로 이렇게 동작합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = a + <span class="number">10</span></span><br><span class="line"><span class="comment">// chrome  | Error: a is not defined</span></span><br><span class="line"><span class="comment">// safari  | Error: Cannot access uninitialized variable.</span></span><br><span class="line"><span class="comment">// firefox | Error: can&#x27;t access lexical declaration &#x27;a&#x27; before initialization</span></span><br><span class="line"><span class="built_in">console</span>.log(b &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">5</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = a + <span class="number">10</span>;</span><br><span class="line"><span class="comment">// chrome  | Error: Cannot access &#x27;a&#x27; before initialization</span></span><br><span class="line"><span class="comment">// safari  | Error: Cannot access uninitialized variable.</span></span><br><span class="line"><span class="comment">// firefox | Error: can&#x27;t access lexical declaration &#x27;a&#x27; before initialization</span></span><br><span class="line"><span class="built_in">console</span>.log(b &gt; <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>역시 각 브라우저의 에러메시지가 표현 방식은 다르지만 에러의 원인이 무엇인지 충분히 설명하고 있습니다. 그 중 크롬만이 유일하게 let과 const를 구분하여 다르게 표현하고 있는데, 그 중에서도 let에 대한 표현이 가장 정확해 보입니다. a를 선언한 방식이 let이든 const이든, 1행에서의 상태는 변수 a가 ‘아직 선언되기 전’인 상태이므로, 선언을 전제로 한 ‘초기화’ 내지 ‘할당’에 대한 메시지를 표시할 이유는 없습니다. 즉 let과 const 모두에 대해 ‘not defined’ 라는 메시지를 출력하는 것이 타당합니다. 다만 const의 경우 선언과 동시에 할당(초기화)가 반드시 이루어져야 하니, 굳이 선언과 초기화를 구분할 이유가 없긴 합니다. 따라서 let에 대해서는 ‘아직 정의되지 않았음’을, const에 대해서는 ‘초기화 되기 전에는 접근할 수 없음’을 알려주는 크롬의 에러메시지가 가장 도움이 된다고 봅니다.</p><p>TDZ는 Temporal Dead Zone의 약자입니다. 직역하면 임시사망지역, 임시사각지대 정도가 되겠습니다. 그러나 이보다는 ‘접근불가구역’이라고 표현하는 것이 의미가 더 잘 와닿는 것 같습니다. let과 const로 선언한 변수는 선언이 실제로 이뤄지기 전까지 그 변수에 접근할 수 없습니다. 그리고 이렇게 접근할 수 없는 구역을 TDZ라고 칭합니다. 명세에 기재된 것은 아니지만 전세계 자바스크립트 개발자들 사이에서 널리 통용되는 명칭입니다.</p><h1 id="TDZ와-스코프"><a href="#TDZ와-스코프" class="headerlink" title="TDZ와 스코프"></a>TDZ와 스코프</h1><p>TDZ와 스코프의 관계로부터 발생하는 재미 있는(?) 현상이 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 블록스코프 A</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 블록스코프 B</span></span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// (?)</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1행의 조건문에 의해 7번줄까지의 블록스코프 A가 생성되었습니다. 2행에서 선언한 변수 a가 유효한 범위는 1행의 조건문에 의한 블록스코프 A 내부입니다. 3행의 다시 조건문에 의해 6번줄까지의 블록스코프 B가 생성되었습니다. 이제 4행에서 변수 a에 접근하고자 합니다. 그런데 5행에서는 2행의 변수와 동일한 식별자를 지닌 변수를 선언했습니다. 4행은 블록스코프 B에 속하면서, B의 변수 a가 선언되는 위치인 5행보다 코드상 위에 위치하고 있는, 블록스코프 B의 TDZ 영역에 속하는 위치입니다. 이 위치에서는 어떤 결과가 출력될까요? 만약 자바스크립트 엔진이 4행 위치에서 5행의 변수 선언보다 ‘먼저 선언된’ 외부 변수에 대한 접근을 우선시 한다면, 블록스코프 A에서 선언한 변수 a에 접근하여 1을 출력할 것입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chrome  | Error: Cannot access &#x27;a&#x27; before initialization</span></span><br><span class="line"><span class="comment">// safari  | Error: Cannot access uninitialized variable.</span></span><br><span class="line"><span class="comment">// firefox | Error: can&#x27;t access lexical declaration &#x27;a&#x27; before initialization</span></span><br></pre></td></tr></table></figure><p>실제로는 TDZ 에러가 출력되었습니다. 그렇다면 자바스크립트 엔진은 스코프 내부에서 선언한 변수가 있는 한, 외부에 동일한 식별자가 존재하건 존재하지 않건 상관 없이 무조건 내부에서 선언한 변수에 먼저 접근하고자 한다는 것을 알 수 있습니다. 내부에서 선언한 변수가 존재하는 한, 설령 TDZ에 속한다 하더라도 상위 스코프에 대한 검색을 하지 않습니다.</p><p>사용자가 어떤 변수에 접근하고자 하면 자바스크립트 엔진은 해당 코드에서 가장 가까운 스코프에서 먼저 해당 변수를 검색하고, 없으면 보다 상위의 스코프에서 해당 변수를 검색합니다. 이런 순서로 계속 상위 스코프로 올라가다 보면 마지막에는 늘 전역 스코프까지 탐색하게 됩니다. 이런 검색 과정을 스코프 체이닝(scope chaining)이라 합니다. 스코프가 체인처럼 줄줄이 연결되어 있는 이미지를 떠올리시면 되겠습니다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;let과-const의-차이점&quot;&gt;&lt;a href=&quot;#let과-const의-차이점&quot; class=&quot;headerlink&quot; title=&quot;let과 const의 차이점&quot;&gt;&lt;/a&gt;let과 const의 차이점&lt;/h1&gt;&lt;h2 id=&quot;차이점-1-const는-</summary>
      
    
    
    
    <category term="FE" scheme="http://roy-jung.github.io/categories/fe/"/>
    
    <category term="javascript" scheme="http://roy-jung.github.io/categories/fe/javascript/"/>
    
    <category term="variable" scheme="http://roy-jung.github.io/categories/fe/javascript/variable/"/>
    
    
  </entry>
  
  <entry>
    <title>4. scope</title>
    <link href="http://roy-jung.github.io/201026-fe_004_scope/"/>
    <id>http://roy-jung.github.io/201026-fe_004_scope/</id>
    <published>2020-10-26T12:29:12.000Z</published>
    <updated>2020-11-11T01:24:58.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scope-변수의-유효범위"><a href="#Scope-변수의-유효범위" class="headerlink" title="Scope: 변수의 유효범위"></a>Scope: 변수의 유효범위</h1><p>자바스크립트에는 세 가지의 유효범위, 즉 ‘스코프(scope)’가 있습니다. let 또는 const로 선언한 변수는 세 스코프 모두의 영향을 받습니다.</p><h2 id="1-전역-스코프-global-scope"><a href="#1-전역-스코프-global-scope" class="headerlink" title="1. 전역 스코프: global scope"></a>1. 전역 스코프: global scope</h2><p>전역 스코프는 자바스크립트 코드의 가장 큰 유효범위입니다. ‘전역(全域)’이란 ‘모든 지역’을 뜻합니다. 코드의 모든 지역에서 접근할 수 있는 영역임을 표현한 한자어입니다. 전역 스코프에서 선언한 변수를 ‘전역 변수(global variable)’라고 합니다. 전역 변수는 전역 스코프 내에서만 존재하며, 외부에서는 접근할 수 없습니다. 반대로 전역 변수는 코드 내부 어디서든 접근할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> functionC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b) <span class="comment">// 1 2</span></span><br><span class="line">  <span class="keyword">const</span> functionD = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b) <span class="comment">// 1 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  functionD()</span><br><span class="line">&#125;</span><br><span class="line">functionC()</span><br></pre></td></tr></table></figure><p>전역 스코프 및 전역 변수와 대칭점에 있는 표현으로 ‘지역 스코프(local scope)’ 및 ‘지역 변수(local variable)’가 있습니다. 안티패턴인 eval 스코프(eval 명령에 의해 생성되는 스코프)를 제외하면, 자바스크립트의 모든 스코프는 전역 스코프이거나 지역 스코프입니다.</p><h2 id="2-함수-스코프-function-scope"><a href="#2-함수-스코프-function-scope" class="headerlink" title="2. 함수 스코프: function scope"></a>2. 함수 스코프: function scope</h2><p>함수 내에서 선언한 변수는 함수 내에서만 유효하며 함수 외부에서는 접근할 수 없습니다. 반면 해당 함수 내부에서는 TDZ(1-6-2에서 소개합니다)에 속하지 않는 한 어디서나 참조할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> functionA = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line">  <span class="keyword">const</span> functionB = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> c = <span class="number">3</span></span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1 2 3</span></span><br><span class="line">  &#125;</span><br><span class="line">  functionB()</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">  <span class="comment">// chrome &amp; firefox | Error: c is not defined.</span></span><br><span class="line">  <span class="comment">// safari           | Error: Can&#x27;t find variable: c</span></span><br><span class="line">&#125;</span><br><span class="line">functionA()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> functionA = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line">  <span class="keyword">const</span> functionB = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> c = <span class="number">3</span></span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1 2 3</span></span><br><span class="line">  &#125;</span><br><span class="line">  functionB()</span><br><span class="line">&#125;</span><br><span class="line">functionA()</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)</span><br><span class="line"><span class="comment">// chrome &amp; firefox | Error: a is not defined.</span></span><br><span class="line"><span class="comment">// safari           | Error: Can&#x27;t find variable: a</span></span><br></pre></td></tr></table></figure><p>위 두 코드는 <code>console.log(a, b, c)</code> 의 위치만 다르고 나머지는 완전히 동일합니다. 우선 functionB 내부에서의 console.log 명령에 의해 <code>1 2 3</code>이 잘 출력되었습니다. functionB 내부에서는 functionA 내부에서 선언한 변수 a 및 b와 functionB 내부에서 선언한 변수 c 모두를 참조할 수 있음을 확인했습니다.첫 번째 코드에서는 functionA 내부에서는 어떨지를 확인해 보았는데 에러가 발생했습니다. 변수 c가 ‘정의되지 않았다’거나, ‘찾을 수 없다’고 합니다. functionA에서는 functionB에서 선언한 변수 c의 존재조차 알지 못하는 것입니다. 두 번째 코드에서는 전역 스코프에서의 결과를 확인해 보았는데 역시 에러가 발생했습니다. 당장 a부터 찾을 수 없기 때문에 뒤의 b, c를 찾으려는 시도를 하기도 전에 이미 중단되고 말았습니다. 전역 스코프에서는 functionA에서 선언한 변수들의 존재조차 알지 못하는 것입니다.</p><p><em>함수 스코프는 실행 컨텍스트(execution context)와 밀접한 연관이 있습니다. 실행 컨텍스트와 스코프 및 스코프 체이닝, 클로저 등에 대한 자세한 내용은 제 저서인 <a href="https://wikibook.co.kr/corejs/">코어 자바스크립트</a>를 참고하시기 바랍니다.</em></p><h2 id="3-블록-스코프-block-scope"><a href="#3-블록-스코프-block-scope" class="headerlink" title="3. 블록 스코프: block scope"></a>3. 블록 스코프: block scope</h2><p>함수를 제외한 모든 문(statement) 형태의 문법(if문, for문, while문, switch/case문, try/catch문 등) 내부에서 선언한 변수는 문(중괄호) 내에서만 유효하며, 블록 외부에서는 접근할 수 없습니다.</p><blockquote><p><strong>‘식’과 ‘문’에 대하여</strong></p></blockquote><blockquote><p>어떤 하나 이상의 명령을 수행하는 단위를 통틀어 ‘문(statement)’라 합니다. 이 중에서 명령 수행의 결과로 어떤 값을 도출하는 경우를 특별히 ‘식 또는 표현식(expression)’이라 합니다. 즉 식은 문의 부분집합입니다. 그러나 일반적으로는 식과 문을 보다 명확히 구분하기 위해서, 값을 도출하지 않는 경우만을 일컬어 ‘문’이라고 하는 경우가 많습니다. 이 방식에 의하면 식과 문은 서로 부분집합이 아닌 여집합 관계가 됩니다. 저는 이 방식을 따르겠습니다. 앞으로는 ‘식’은 수행 결과 값이 되는 경우를, ‘문’은 수행 결과 값을 도출하지 않고 넘어가는 경우를 말하는 것으로 이해해 주세요.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 조건문 (1)</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 결과: 1</span></span><br><span class="line">  <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 조건문 (2)</span></span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 결과: 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 결과: Error: a is not defined.</span></span><br></pre></td></tr></table></figure><p>조건문 (1) 내에서 선언한 변수 a는 조건문 (1)의 블록 스코프 내부 어디서든 접근할 수 있습니다. 조건문 (2) 역시 조건문 (1)의 블록스코프에 접근할 수 있습니다. 그러나 조건문 (1)의 외부에 해당하는 8행에서는 접근할 수 없으므로 에러가 발생했습니다.</p><p>블록 스코프는 for문, if문 등 ‘문 형태의 문법’에 의해서만 발생하는 것이 아닙니다. 단순히 중괄호로 묶기만 한 경우에도 성립합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// (문 시작)</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 결과: 1</span></span><br><span class="line">&#125; <span class="comment">// (문 종료)</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 결과: Error: a is not defined.</span></span><br></pre></td></tr></table></figure><p>실제로 이런 식의 코드를 작성할 이유는 전혀 없습니다. 이렇게 작성하더라도 블록 스코프가 발생한다는 사실을 소개하고자 하였을 뿐입니다. 이런 의미 없는 문은 절대 작성하지 맙시다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Scope-변수의-유효범위&quot;&gt;&lt;a href=&quot;#Scope-변수의-유효범위&quot; class=&quot;headerlink&quot; title=&quot;Scope: 변수의 유효범위&quot;&gt;&lt;/a&gt;Scope: 변수의 유효범위&lt;/h1&gt;&lt;p&gt;자바스크립트에는 세 가지의 유효범위,</summary>
      
    
    
    
    <category term="FE" scheme="http://roy-jung.github.io/categories/fe/"/>
    
    <category term="javascript" scheme="http://roy-jung.github.io/categories/fe/javascript/"/>
    
    <category term="variable" scheme="http://roy-jung.github.io/categories/fe/javascript/variable/"/>
    
    
  </entry>
  
  <entry>
    <title>3. const 소개</title>
    <link href="http://roy-jung.github.io/201026_fe_003_const/"/>
    <id>http://roy-jung.github.io/201026_fe_003_const/</id>
    <published>2020-10-26T12:24:14.000Z</published>
    <updated>2020-10-28T07:22:28.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="const-변경-불가능한-변수-선언"><a href="#const-변경-불가능한-변수-선언" class="headerlink" title="const: 변경 불가능한 변수 선언"></a>const: 변경 불가능한 변수 선언</h1><h2 id="1-소개"><a href="#1-소개" class="headerlink" title="1. 소개"></a>1. 소개</h2><p>변경 불가능한 변수라니, 앞뒤가 맞지 않는 말인 것 같습니다. 시작부터 혼란스럽네요. 역사적으로 프로그래밍 언어에서 쓰이는 단어를 실제 의미에 맞게 적용하는 대신 그때그때 필요에 따라 관습적으로 많이 사용되어 왔던 단어들을 적당히 차용해온 탓에, 후세에 학습을 해야 하는 우리가 고통스럽습니다. 이 고통의 원인은 사회에서 널리 통용되는 ‘변수’의 의미와 프로그래밍 언어상의 ‘변수’의 의미가 다르기 때문입니다. 변수란 <strong>값을 담을 수 있는 저장공간</strong>입니다. 이 개념을 곱씹어보면 이제는 전혀 이상하지 않게 느껴질 것입니다. const는 한 번 값을 담고 나면 다시는 다른 값으로 바꿔 담을 수 없는(변경 불가능한) 저장공간(변수)를 생성하는 방식입니다. 즉 ‘재할당’을 허용하지 않는 것입니다.</p><h2 id="2-const는-상수가-아니다"><a href="#2-const는-상수가-아니다" class="headerlink" title="2. const는 상수가 아니다."></a>2. const는 상수가 아니다.</h2><p>혹자는 const를 ‘상수’라고 부르기도 하지만, 필자의 생각에는 좀 길더라도 ‘재할당 불가능한 변수’라는 표현이 적절해 보입니다. 왜냐하면 ‘상수’란 처음부터 존재했고 끝까지 존재할, 처음부터 끝까지 늘 한결같은 값이라는 느낌인데, const로 선언한 변수는 그런 의미와는 다소 거리가 있기 때문입니다. const로 선언한 변수는 해당 선언 위치보다 이전에는 존재하지 않았고, 선언 후에도 유효범위(스코프)를 벗어난 뒤에는 존재하지 않게 됩니다. 값을 할당하여 초기화가 이뤄진 후부터 선언 당시의 스코프를 벗어나기 전까지가 const로 선언한 변수가 존재하는 영역입니다. 그러니까 ‘상수’라는 단어는 언제나 한결같이 유지될 것이 보장되는 <code>Number.EPSILON</code>, <code>Math.PI</code>, <code>Number.MAX_SAFE_INTEGER</code> 등에나 어울립니다.</p><p>그런가 하면 const로 선언한 변수가 실존하는 영역에서조차 ‘상수’ 개념과 다소 동떨어진 모습을 보이는 경우도 있습니다. const 변수에 객체를 할당한 경우에 그렇습니다. 코드로 확인해 봅시다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iu = &#123;</span><br><span class="line">  name: <span class="string">&#x27;지은&#x27;</span>,</span><br><span class="line">  age: <span class="number">26</span>,</span><br><span class="line">&#125;</span><br><span class="line">iu.age = <span class="number">27</span></span><br><span class="line">iu.job = <span class="string">&#x27;가수&#x27;</span></span><br><span class="line"><span class="keyword">delete</span> iu.name</span><br><span class="line"><span class="built_in">console</span>.log(iu) <span class="comment">// &#123; age: 27,  job: &#x27;가수&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>const로 선언한 iu라는 변수에 객체를 할당했습니다. iu.age의 값을 27로 변경하고, iu.job에는 ‘가수’를 할당했습니다. iu.name을 삭제하고 iu를 출력하니 추가/변경/삭제한 내용들이 모두 제대로 반영되어 있습니다. const는 ‘변경 불가능한 변수’라고 했는데 어찌된 일인지 변경이 가능하네요. 이는 const를 ‘상수’로 여기면 이해하기 어려운 현상이지만 실은 아무런 문제가 없습니다. 자바스크립트에게 어떤 변수에 참조형 데이터를 할당하라고 명령하면, 자바스크립트는 그 변수의 저장공간에 참조형 데이터 자체를 저장하지 않습니다. 참조형 데이터는 별도의 메모리상에 저장하고, 저장한 데이터를 특정할 수 있는 ‘메모리 주솟값’을 할당합니다. 따라서 변수에는 그 객체가 저장된 ‘메모리 주솟값’이 담기고, 이후로는 다른 값으로 변경할 수 없게 되는 것입니다. 객체 내부의 프로퍼티들에 어떤 변경사항이 있더라도, 객체가 저장된 메모리 주솟값이 바뀌지 않는 한 const로 선언한 iu 변수에는 아무런 문제가 없습니다. 그리고 다행스럽게도(?) 객체가 저장된 메모리 주솟값은 const로 선언한 변수가 실행 컨텍스트의 종료에 따라 소멸하기 전까지는 영원히 변하지 않습니다.</p><p>참조형 데이터에 관한 얘기는 이정도로 마무리 짓겠습니다. 더 자세한 내용은 제 책 <a href="https://wikibook.co.kr/corejs/">코어 자바스크립트</a>를 참고하시기 바랍니다.</p><h2 id="3-심리적-안정감"><a href="#3-심리적-안정감" class="headerlink" title="3. 심리적 안정감"></a>3. 심리적 안정감</h2><p>const로 선언한 변수에 다른 값을 재할당할 수 없음은 둘째 치더라도, 명시적으로 ‘변경 불가능함’을 표기한다는 자체만으로도 생각보다 큰 심리적 안정감을 주게 됩니다. 동료가 작성한 코드를 살펴보던 중 어떤 변수가 let으로 선언되었다면 이후의 코드를 읽는 내내 해당 변수가 언제 변하게 될 지 모른다는 점을 계속 염두에 두며 읽어야만 합니다. 한참 아래에서 해당 변수를 발견했을 때, 그 변수가 그 위치에서 어떤 값을 가지고 있을지를 단번에 확신할 수 없습니다. 반면 const로 선언된 경우에는 이런 걱정을 할 필요가 없습니다. 예상치 못한 버그가 발생하더라도 혹여 const로 선언한 변수가 잘못 되었을지를 의심할 필요가 없습니다. 한참 아래에서 발견하더라도 처음의 그 값을 여전히 지니고 있을 거라고 자신할 수 있습니다.</p><p>눈썰미 좋은 독자라면 이미 눈치채셨을지도 모르지만, 사실 이전 <code>let</code> 포스트에서 기본 코드를 제외한 ‘더 나은 방안’들로 소개한 코드들은 순차적으로 최대한 let을 제거하는 방향성을 지니고 있습니다. 부득이하게 let을 제거하지 못한 경우는 debounce를 다룬 예제 뿐입니다. 바꿔 말하면 적절하게 let을 활용한 예제는 오직 debounce 예제 뿐이었다는 뜻이기도 합니다.</p><p>가급적 let을 사용하지 않는 방법을 고민하고, 가능한 모든 경우에서 const를 쓰고자 노력하시기 바랍니다. 이 노력이 이어지면 나중에는 let으로 선언한 변수에 대해서는 ‘무조건 언젠가는 값이 바뀔 것’이라고 인식하여 해당 변수를 중점적으로 살펴볼 수 있게 됩니다. 코드의 흐름을 파악하고 디버깅하는 데에 수고를 덜 들일 수 있게 되는 것입니다. 실제로 let을 쓰려는 생각이 들 때마다 const로도 가능할지를 고민하다 보면, 놀라우리만큼 많은 경우에 let을 쓰지 않아도 된다는 것을 깨닫게 될 것입니다. 앞서 소개한 참조형 데이터를 생각하면 더욱 그렇습니다. 실무에서는 어떤 변수를 선언하여 기본형 데이터를 직접 할당하는 경우에 비해, 참조형 데이터 하나를 만들어두고 그 내부의 프로퍼티만 조작하는 경우가 압도적으로 많습니다. 내부 프로퍼티 조작만으론 어려운 상황에 처하더라도 조금 더 생각해보면 내부 프로퍼티 조작만으로 가능한 다른 방법을 찾아낼 수 있는 경우가 있고, 설령 그럴 수 없다 해도 기존 변수는 그대로 둔 채 새로운 변수를 생성하여 새로운 객체를 할당하는 편이 나은 경우가 많습니다. 이에 대해서는 역시 <a href="https://wikibook.co.kr/corejs/">코어 자바스크립트</a>의 ‘불변성’ 파트를 참고하시기 바랍니다.</p><p>const는 변경 불가능성에서 비롯한 성질들을 제외하면 거의 모든 면에서 let과 똑같기 때문에, 자세한 성질들은 let과 const를 비교하면서 살펴보도록 하겠습니다. 그러기에 앞서, let과 const의 성질을 이해하기 위해 빼놓을 수 없는 중요한 개념인 ‘스코프’를 먼저 소개하겠습니다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;const-변경-불가능한-변수-선언&quot;&gt;&lt;a href=&quot;#const-변경-불가능한-변수-선언&quot; class=&quot;headerlink&quot; title=&quot;const: 변경 불가능한 변수 선언&quot;&gt;&lt;/a&gt;const: 변경 불가능한 변수 선언&lt;/h1&gt;&lt;h2</summary>
      
    
    
    
    <category term="FE" scheme="http://roy-jung.github.io/categories/fe/"/>
    
    <category term="javascript" scheme="http://roy-jung.github.io/categories/fe/javascript/"/>
    
    <category term="variable" scheme="http://roy-jung.github.io/categories/fe/javascript/variable/"/>
    
    
  </entry>
  
  <entry>
    <title>2. let - 반복문 &amp; debounce</title>
    <link href="http://roy-jung.github.io/201026_fe_002_let-iteration/"/>
    <id>http://roy-jung.github.io/201026_fe_002_let-iteration/</id>
    <published>2020-10-26T11:31:26.000Z</published>
    <updated>2020-10-28T07:22:19.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a>반복문</h1><p>일반적으로 재할당 가능 변수(let)을 선언하는 또다른 경우로 반복문이 있습니다.<br>이번에는 동적으로 과일 목록 html 엘리먼트를 생성하는 예제를 살펴봅시다.</p><h2 id="1-기본-코드"><a href="#1-기본-코드" class="headerlink" title="1. 기본 코드"></a>1. 기본 코드</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildListElem = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> elem = <span class="string">&#x27;&lt;ul&gt;&#x27;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    elem += <span class="string">&#x27;&lt;li&gt;&#x27;</span> + list[i] + <span class="string">&#x27;&lt;/li&gt;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  elem += <span class="string">&#x27;&lt;/ul&gt;&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> elem</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;바나나&#x27;</span>, <span class="string">&#x27;사과&#x27;</span>, <span class="string">&#x27;배&#x27;</span>, <span class="string">&#x27;딸기&#x27;</span>, <span class="string">&#x27;귤&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> listElem = buildListElem(fruits)</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML += listElem</span><br></pre></td></tr></table></figure><p>9행에서 buildListElem 함수를 호출하였습니다. buildListElem 함수는 list 라는 배열을 받습니다.<br>2행에서 변경 가능한 변수 elem을 선언하고, 여기에 ‘&lt;ul&gt;‘을 저장했습니다.<br>3행부터 5행까지는 for 반복문 내에서 인덱싱을 목적으로 하는 변경 가능한 변수 i를 선언하여 i의 값을 1씩 증가시키면서 elem에 문자열을 추가해 나갑니다.<br>for 반복문을 마친 후인 6행에서는 ul 마침태그를 추가해주고, 7행에서 최종 elem을 반환해줍니다.<br>반환된 결과는 9행의 listElem 변수에 저장됩니다.<br>10행에서는 innerHTML에 직접 접근하여 listElem에 저장된 내용을 HTML로써 삽입합니다.</p><p>이번 예제에서는 <code>let</code>이 총 두 번 등장했습니다. 리스트 정보를 생성하기 위한 문자열 변수 elem과, list의 인덱싱을 처리하기 위한 숫자형 변수 i입니다.<br>이것만으로도 문제 없이 동작하긴 하지만, 더 나은 방법들을 계속 살펴봅시다.</p><h2 id="2-document-createElement"><a href="#2-document-createElement" class="headerlink" title="2. document.createElement"></a>2. document.createElement</h2><p>우선 innerHTML에 직접 접근하여 HTML 엘리먼트를 제어하는 것은 위험하고 바람직하지 않습니다. 여는 태그와 닫는 태그를 정확히 매칭시키지 못하는 실수를 일으킬 가능성이 높을 뿐 아니라, 문자열로 이루어진 형태를 강제로 HTML로 여기도록 하는 방식은 브라우저에 생각보다 큰 부담을 줍니다.<br>이런 위험을 제거하기 위해, 코드가 조금 길어지긴 하지만 innerHTML 대신 다른 기법을 사용해 봅시다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildListElem = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ul = <span class="built_in">document</span>.createElement(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">    li.innerText = list[i]</span><br><span class="line">    ul.append(li)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ul</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;바나나&#x27;</span>, <span class="string">&#x27;사과&#x27;</span>, <span class="string">&#x27;배&#x27;</span>, <span class="string">&#x27;딸기&#x27;</span>, <span class="string">&#x27;귤&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> listElem = buildListElem(fruits)</span><br><span class="line"><span class="built_in">document</span>.body.append(listElem)</span><br></pre></td></tr></table></figure><p>이렇게 바꾸고 보니 여는 태그와 닫는 태그에 대해 고려할 필요가 없어져서 마지막까지 문자열을 조합하는 방식에 비해 실수할 가능성이 많이 줄어들었습니다. innerHTML 대신 append를 활용함으로써 브라우저에 주는 부담도 줄였습니다. 그렇지만 반복문에서는 여전히 실수할 가능성이 남아있습니다. 예를 들어 for문의 범위를 설정하는 부분에서 <code>&lt;</code> 대신 <code>&lt;=</code>를 쓴다거나, 변화를 설정하는 부분에서 <code>i++</code> 대신 <code>++i</code>를 쓴다면 그 결과는 완전히 달라지게 될 것입니다. 범위를 <code>list.length</code>까지로 설정해야 하는지, 혹은 <code>list.length - 1</code>까지로 설정해야 하는지도 혼란스럽습니다. 이처럼 for문은 개발자로 하여금 실수할 수 있는 여지를 많이 내포하고 있습니다.</p><p><em>위 방식보다 insertAdjacentHTML을 사용하는 것이 성능 면에서 더 낫긴 하지만 작성해야 하는 코드가 전반적으로 innerHTML과 크게 다르지 않기 때문에 생략합니다.</em></p><h2 id="3-forEach"><a href="#3-forEach" class="headerlink" title="3. forEach"></a>3. forEach</h2><p>반복문 대신 배열의 메서드인 <code>forEach</code>를 활용해 봅시다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildListElem = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ul = <span class="built_in">document</span>.createElement(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line">  list.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">    li.innerText = value</span><br><span class="line">    ul.append(li)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> ul</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;바나나&#x27;</span>, <span class="string">&#x27;사과&#x27;</span>, <span class="string">&#x27;배&#x27;</span>, <span class="string">&#x27;딸기&#x27;</span>, <span class="string">&#x27;귤&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> listElem = buildListElem(fruits)</span><br><span class="line"><span class="built_in">document</span>.body.append(listElem)</span><br></pre></td></tr></table></figure><p>forEach는 배열의 첫번째 값부터 마지막 값까지를 차례로 순회하면서 콜백함수를 실행합니다. <code>list[i]</code> 대신 forEach가 콜백함수를 호출할 때 자동으로 넘겨주는 인자를 그대로 활용하였습니다(item). forEach 메서드는 모든 개발자가 반드시 알고 있어야 하는 메서드이므로 첫번째 인자에 어떤 값이 올 것인지도 정확히 인지할 수 있습니다. 또한 i값을 증가시키고, 범위를 설정하는 등의 부담을 지지 않아도 되므로 실수할 여지가 현저히 줄어듭니다.</p><h2 id="4-reduce"><a href="#4-reduce" class="headerlink" title="4. reduce"></a>4. reduce</h2><p>이번에는 3.을 바탕으로 배열 메서드인 <code>reduce</code>를 활용해 보겠습니다. <code>reduce</code>는 처음 접할 때엔 다소 난이도가 있습니다. 추후 배열 챕터에서 제대로 다루기 전에 먼저 대략적으로나마 감을 잡아보자는 차원에서 소개합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildListElem = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> list.reduce(<span class="function">(<span class="params">ul, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">    li.innerText = value</span><br><span class="line">    ul.append(li)</span><br><span class="line">    <span class="keyword">return</span> ul</span><br><span class="line">  &#125;, <span class="built_in">document</span>.createElement(<span class="string">&#x27;ul&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;바나나&#x27;</span>, <span class="string">&#x27;사과&#x27;</span>, <span class="string">&#x27;배&#x27;</span>, <span class="string">&#x27;딸기&#x27;</span>, <span class="string">&#x27;귤&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> listElem = buildListElem(fruits)</span><br><span class="line"><span class="built_in">document</span>.body.append(listElem)</span><br></pre></td></tr></table></figure><p>reduce는 배열의 첫번째 값부터 마지막 값까지를 차례로 순회하면서 콜백함수를 실행하는데, 콜백함수의 첫번째 인자에는 바로 직전 콜백함수에서 반환한 결과가 담겨 있습니다. 콜백함수가 처음 호출될 때에는 함수 뒤에 지정해준 값이 첫번째 인자가 됩니다. 따라서 ul이라는 변수를 선언하지 않고도 배열 순회만으로 원하는 결과를 바로 도출해낼 수 있습니다.</p><h1 id="간단한-debounce-구현"><a href="#간단한-debounce-구현" class="headerlink" title="간단한 debounce 구현"></a>간단한 debounce 구현</h1><p>이번엔 난이도 높은 다른 예제를 소개하겠습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> simpleDebounce = <span class="function">(<span class="params">callback, delay</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timeoutId = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeoutId) <span class="built_in">clearTimeout</span>(timeoutId)</span><br><span class="line">    timeoutId = <span class="built_in">setTimeout</span>(callback, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> resizeHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> pElem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">  pElem.innerText = <span class="string">`w: <span class="subst">$&#123;<span class="built_in">window</span>.innerWidth&#125;</span>, h: <span class="subst">$&#123;<span class="built_in">window</span>.innerHeight&#125;</span>`</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(pElem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> onResize = simpleDebounce(resizeHandler, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, onResize)</span><br></pre></td></tr></table></figure><p>말 그대로 간단한 debounce 함수입니다. debounce란 같은 형태의 입력이 일정 시간 간격 내에 연속적으로 발생할 경우 그 중 하나의 입력만을 처리하고 나머지는 무시하는 기법입니다. 비슷한 개념으로 throttle이 있는데, throttle은 연속적으로 발생하는 입력값들 중 일정 시간 간격마다 하나씩만 취하는 기법입니다. 같은 말인 것 같지만 엄연히 동작 방식과 사용 목적이 다릅니다.</p><p>예를 들어 위 예제에서처럼 시간 간격을 300ms(0.3초)로 한 상태에서 2.1초 동안 균일한 속도로 창크기를 조절할 경우, debounce에 의하면 마지막 시점으로부터 0.3초 뒤에 결과값이 딱 한 번만 출력됩니다. 반면 throttle에 의할 경우 0.3초마다 한 번씩 결과값이 출력되어 총 7번의 출력물을 확인하게 됩니다. 따라서 값의 변화를 주기적으로 체크하여 처리할 필요가 있는 경우에는 throttle을, 마지막(또는 첫번째) 결과만을 활용하고자 할 때엔 debounce를 씁니다. 드래그 이벤트처럼 마우스의 위치를 주기적으로 파악하여 꾸준히 어떤 대상의 위치를 조정해줘야 할 경우에는 throttle이 적합하겠죠. 반면 가로폭의 길이 변화에 따라 보여줄 내용을 달리해야 할 경우에는 마지막 한 번만 체크하는 것으로 충분하므로 debounce가 적합할 것입니다.</p><p>두 기법 모두 짧은 시간 간격으로 연달아 발생하는 사용자 이벤트 등에 대한 처리 효율을 높이기 위해 활용합니다. 이 둘은 프론트엔드의 성능 최적화를 위해 빼놓을 수 없는 중요한 기법입니다.</p><p>simpleDebounce는 클로저를 활용하였습니다. 변경가능한 timeoutId 변수를 선언하고 함수를 반환합니다. 반환되는 함수는 timeoutId에 값이 설정되어 있는 경우(setTimeout이 이미 실행되었으나 delay 만큼의 시간이 경과되지는 않은 상태인 경우) 이를 취소시키고(clearTimeout), 새롭게 setTimeout을 설정하여 그 때 생성된 id(콜백 함수를 실행시키거나 취소시키기 위한 식별자)를 timeoutId 변수에 재할당합니다.</p><p>resize 이벤트가 발생한 이후 0.3초 이내에 다시 resize 이벤트가 발생한 경우, 앞서 발생한 이벤트에 대한 처리를 취소하고 다시 delay 시간 후에 콜백을 실행하도록 등록합니다. 사용자가 브라우저 크기를 조절할 경우 resize 이벤트는 브라우저 환경에 따라 약 1ms~20ms에 한 번씩 연속해서 발생하게 되는데, 바로 직전의 이벤트와 다음 이벤트 간격이 0.3초 이내에 있으므로 마지막 바로 앞까지의 이벤트는 모두 취소되고, 마지막 이벤트로부터 0.3초 후에야 비로소 콜백함수를 호출하게 됩니다. 일반적으로 사람은 마우스를 완전히 균일한 속도로 움직이게 할 수는 없기 때문에 순간 순간 멈추는 경우가 발생하곤 하는데, 이러한 경우에도 0.3초 이내에 다시 움직이기만 한다면 무시할 수 있도록 설정한 것입니다. 시간 간격을 0.3초보다 줄일 경우 변경 완료 시점과 resizeHandler 함수가 실행되는 시간 사이의 간격이 줄어드는 대신, 경우에 따라 resizeHandler 함수가 실행되는 횟수가 더 많아질 수 있습니다.반면 시간 간격을 0.3초보다 늘릴 경우 변경 완료 시점으로부터 resizeHandler 함수가 실행되는 시간은 더 늦어지겠지만, resizeHandler가 창 크기를 조절하는 중간에 원치 않게 실행되는 경우는 줄어들겠죠.</p><p>어쨌든 위 예제에서는 timeoutId라는 재할당 가능한 변수를 이용하여 간단하게(?) debounce를 구현하였습니다. lodash, underscore 등의 라이브러리에서 제공하는 debounce는 제가 소개한 간단한 debounce 함수에 비해 훨씬 복잡하고 편리한 기능을 담고 있습니다. 그렇지만 상황에 따라 앞서 구현한 기능 만으로 충분한 경우도 많이 있습니다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;반복문&quot;&gt;&lt;a href=&quot;#반복문&quot; class=&quot;headerlink&quot; title=&quot;반복문&quot;&gt;&lt;/a&gt;반복문&lt;/h1&gt;&lt;p&gt;일반적으로 재할당 가능 변수(let)을 선언하는 또다른 경우로 반복문이 있습니다.&lt;br&gt;이번에는 동적으로 과일 목록 h</summary>
      
    
    
    
    <category term="FE" scheme="http://roy-jung.github.io/categories/fe/"/>
    
    <category term="javascript" scheme="http://roy-jung.github.io/categories/fe/javascript/"/>
    
    <category term="variable" scheme="http://roy-jung.github.io/categories/fe/javascript/variable/"/>
    
    
  </entry>
  
  <entry>
    <title>1. let - url param 생성 함수 만들기</title>
    <link href="http://roy-jung.github.io/201026_fe_001_let-set-url-params/"/>
    <id>http://roy-jung.github.io/201026_fe_001_let-set-url-params/</id>
    <published>2020-10-26T11:27:51.000Z</published>
    <updated>2020-10-28T07:22:11.938Z</updated>
    
    <content type="html"><![CDATA[<p>let은 ‘재할당’, 즉 이미 할당이 이루어진 변수에 다시 다른 값을 할당할 수 있는 변수 선언 방식입니다. 실무에서는 주로 자주 변경을 해야 하는 경우 또는 넘어온 데이터를 변형, 재가공하는 과정에서 임시로 저장할 필요가 있을 때에 활용하게 됩니다. let으로 선언한 변수에는 기존에 할당한 값과 데이터 타입이 같은지 여부와 관계 없이 어떤 데이터 타입의 값도 재할당할 수 있습니다.</p><p>let을 좀 더 자세히 알아보기에 앞서 간단한 예제를 먼저 살펴볼까 합니다. 다음 네 가지 파라미터를 받아 실제로 검색 페이지로 이동할 수 있는 URL을 만들어 봅시다.</p><ul><li>검색어(query)</li><li>검색기간유형(period): y(1년), 6m(6개월), m(한 달), w(한 주), d(하루)</li><li>시작일(startDate): YYYYMMDDHHmmss</li><li>마감일(endDate): YYYYMMDDHHmmss</li></ul><h2 id="1-기본-코드"><a href="#1-기본-코드" class="headerlink" title="1. 기본 코드"></a>1. 기본 코드</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildUrl = <span class="function">(<span class="params">query, period, startDate, endDate</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">&#x27;https://search.daum.net/search?w=tot&amp;q=&#x27;</span> + <span class="built_in">encodeURI</span>(query)</span><br><span class="line">  <span class="keyword">if</span> (period) url += <span class="string">&#x27;&amp;period=&#x27;</span> + period</span><br><span class="line">  <span class="keyword">if</span> (startDate) url += <span class="string">&#x27;&amp;sd=&#x27;</span> + startDate</span><br><span class="line">  <span class="keyword">if</span> (endDate) url += <span class="string">&#x27;&amp;ed=&#x27;</span> + endDate</span><br><span class="line">  <span class="keyword">return</span> url</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newUrl = buildUrl(<span class="string">&#x27;자바스크립트&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;20200626000000&#x27;</span>, <span class="string">&#x27;202007260000000&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>1행에서는 buildUrl이라는 변경 불가능한 변수를 선언하고, 여기에 새로운 익명의 화살표함수를 할당했습니다. buildUrl 함수는 query, period, startDate, endDate를 파라미터로 받습니다.</li><li>이후 8행에서 buildUrl 함수를 호출하였습니다.</li><li>2행에서 변경 가능한 변수 url을 선언하고, 여기에 <code>https://search.daum.net/search?w=tot&amp;q=javascript</code>를 저장했습니다. encodeURI는 검색어가 한글 등 브라우저가 인식할 수 없는 글자들로 이루어진 경우 이를 브라우저가 인식할 수 있는 글자로 바꾸어 줍니다.</li><li>3행의 period 값이 비어있지 않으므로 이제 url 값은 <code>https://search.daum.net/search?w=tot&amp;q=javascript&amp;period=w</code>가 됩니다.</li><li>같은 방식으로 4행 및 5행을 거치면, 최종적으로 url에는 <code>https://search.daum.net/search?w=tot&amp;q=javascript&amp;period=m&amp;sd=202006262000000&amp;ed=202007262000000</code>가 담기게 됩니다.</li><li>6행에서 최종값을 반환해주면 함수가 종료되고, 반환된 url 값이 8행의 newUrl에 담기게 됩니다.</li><li>9행에서는 브라우저의 href 값을 newUrl로 교체해 줌으로써 다음의 검색화면으로 이동하게 됩니다.</li></ul><p>예제의 2행에서 선언한 변수 url의 값은 5행까지 각 행을 거치면서 문자열의 내용이 점차 증가했습니다. 사실 우리는 url 변수에 다른 문자열을 ‘추가’하라는 명령을 내렸지만, 실제로는 기존 내용과 추가된 내용을 합쳐서 ‘완전히 새로운’ 문자열을 만들고, 그렇게 만들어진 새 문자열을 url 변수에 ‘재할당’ 하는 식으로 동작합니다. 이처럼 <code>let</code>은 재할당이 필요한 경우에 유용한 변수 선언 방식입니다.</p><p>위 예제는 let을 소개하기 위해 마련했지만, 실은 더 나은 방안이 많이 있습니다.</p><h2 id="2-배열-활용"><a href="#2-배열-활용" class="headerlink" title="2. 배열 활용"></a>2. 배열 활용</h2><p>가장 먼저 생각할 수 있는 방법은 배열을 이용하는 것입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildUrl = <span class="function">(<span class="params">query, period, startDate, endDate</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> queries = [<span class="string">&#x27;w=tot&#x27;</span>, <span class="string">&#x27;q=&#x27;</span> + <span class="built_in">encodeURI</span>(query)]</span><br><span class="line">  <span class="keyword">if</span> (period) queries.push(<span class="string">&#x27;period=&#x27;</span> + period)</span><br><span class="line">  <span class="keyword">if</span> (startDate) queries.push(<span class="string">&#x27;sd=&#x27;</span> + startDate)</span><br><span class="line">  <span class="keyword">if</span> (endDate) queries.push(<span class="string">&#x27;ed=&#x27;</span> + endDate)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;https://search.daum.net/search?&#x27;</span> + queries.join(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newUrl = buildUrl(<span class="string">&#x27;자바스크립트&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;20200626000000&#x27;</span>, <span class="string">&#x27;202007260000000&#x27;</span>)</span><br></pre></td></tr></table></figure><p>배열과 <code>join</code> 메서드를 사용했습니다. ‘&amp;’를 입력하는 횟수가 적으므로 상대적으로 실수할 가능성이 줄어들었습니다. 다만 여전히 개발자가 직접 반복 입력해야 하는 내용이 많이 보입니다. 가능한 모든 수단을 동원하여 반복을 최소화 하고 싶네요.<br>다시 한 번 코드를 살펴봅시다. 함수 파라미터를 query 대신 <code>q</code>, startDate 대신 <code>sd</code>, endDate 대신 <code>ed</code>로 바꾼다면 뭔가 가능할 것도 같습니다. 일단 해보죠.</p><h2 id="3-객체와-map"><a href="#3-객체와-map" class="headerlink" title="3. 객체와 map"></a>3. 객체와 map</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildUrl = <span class="function"><span class="params">queries</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> searchParams = <span class="built_in">Object</span>.entries(queries)</span><br><span class="line">  searchParams.unshift([<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;tot&#x27;</span>])</span><br><span class="line">  <span class="keyword">const</span> searchParamsString = searchParams</span><br><span class="line">    .map(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;q&#x27;</span>) <span class="keyword">return</span> key + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">encodeURI</span>(value)</span><br><span class="line">      <span class="keyword">return</span> key + <span class="string">&#x27;=&#x27;</span> + value</span><br><span class="line">    &#125;)</span><br><span class="line">    .join(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;https://search.daum.net/search?&#x27;</span> + searchParamsString</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newUrl = buildUrl(&#123;</span><br><span class="line">  q: <span class="string">&#x27;자바스크립트&#x27;</span>,</span><br><span class="line">  period: <span class="string">&#x27;m&#x27;</span>,</span><br><span class="line">  sd: <span class="string">&#x27;20200626000000&#x27;</span>,</span><br><span class="line">  ed: <span class="string">&#x27;202007260000000&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>고민 끝에 아예 buildUrl 함수가 인자를 객체 하나만 받도록 고쳐보았습니다. 객체의 프로퍼티 키(key)값은 ‘query’, ‘startDate’, ‘endDate’ 대신 실제 url에 적용해야 하는 <code>q</code>, <code>sd</code>, <code>ed</code>로 명칭을 변경하였습니다. 이 객체를 다시 <code>Object.entries</code> 메서드에 대입함으로써 [key, value] 쌍으로 이루어진 배열로 전환하고, 반환된 내용을 searchParams에 할당했습니다.<br>4행에서는 배열 메서드인 map을 이용하여 문자열을 조합하였습니다. 앞의 (2)에 비해 사용자가 직접 제어하는 내용은 더 줄었고, 대신 자바스크립트 엔진이 처리하도록 위임한 부분이 늘었습니다. map 메서드 내부의 콜백함수에서는 첫 번째 인자를 바로 해체하여 사용하였습니다. 사용자가 직접 제어하는 내용이 줄어들 수록 실수 가능성도 함께 줄어들고, 보다 프로그래밍이 지향하는 방향에 가까워 집니다.</p><h2 id="4-URLSearchParams"><a href="#4-URLSearchParams" class="headerlink" title="4. URLSearchParams"></a>4. URLSearchParams</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildUrl = <span class="function"><span class="params">queries</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> searchParams = <span class="keyword">new</span> URLSearchParams(<span class="string">&#x27;w=tot&#x27;</span>)</span><br><span class="line">  <span class="built_in">Object</span>.entries(queries).forEach(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">    searchParams.append(key, value)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;https://search.daum.net/search?&#x27;</span> + searchParams.toString()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newUrl = buildUrl(&#123;</span><br><span class="line">  q: <span class="string">&#x27;자바스크립트&#x27;</span>,</span><br><span class="line">  period: <span class="string">&#x27;m&#x27;</span>,</span><br><span class="line">  sd: <span class="string">&#x27;20200626000000&#x27;</span>,</span><br><span class="line">  ed: <span class="string">&#x27;202007260000000&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>이번에는 URLSearchParams 라는 window 내장 메서드를 이용했습니다. 이 방법은 각 키와 값 사이에 ‘=’을 입력할 필요가 없습니다. 뿐만 아니라 인코딩을 신경 쓰지 않아도 됩니다. 명시적으로 ‘URLSearchParams’를 다루는 것임을 표기하고 있어 다른 개발자들이 이 함수가 어떤 식으로 동작할 것인지를 예측하기도 쉽습니다.<br>단점이라면, IExplorer에서는 URLSearchParams을 지원하지 않으니 코드가 실제 사용될 환경을 고려할 필요가 있습니다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><ul><li>let을 다룬다고 해놓고 이상한 내용이 덕지덕지 붙었습니다. 앞으로도 계속해서 이렇게 제멋대로 이상하게 흘러가는 글을 써보고자 합니다.</li><li>let에 대해서는 다음 포스트에서 이어서 소개할 것입니다.</li><li>위 방안들 외에 다른 더 좋은 방법이 있다면 댓글로 알려주세요!</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;let은 ‘재할당’, 즉 이미 할당이 이루어진 변수에 다시 다른 값을 할당할 수 있는 변수 선언 방식입니다. 실무에서는 주로 자주 변경을 해야 하는 경우 또는 넘어온 데이터를 변형, 재가공하는 과정에서 임시로 저장할 필요가 있을 때에 활용하게 됩</summary>
      
    
    
    
    <category term="FE" scheme="http://roy-jung.github.io/categories/fe/"/>
    
    <category term="javascript" scheme="http://roy-jung.github.io/categories/fe/javascript/"/>
    
    <category term="variable" scheme="http://roy-jung.github.io/categories/fe/javascript/variable/"/>
    
    
  </entry>
  
  <entry>
    <title>0. &quot;실용적인 프론트엔드 개발 지식&quot;을 시작하며</title>
    <link href="http://roy-jung.github.io/201026_fe_000_intro/"/>
    <id>http://roy-jung.github.io/201026_fe_000_intro/</id>
    <published>2020-10-26T11:18:51.000Z</published>
    <updated>2020-10-26T12:59:44.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="오랜만입니다"><a href="#오랜만입니다" class="headerlink" title="오랜만입니다!"></a>오랜만입니다!</h1><p>근 3년만에 블로그를 다시 열었습니다.<br>실무에서 작업하면서 맞딱뜨리는 이런저런 프론트엔드 이슈에 대해 다뤄보고자 하여 시작합니다.<br>아무거나 그때 그때 생각나는대로 올릴 예정입니다.</p><h1 id="컨셉"><a href="#컨셉" class="headerlink" title="컨셉"></a>컨셉</h1><ul><li>HTML, CSS, Javascript 등을 넘나들 계획입니다.</li><li>쉬운 개념이라도 나름대로 집요하게 파고들어 좀 더 나은 방안을 모색하고 소개하고자 합니다.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;오랜만입니다&quot;&gt;&lt;a href=&quot;#오랜만입니다&quot; class=&quot;headerlink&quot; title=&quot;오랜만입니다!&quot;&gt;&lt;/a&gt;오랜만입니다!&lt;/h1&gt;&lt;p&gt;근 3년만에 블로그를 다시 열었습니다.&lt;br&gt;실무에서 작업하면서 맞딱뜨리는 이런저런 프론트엔드</summary>
      
    
    
    
    <category term="FE" scheme="http://roy-jung.github.io/categories/fe/"/>
    
    <category term="intro" scheme="http://roy-jung.github.io/categories/fe/intro/"/>
    
    
  </entry>
  
  <entry>
    <title>let과 var의 성능 비교</title>
    <link href="http://roy-jung.github.io/170110_let-vs-var-performance-compare/"/>
    <id>http://roy-jung.github.io/170110_let-vs-var-performance-compare/</id>
    <published>2017-01-10T09:26:03.000Z</published>
    <updated>2020-10-26T11:23:03.148Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/category-es.png"/><blockquote><p><code>if</code>, <code>for</code> 등의 block statement 외부에서 <code>let</code>으로 선언한 변수를 statement 내부에서 호출할 때에는 비용이 발생하기 때문에, 블록스코프의 영향을 받지 않는 <code>var</code>로 선언한 변수를 호출할 때보다 느리므로, 일반적으로 <code>var</code>를 쓰는 편이 낫다.</p></blockquote><p>라는 논지의 글을 읽었다. 정말로 그러한지 궁금하여 ES6의 <code>let</code>과 기존의 <code>var</code>의 성능 차이를 비교실험 해보면서 그 내용을 정리하여 포스팅한다.</p><!-- more  --><p>모든 테스트는 MacOS 10.11.6 에서 진행하였고, 테스트한 브라우저의 버전은 각 Chrome 55.0.2283.95, Firefox 50.1.0, Safari 10.0.2 이다.</p><h2 id="테스팅-방식"><a href="#테스팅-방식" class="headerlink" title="테스팅 방식"></a>테스팅 방식</h2><p>가급적 단순한 소스로 빠르게 테스트를 하기 위해, 테스팅 방법은 다음 함수를 이용하였다. 모든 테스트는 세 번씩 독립시행하였다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeCheck = <span class="function">(<span class="params">times, test</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="number">0</span>,</span><br><span class="line">    t1,</span><br><span class="line">    t2</span><br><span class="line">  <span class="keyword">while</span> (times-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    t1 = <span class="built_in">window</span>.performance.now()</span><br><span class="line">    test()</span><br><span class="line">    t2 = <span class="built_in">window</span>.performance.now()</span><br><span class="line">    res += t1 - t2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(test.name, res / times)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> compare = <span class="function">(<span class="params">times, ...tests</span>) =&gt;</span> &#123;</span><br><span class="line">  tests.forEach(<span class="function"><span class="params">test</span> =&gt;</span> timeCheck(times, test))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for문-내부에서-변수-선언"><a href="#for문-내부에서-변수-선언" class="headerlink" title="for문 내부에서 변수 선언"></a>for문 내부에서 변수 선언</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testVar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">10000</span>; i++</span>)</span> &#123; i * <span class="number">10</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testLet = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">10000</span>; i++</span>)</span> &#123; i * <span class="number">10</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">compare(<span class="number">100000</span>, testVar, testLet);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 결과 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Chrome</span></span><br><span class="line">testVar <span class="number">504.3849999997001</span></span><br><span class="line">testLet <span class="number">1814.029999999897</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">515.3349999994971</span></span><br><span class="line">testLet <span class="number">2168.7300000004616</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">512.150000000518</span></span><br><span class="line">testLet <span class="number">2162.0000000004075</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Firefox</span></span><br><span class="line">testVar <span class="number">377.39500000001044</span></span><br><span class="line">testLet <span class="number">392.5850000000137</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">369.3049999999894</span></span><br><span class="line">testLet <span class="number">362.095000000103</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">369.91000000006534</span></span><br><span class="line">testLet <span class="number">360.53500000012355</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Safari</span></span><br><span class="line">testVar <span class="number">660.6800000000158</span></span><br><span class="line">testLet <span class="number">7921.925000000066</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">636.9849999999497</span></span><br><span class="line">testLet <span class="number">8070.989999999889</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">659.1450000000623</span></span><br><span class="line">testLet <span class="number">8052.3949999999895</span></span><br></pre></td></tr></table></figure><ul><li>크롬 : 3~4배 정도의 성능차이가 보인다. var는 블록스코프에 제한되지 않으며 재선언시 기존 변수를 그대로 활용하는 반면, let은 for문의 블록스코프에 의해 iterating 과정에서 매 번 새로 선언되므로, 이러한 차이는 당연한 결과인 듯 하다.</li><li>파이어폭스 : 둘 사이에 차이가 없다. 블록스코프에 대한 성능최적화가 잘 이뤄진 것 같다.</li><li>사파리 : let의 성능 저하가 심각하다;;</li></ul><h2 id="for문-외부에서-변수-선언"><a href="#for문-외부에서-변수-선언" class="headerlink" title="for문 외부에서 변수 선언"></a>for문 외부에서 변수 선언</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testVar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"> ; i &lt;= <span class="number">10000</span>; i++</span>)</span> &#123; i * <span class="number">10</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testLet = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"> ; i &lt;= <span class="number">10000</span>; i++</span>)</span> &#123; i * <span class="number">10</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">compare(<span class="number">100000</span>, testVar, testLet);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 결과 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Chrome</span></span><br><span class="line">testVar <span class="number">567.7750000001979</span></span><br><span class="line">testLet <span class="number">562.8849999998911</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">552.2350000001934</span></span><br><span class="line">testLet <span class="number">556.7149999999783</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">580.739999999023</span></span><br><span class="line">testLet <span class="number">558.8600000011284</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Firefox</span></span><br><span class="line">testVar <span class="number">368.3499999999258</span></span><br><span class="line">testLet <span class="number">361.55000000003383</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">385.23500000002605</span></span><br><span class="line">testLet <span class="number">391.53000000022075</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">385.8400000003203</span></span><br><span class="line">testLet <span class="number">386.88999999985754</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Safari</span></span><br><span class="line">testVar <span class="number">671.9050000000643</span></span><br><span class="line">testLet <span class="number">680.2949999999109</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">649.0050000001429</span></span><br><span class="line">testLet <span class="number">677.1050000001269</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">644.2449999999953</span></span><br><span class="line">testLet <span class="number">678.655000000108</span></span><br></pre></td></tr></table></figure><p>세 브라우저 모두 엎치락 뒤치락 한다. 유의미한 차이가 있다고 보기는 힘들다.<br>그러나 이론상 이 테스트는 동등한 조건의 비교가 아니다. let의 경우 for문 내부의 블록스코프로 인해 내부에서는 스코프 외부의 변수를 호출하는 것이기 때문이다.</p><h2 id="var와-let의-혼용-비교"><a href="#var와-let의-혼용-비교" class="headerlink" title="var와 let의 혼용 비교"></a>var와 let의 혼용 비교</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testVar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"> ; i &lt;= <span class="number">10000</span>; i++</span>)</span> &#123; sum += i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testLet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"> ; i &lt;= <span class="number">10000</span>; i++</span>)</span> &#123; sum += i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testVarAndLet1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"> ; i &lt;= <span class="number">10000</span>; i++</span>)</span> &#123; sum += i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testVarAndLet2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"> ; i &lt;= <span class="number">10000</span>; i++</span>)</span> &#123; sum += i; &#125;</span><br><span class="line">&#125;</span><br><span class="line">compare(<span class="number">100000</span>, testVar, testLet, testVarAndLet1, testVarAndLet2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 결과 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Chrome</span></span><br><span class="line">testVar <span class="number">328.94750000005934</span></span><br><span class="line">testLet <span class="number">1971.6525000000265</span></span><br><span class="line">testVarAndLet1 <span class="number">329.54000000009637</span></span><br><span class="line">testVarAndLet2 <span class="number">1987.0774999999967</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">329.9424999997682</span></span><br><span class="line">testLet <span class="number">1938.6849999998158</span></span><br><span class="line">testVarAndLet1 <span class="number">337.06249999996726</span></span><br><span class="line">testVarAndLet2 <span class="number">1977.209999999879</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">332.9599999998718</span></span><br><span class="line">testLet <span class="number">1969.6900000002897</span></span><br><span class="line">testVarAndLet1 <span class="number">335.554999999782</span></span><br><span class="line">testVarAndLet2 <span class="number">1982.3450000001758</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Firefox</span></span><br><span class="line">testVar <span class="number">564.0900000000029</span></span><br><span class="line">testLet <span class="number">562.0799999999808</span></span><br><span class="line">testVarAndLet1 <span class="number">584.0799999999813</span></span><br><span class="line">testVarAndLet2 <span class="number">568.134999999998</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">554.6249999998327</span></span><br><span class="line">testLet <span class="number">575.6050000002069</span></span><br><span class="line">testVarAndLet1 <span class="number">564.4250000000866</span></span><br><span class="line">testVarAndLet2 <span class="number">576.765000000104</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">551.2000000002226</span></span><br><span class="line">testLet <span class="number">591.664999999859</span></span><br><span class="line">testVarAndLet1 <span class="number">592.3350000000064</span></span><br><span class="line">testVarAndLet2 <span class="number">575.719999999892</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Safari</span></span><br><span class="line">testVar <span class="number">1216.0200000000077</span></span><br><span class="line">testLet <span class="number">1213.5549999999967</span></span><br><span class="line">testVarAndLet1 <span class="number">2708.7750000000124</span></span><br><span class="line">testVarAndLet2 <span class="number">2705.750000000038</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">1196.7449999999117</span></span><br><span class="line">testLet <span class="number">1210.9099999998725</span></span><br><span class="line">testVarAndLet1 <span class="number">2687.62000000017</span></span><br><span class="line">testVarAndLet2 <span class="number">2707.380000000063</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">1201.1799999999712</span></span><br><span class="line">testLet <span class="number">1236.5599999998667</span></span><br><span class="line">testVarAndLet1 <span class="number">2702.5649999999005</span></span><br><span class="line">testVarAndLet2 <span class="number">2728.939999999857</span></span><br></pre></td></tr></table></figure><ul><li>크롬 : 흥미로운 결과이지만, 스코프에 따른 비용을 생각하면 당연한 결과일 수도 있겠다. for문 외부에서 let으로 선언한 <code>sum</code>에 for문 내부에서 접근하기 위해서는 블록스코프 체이닝을 한 단계 거쳐야 하기 때문에 비용이 발생한다는 것이다. 아마도 원글에서는 이 부분을 말하고자 했던 것 같다.</li><li>파이어폭스 : 네 가지 테스트에 대해 아무런 차이가 없다. 파이어폭스만 놓고 보자면 블록스코프 체이닝으로 인한 성능저하는 고려할 필요가 없을 것 같다.</li><li>사파리 : 특이하게 <code>var</code>만 사용한 경우나 <code>let</code>만 사용한 경우엔 성능이 비슷한 반면, 혼용하면 느려진다. ES6전용엔진, ES5전용엔진, ES5 + ES6 엔진이 각각 마련되어 있으며, 혼용엔진의 성능이 좀 떨어지는 것이 아닐까 추측된다.</li></ul><h2 id="그렇다면-내장-메소드를-활용한다면-어떨까"><a href="#그렇다면-내장-메소드를-활용한다면-어떨까" class="headerlink" title="그렇다면 내장 메소드를 활용한다면 어떨까?"></a>그렇다면 내장 메소드를 활용한다면 어떨까?</h2><p>for문을 forEach로 대체한 경우와 reduce를 이용한 직접계산 방식을 테스트해보자.</p><h3 id="1-forEach로-전환"><a href="#1-forEach로-전환" class="headerlink" title="1. forEach로 전환"></a>1. forEach로 전환</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testVar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>).forEach(<span class="function">(<span class="params">v, i</span>) =&gt;</span> &#123; sum += i; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testLet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>).forEach(<span class="function">(<span class="params">v, i</span>) =&gt;</span> &#123; sum += i; &#125;);</span><br><span class="line">&#125;</span><br><span class="line">compare(<span class="number">10000</span>, testVar, testLet);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 결과 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Chrome</span></span><br><span class="line">testVar <span class="number">916.9325000000117</span></span><br><span class="line">testLet <span class="number">1261.5850000000355</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">918.6650000000309</span></span><br><span class="line">testLet <span class="number">1298.54500000001</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">884.2624999999607</span></span><br><span class="line">testLet <span class="number">1285.3525000000227</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Firefox</span></span><br><span class="line">testVar <span class="number">874.3749999999818</span></span><br><span class="line">testLet <span class="number">828.920000000031</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">800.085000000101</span></span><br><span class="line">testLet <span class="number">812.5499999999629</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">814.4299999999675</span></span><br><span class="line">testLet <span class="number">796.349999999984</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Safari</span></span><br><span class="line">testVar <span class="number">3708.769999999984</span></span><br><span class="line">testLet <span class="number">3811.210000000001</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">3771.770000000024</span></span><br><span class="line">testLet <span class="number">3784.889999999963</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">3831.679999999993</span></span><br><span class="line">testLet <span class="number">3850.014999999996</span></span><br></pre></td></tr></table></figure><p>for문으로 돌린 것보다 느려지는 것은 당연하다.</p><ul><li>크롬 : var가 살짝 빠르다. forEach로 같은 연산을 수행하기 위해서는 외부 스코프의 변수 <code>sum</code>을 갱신하여야 하는데, 이런 경우에는 <code>let</code>이 <code>var</code>보다 더 큰 비용을 필요로 하는 것으로 보인다.</li><li>Firefox : 동일한 성능을 보인다. 결국 브라우저의 최적화 정도에 따라 다른 결론이 나온다고 볼 수밖에 없겠다.</li><li>사파리 : 테스트를 그만두고 싶다. 이걸 왜 하고 있는거지…? 앞으로는 사파리 테스트는 한 번만 진행하겠다.</li></ul><h3 id="2-reduce로-직접-계산"><a href="#2-reduce로-직접-계산" class="headerlink" title="2. reduce로 직접 계산"></a>2. reduce로 직접 계산</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testVar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>).reduce(<span class="function">(<span class="params">a, b, i</span>) =&gt;</span> a + i, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testLet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>).reduce(<span class="function">(<span class="params">a, b, i</span>) =&gt;</span> a + i, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">compare(<span class="number">10000</span>, testVar, testLet);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 결과 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Chrome</span></span><br><span class="line">testVar <span class="number">904.6750000000009</span></span><br><span class="line">testLet <span class="number">915.0900000000024</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">903.6025000000136</span></span><br><span class="line">testLet <span class="number">892.7199999999839</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">891.3525000000091</span></span><br><span class="line">testLet <span class="number">882.7275000000318</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Firefox</span></span><br><span class="line">testVar <span class="number">710.5149999999967</span></span><br><span class="line">testLet <span class="number">737.0249999999924</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">708.6700000000383</span></span><br><span class="line">testLet <span class="number">744.3350000000064</span></span><br><span class="line"></span><br><span class="line">testVar <span class="number">710.0099999999929</span></span><br><span class="line">testLet <span class="number">730.4449999999615</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Safari</span></span><br><span class="line">testVar <span class="number">4057.314999999999</span></span><br><span class="line">testLet <span class="number">4090.555000000005</span></span><br></pre></td></tr></table></figure><p>한편 reduce를 이용하면 메소드 내부에서 외부 스코프의 변수를 호출할 일이 없으므로 상대적으로 매우 양호한 성능을 보이며, <code>let</code>과 <code>var</code> 사이의 차이는 없는 것으로 확인된다.<br>이러한 차이에 대해 보다 자세히 확인하기 전에, 변인을 통제하기 위해 스코프 자체의 생성 비용을 먼저 확인해볼 필요가 있을 것 같다.</p><h2 id="내부-스코프가-없는-경우-vs-즉시실행함수-vs-블록스코프"><a href="#내부-스코프가-없는-경우-vs-즉시실행함수-vs-블록스코프" class="headerlink" title="내부 스코프가 없는 경우 vs. 즉시실행함수 vs. 블록스코프"></a>내부 스코프가 없는 경우 vs. 즉시실행함수 vs. 블록스코프</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testNoScopeVar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>).fill(<span class="number">0</span>).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testNoScopeLet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>).fill(<span class="number">0</span>).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testFunctionScope = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>).fill(<span class="number">0</span>).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testBlockScope = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>).fill(<span class="number">0</span>).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">compare(<span class="number">100000</span>, testNoScopeVar, testNoScopeLet, testFunctionScope, testBlockScope);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 결과 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Chrome</span></span><br><span class="line">testNoScopeVar <span class="number">1601.9000000000224</span></span><br><span class="line">testNoScopeLet <span class="number">1586.9125000000586</span></span><br><span class="line">testFunctionScope <span class="number">1588.4724999999517</span></span><br><span class="line">testBlockScope <span class="number">1582.192499999961</span></span><br><span class="line"></span><br><span class="line">testNoScopeVar <span class="number">1594.0849999999155</span></span><br><span class="line">testNoScopeLet <span class="number">1593.0999999999785</span></span><br><span class="line">testFunctionScope <span class="number">1706.752500000075</span></span><br><span class="line">testBlockScope <span class="number">1641.9625000000942</span></span><br><span class="line"></span><br><span class="line">testNoScopeVar <span class="number">1670.175000000112</span></span><br><span class="line">testNoScopeLet <span class="number">1708.109999999855</span></span><br><span class="line">testFunctionScope <span class="number">1678.099999999955</span></span><br><span class="line">testBlockScope <span class="number">1670.0550000006842</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Firefox</span></span><br><span class="line">testNoScopeVar <span class="number">2152.220000000035</span></span><br><span class="line">testNoScopeLet <span class="number">2145.2300000000196</span></span><br><span class="line">testFunctionScope <span class="number">2198.4799999999686</span></span><br><span class="line">testBlockScope <span class="number">2163.9349999999777</span></span><br><span class="line"></span><br><span class="line">testNoScopeVar <span class="number">2211.5000000000255</span></span><br><span class="line">testNoScopeLet <span class="number">2295.075000000037</span></span><br><span class="line">testFunctionScope <span class="number">2262.6200000000536</span></span><br><span class="line">testBlockScope <span class="number">2184.70499999994</span></span><br><span class="line"></span><br><span class="line">testNoScopeVar <span class="number">2263.599999999693</span></span><br><span class="line">testNoScopeLet <span class="number">2202.645000000368</span></span><br><span class="line">testFunctionScope <span class="number">2303.4850000000224</span></span><br><span class="line">testBlockScope <span class="number">2238.1649999999863</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Safari</span></span><br><span class="line">testNoScopeVar <span class="number">1201.3650000000011</span></span><br><span class="line">testNoScopeLet <span class="number">1180.3599999999997</span></span><br><span class="line">testFunctionScope <span class="number">1215.030000000006</span></span><br><span class="line">testBlockScope <span class="number">1207.0399999999972</span></span><br><span class="line"></span><br><span class="line">testNoScopeVar <span class="number">1201.0800000000418</span></span><br><span class="line">testNoScopeLet <span class="number">1217.4399999999187</span></span><br><span class="line">testFunctionScope <span class="number">1215.8149999999368</span></span><br><span class="line">testBlockScope <span class="number">1200.325000000099</span></span><br><span class="line"></span><br><span class="line">testNoScopeVar <span class="number">1202.5349999998944</span></span><br><span class="line">testNoScopeLet <span class="number">1195.4449999999779</span></span><br><span class="line">testFunctionScope <span class="number">1192.2499999997235</span></span><br><span class="line">testBlockScope <span class="number">1196.464999999982</span></span><br></pre></td></tr></table></figure><p>기존까지의 테스트와 달리 이번 테스트는 파이어폭스가 가장 느리게 나왔으며, 사파리의 약진이 돋보여 한 번만 하겠다는 다짐을 깨고 세 번 돌려보았다.<br>놀랍게도 세 브라우저 모두 스코프 생성 자체는 성능상에 거의 아무런 영향을 주지 않는 것으로 확인된다. 혹시 스코프를 한 번만 생성했기 때문에 영향이 없었던 것은 아닐까? 스코프를 잔뜩 생성해서 테스트 해보자.</p><h2 id="스코프를-1000회-생성"><a href="#스코프를-1000회-생성" class="headerlink" title="스코프를 1000회 생성"></a>스코프를 1000회 생성</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testFunctionScope = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>).fill(<span class="number">0</span>).forEach(<span class="function"><span class="params">_</span>=&gt;</span> &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>).fill(<span class="number">0</span>).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;)();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testBlockScope = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>).fill(<span class="number">0</span>).forEach(<span class="function"><span class="params">_</span>=&gt;</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>).fill(<span class="number">0</span>).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">compare(<span class="number">1000</span>, testFunctionScope, testBlockScope);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 결과 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Chrome</span></span><br><span class="line">testFunctionScope <span class="number">16264.852499999985</span></span><br><span class="line">testBlockScope <span class="number">15813.532500000016</span></span><br><span class="line"></span><br><span class="line">testFunctionScope <span class="number">16406.502499999522</span></span><br><span class="line">testBlockScope <span class="number">16261.40749999987</span></span><br><span class="line"></span><br><span class="line">testFunctionScope <span class="number">16506.43499999994</span></span><br><span class="line">testBlockScope <span class="number">16097.730000000083</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Firefox</span></span><br><span class="line">testFunctionScope <span class="number">21992.190000000028</span></span><br><span class="line">testBlockScope <span class="number">21433.97000000001</span></span><br><span class="line"></span><br><span class="line">testFunctionScope <span class="number">21121.65000000008</span></span><br><span class="line">testBlockScope <span class="number">21132.1000000005</span></span><br><span class="line"></span><br><span class="line">testFunctionScope <span class="number">22201.30000000063</span></span><br><span class="line">testBlockScope <span class="number">21140.65000000017</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Safari</span></span><br><span class="line">testFunctionScope <span class="number">11941.540000000026</span></span><br><span class="line">testBlockScope <span class="number">11820.930000000008</span></span><br><span class="line"></span><br><span class="line">testFunctionScope <span class="number">12206.484999999979</span></span><br><span class="line">testBlockScope <span class="number">12454.840000000018</span></span><br><span class="line"></span><br><span class="line">testFunctionScope <span class="number">12273.975000000224</span></span><br><span class="line">testBlockScope <span class="number">12344.614999999932</span></span><br></pre></td></tr></table></figure><p>이정도면 블록스코프와 즉시실행함수의 속도차이는 없다고 보아야 할 것이다. 그렇다면 이제 <code>let</code>과 <code>var</code>가 외부 스코프의 변수를 갱신하는 데에 드는 비용을 확인해볼 수 있겠다. Safari에 대해 안좋게 평가했던 내 자신을 반성한다.</p><h2 id="외부스코프에-대한-비용-비교-1"><a href="#외부스코프에-대한-비용-비교-1" class="headerlink" title="외부스코프에 대한 비용 비교 - 1"></a>외부스코프에 대한 비용 비교 - 1</h2><p>반복을 위한 함수선언 자체가 새로운 스코프를 만들게 되므로, 이런 변인을 통제(새로운 스코프 형성 없이 테스트)하기 위해 무식한 소스를 작성해보았다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testFunctionScopeVar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;)();</span><br><span class="line">  sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;)();</span><br><span class="line">  sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;)();</span><br><span class="line">  sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;)();</span><br><span class="line">  sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testFunctionScopeLet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;)();</span><br><span class="line">  sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;)();</span><br><span class="line">  sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;)();</span><br><span class="line">  sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;)();</span><br><span class="line">  sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testBlockScopeVar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  &#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;</span><br><span class="line">  sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  &#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;</span><br><span class="line">  sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  &#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;</span><br><span class="line">  sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  &#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;</span><br><span class="line">  sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  &#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testBlockScopeLet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  &#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;</span><br><span class="line">  sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  &#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;</span><br><span class="line">  sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  &#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;</span><br><span class="line">  sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  &#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;</span><br><span class="line">  sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  &#123; sum = sum.join(<span class="string">&#x27;&#x27;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compare(<span class="number">1000</span>, testFunctionScopeVar, testFunctionScopeLet, testBlockScopeVar, testBlockScopeLet);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 결과 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Chrome</span></span><br><span class="line">testFunctionScopeVar <span class="number">798.4200000000856</span></span><br><span class="line">testFunctionScopeLet <span class="number">781.6874999999345</span></span><br><span class="line">testBlockScopeVar <span class="number">786.3724999999904</span></span><br><span class="line">testBlockScopeLet <span class="number">779.984999999986</span></span><br><span class="line"></span><br><span class="line">testFunctionScopeVar <span class="number">798.8450000002049</span></span><br><span class="line">testFunctionScopeLet <span class="number">850.8949999999168</span></span><br><span class="line">testBlockScopeVar <span class="number">860.9525000000867</span></span><br><span class="line">testBlockScopeLet <span class="number">822.717499999897</span></span><br><span class="line"></span><br><span class="line">testFunctionScopeVar <span class="number">829.2199999999721</span></span><br><span class="line">testFunctionScopeLet <span class="number">821.3075000001991</span></span><br><span class="line">testBlockScopeVar <span class="number">856.947499999922</span></span><br><span class="line">testBlockScopeLet <span class="number">799.0949999999866</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Firefox</span></span><br><span class="line">testFunctionScopeVar <span class="number">939.735000000006</span></span><br><span class="line">testFunctionScopeLet <span class="number">13033.770000000011</span></span><br><span class="line">testBlockScopeVar <span class="number">13230.579999999976</span></span><br><span class="line">testBlockScopeLet <span class="number">13146.650000000001</span></span><br><span class="line"></span><br><span class="line">testFunctionScopeVar <span class="number">13114.275000000023</span></span><br><span class="line">testFunctionScopeLet <span class="number">13361.729999999778</span></span><br><span class="line">testBlockScopeVar <span class="number">3324.755000000092</span></span><br><span class="line">testBlockScopeLet <span class="number">13032.479999999865</span></span><br><span class="line"></span><br><span class="line">testFunctionScopeVar <span class="number">13281.810000000201</span></span><br><span class="line">testFunctionScopeLet <span class="number">13104.510000000242</span></span><br><span class="line">testBlockScopeVar <span class="number">13282.044999999867</span></span><br><span class="line">testBlockScopeLet <span class="number">13141.575000000244</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Safari</span></span><br><span class="line">testFunctionScopeVar <span class="number">631.1549999999843</span></span><br><span class="line">testFunctionScopeLet <span class="number">623.5099999999984</span></span><br><span class="line">testBlockScopeVar <span class="number">641.4000000000196</span></span><br><span class="line">testBlockScopeLet <span class="number">622</span></span><br><span class="line"></span><br><span class="line">testFunctionScopeVar <span class="number">661.0600000000013</span></span><br><span class="line">testFunctionScopeLet <span class="number">652.924999999992</span></span><br><span class="line">testBlockScopeVar <span class="number">630.9400000000023</span></span><br><span class="line">testBlockScopeLet <span class="number">644.5299999999916</span></span><br><span class="line"></span><br><span class="line">testFunctionScopeVar <span class="number">658.5400000000045</span></span><br><span class="line">testFunctionScopeLet <span class="number">652.0749999999971</span></span><br><span class="line">testBlockScopeVar <span class="number">645.9750000000058</span></span><br><span class="line">testBlockScopeLet <span class="number">644.9399999999987</span></span><br></pre></td></tr></table></figure><p>이상하다. 앞서 테스트에서는 분명 블록스코프를 형성하는 for문에서 외부스코프에 접근할 때에 비용 차이가 있었는데, 이번에는 그 차이가 전혀 보이지 않는다. for문을 가지고 다른 변인통제장치를 마련하여 다시 한 번 테스트 해보자. ( 파이어폭스가 잠깐 넋이 나간걸까… ? )</p><h2 id="외부스코프에-대한-비용-비교-2-for문"><a href="#외부스코프에-대한-비용-비교-2-for문" class="headerlink" title="외부스코프에 대한 비용 비교 - 2. for문"></a>외부스코프에 대한 비용 비교 - 2. for문</h2><p>for문은 자체적으로 블록스코프를 형성하므로, 블록스코프와 즉시실행함수의 성능 차이가 거의 없다는 전제하에 var에 대해서도 let과 마찬가지로 외부스코프의 변수에 접근하게끔 for문 내부에 즉시실행함수를 넣어보았다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testVarNoScope = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i = <span class="number">0</span> ; i &lt;= <span class="number">10000</span>; i++</span>)</span> &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testVar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i = <span class="number">0</span> ; i &lt;= <span class="number">10000</span>; i++</span>)</span> &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; sum += i; &#125;)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testLet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span> ; i &lt;= <span class="number">10000</span>; i++</span>)</span> &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testLetWithFunctionScope = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span> ; i &lt;= <span class="number">10000</span>; i++</span>)</span> &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; sum += i; &#125;)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testLetWithBlockScope = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span> ; i &lt;= <span class="number">10000</span>; i++</span>)</span> &#123;</span><br><span class="line">    &#123; sum += i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">compare(<span class="number">10000</span>, testVarNoScope, testVar, testLet, testLetWithFunctionScope, testLetWithBlockScope);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 결과 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Chrome</span></span><br><span class="line">testVarNoScope <span class="number">35.77249999992273</span></span><br><span class="line">testVar <span class="number">1163.234999999855</span></span><br><span class="line">testLet <span class="number">504.2325000000492</span></span><br><span class="line">testLetWithFunctionScope <span class="number">4295.67250000003</span></span><br><span class="line">testLetWithBlockScope <span class="number">500.6700000000783</span></span><br><span class="line"></span><br><span class="line">testVarNoScope <span class="number">36.612500000046566</span></span><br><span class="line">testVar <span class="number">1221.842499999766</span></span><br><span class="line">testLet <span class="number">518.9699999999648</span></span><br><span class="line">testLetWithFunctionScope <span class="number">4509.729999999974</span></span><br><span class="line">testLetWithBlockScope <span class="number">549.4775000002774</span></span><br><span class="line"></span><br><span class="line">testVarNoScope <span class="number">36.07249999981286</span></span><br><span class="line">testVar <span class="number">1247.2349999999278</span></span><br><span class="line">testLet <span class="number">518.7849999999453</span></span><br><span class="line">testLetWithFunctionScope <span class="number">4420.822500000126</span></span><br><span class="line">testLetWithBlockScope <span class="number">504.9025000000038</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Firefox</span></span><br><span class="line">testVarNoScope <span class="number">55.274999999963256</span></span><br><span class="line">testVar <span class="number">76.43499999997948</span></span><br><span class="line">testLet <span class="number">55.2449999999626</span></span><br><span class="line">testLetWithFunctionScope <span class="number">42008.84499999993</span></span><br><span class="line">testLetWithBlockScope <span class="number">52.959999999948195</span></span><br><span class="line"></span><br><span class="line">testVarNoScope <span class="number">55.64499999990221</span></span><br><span class="line">testVar <span class="number">222.23999999988882</span></span><br><span class="line">testLet <span class="number">51.19499999989057</span></span><br><span class="line">testLetWithFunctionScope <span class="number">40998.735000000204</span></span><br><span class="line">testLetWithBlockScope <span class="number">52.89000000010128</span></span><br><span class="line"></span><br><span class="line">testVarNoScope <span class="number">54.12999999962631</span></span><br><span class="line">testVar <span class="number">225.33499999943888</span></span><br><span class="line">testLet <span class="number">51.91500000018277</span></span><br><span class="line">testLetWithFunctionScope <span class="number">42197.229999999894</span></span><br><span class="line">testLetWithBlockScope <span class="number">52.25500000020838</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Safari</span></span><br><span class="line">testVarNoScope <span class="number">119.68999999999824</span></span><br><span class="line">testVar <span class="number">2372.4249999999956</span></span><br><span class="line">testLet <span class="number">837.6250000000036</span></span><br><span class="line">testLetWithFunctionScope <span class="number">3112.0200000000023</span></span><br><span class="line">testLetWithBlockScope <span class="number">847.4800000000105</span></span><br><span class="line"></span><br><span class="line">testVarNoScope <span class="number">112.06999999999607</span></span><br><span class="line">testVar <span class="number">2435.275000000034</span></span><br><span class="line">testLet <span class="number">832.6699999999837</span></span><br><span class="line">testLetWithFunctionScope <span class="number">3124.41</span></span><br><span class="line">testLetWithBlockScope <span class="number">843.8000000000211</span></span><br><span class="line"></span><br><span class="line">testVarNoScope <span class="number">116.38000000001557</span></span><br><span class="line">testVar <span class="number">2436.8349999999846</span></span><br><span class="line">testLet <span class="number">876.3200000000943</span></span><br><span class="line">testLetWithFunctionScope <span class="number">3205.7199999999684</span></span><br><span class="line">testLetWithBlockScope <span class="number">875.5450000000201</span></span><br></pre></td></tr></table></figure><ul><li>크롬 : 스코프가 전혀 중첩되지 않은 첫번째의 결과가 가장 뛰어나고, 그 다음으로는 블록스코프 하나(for문 자체)로 이루어진 세번째 및 블록스코프 둘(for문 자체 + 내부)로 이루어진 다섯번째 결과가 동일한 성능을 보이고 있다. 반면 즉시실행함수는 상당한 비용을 소모하는 것으로 확인된다. 네번째 결과가 훨씬 높게 나타난 이유는 두번째와 비교해 스코프 중첩이 한 번 더 있기 때문이 아닐까 추측된다.</li><li>파이어폭스 : 스코프가 없는 상태의 <code>var</code>(testVarNoScope)보다도 블록스코프가 있는 상태(for)의 <code>let</code>의 결과(testLet)가 더욱 좋은 성능을 발휘한다. 모든 면에서 ES5 이하의 기능으로 구현한 소스보다 ES6에서 추가된 기능들이 더욱 좋은 성능을 보인다.</li><li>사파리 : 크롬보다는 좀더 빠른 성능을 보이고 있는데, 결과 사이의 상대적 차이는 크롬과 비슷하다.</li></ul><p>이 테스트는 영 개운치 않다. 앞선 테스트에서는 블록스코프와 즉시실행함수 사이에 성능차이가 없었는데, for문 내부에서 호출한 즉시실행함수 만큼은 모든 브라우저에서 현저히 느리다.</p><h2 id="let이나-const-선언이-없다면-블록스코프가-생성되지-않는가"><a href="#let이나-const-선언이-없다면-블록스코프가-생성되지-않는가" class="headerlink" title="let이나 const 선언이 없다면 블록스코프가 생성되지 않는가?"></a><code>let</code>이나 <code>const</code> 선언이 없다면 블록스코프가 생성되지 않는가?</h2><p>tc39의 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-lexical-environments">ECMAScript2015 Specfication - Lexical Environments</a>는 다음과 같이 기술하고 있다.</p><blockquote><p>A Lexical Environment is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. (중략) Usually a Lexical Environment is associated with some specific syntactic structure of ECMAScript code such as a FunctionDeclaration, a BlockStatement, or a Catch clause of a TryStatement and a new Lexical Environment is created each time such code is evaluated.</p><blockquote><p>(발번역 주의) 렉시컬 환경은 ECMAScript 코드의 렉시컬 중첩구조를 기반으로 식별자(identifier)와 특정 변수 및 함수와의 연관성을 정의하기 위한 스펙 유형이다. 렉시컬 환경은 일반적으로 <code>Function Declaration</code>, <code>Block Statement</code>, <code>try</code>구문의 <code>catch</code> 절과 같은 ECMAScript 코드의 특정 구문 구조와 연결되며, 이러한 코드가 평가될 때마다 새로운 렉시컬 환경이 생성된다.</p></blockquote></blockquote><p>즉 ‘block statement’가 평가될 때마다 새로운 렉시컬 환경이 생성되며, 이 때 블록스코프가 생성되는 것으로 보아야 할 것이다. let이나 const 선언 유무와 무관하게 블록스코프는 무조건 형성된다. 기존의 함수 내부에 <code>var</code> 변수를 선언하든 하지 않든 함수스코프가 생성되는 것에는 어떠한 영향도 주지 않는 것과 마찬가지로 말이다.</p><h2 id="요약-및-결론"><a href="#요약-및-결론" class="headerlink" title="요약 및 결론"></a>요약 및 결론</h2><ul><li><p>각 브라우저별로 상황에 따라 상대적으로 빠른 연산을 수행하기도 하고 반대로 매우 느리게 처리하기도 하는 등, 성능이 다 다르다. 테스트 결과 특별히 어느 브라우저가 제일 뛰어나다는 판단은 내릴 수 없겠다.</p></li><li><p>블록스코프와 즉시실행함수 자체의 비용 차이는 크지 않은 것으로 확인되었다.</p></li><li><p>다만 for문 내부에 즉시실행함수를 삽입할 경우에는 모든 브라우저에서 매우 느리게 동작한다.</p></li><li><p>스코프체이닝으로 외부 변수에 엑세스할 때의 비용 역시 <code>var</code>와 <code>let</code>이 큰 차이를 보이지 않는다. 다만 파이어폭스의 경우 let이 var보다도 조금 더 빠른 성능을 보이고, 사파리의 경우 둘을 함께 쓸 경우 배로 느려진다.</p></li><li><p><code>if</code>나 <code>for</code>처럼 그 자체가 블록스코프를 지니는 경우, 그 중에서도 block statement 외부의 변수를 내부에서 사용하는 경우에는, 크롬 및 사파리의 경우 <code>var</code>를 활용하는 편이 더 좋은 성능을 발휘하는 반면, 파이어폭스는 <code>let</code>을 그대로 사용하는 편이 더 낫다.</p></li><li><p>스코프 체이닝을 최소화하는 것이 좋다는 것은 당연한 상식이다. 그러나 이는 어디까지나 이론상 그렇다는 것이고, 테스트 결과 엔진 내부 로직에 따라(어떻게 구현되었는지는 모르겠지만 아무튼) 블록스코프가 성능에 거의 영향을 주지 않는 경우도 있는 것으로 확인된다(파이어폭스).</p></li><li><p><em>일반적인 경우 var 변수가 더 효율적</em> 인지 여부는 <strong>브라우저마다, 상황마다 다르다</strong>. 기존의 코딩스타일 안에서 새로운 문법시스템을 판단하는 것 자체가 잘못된 접근일 수 있다는 생각도 든다. 기왕 블록스코프가 도입된 이상 블록스코프 내에서 독립적으로 처리할 방안(<code>reduce</code> 등)을 고민하고, 마땅한 수단이 없는 경우에 한해 부득이 외부 변수를 호출하되, <code>var</code>를 쓸지 <code>let</code>을 쓸지는 타겟 브라우저에 따라 판단해야 할 것 같다.</p></li><li><p>불과 1년 전 <code>var와 let의 성능비교</code> 테스트에 대한 블로그 포스팅을 읽은 적이 있는데, 당시에는 <code>var</code>가 <code>let</code>보다 압도적으로 빠르게 연산을 수행했던 것으로 기억한다. 그 1년 사이 둘의 성능은 같아졌다. 그만큼 최적화가 이루어져왔었기 때문이다. 그렇다면 앞서 확인했던 외부스코프에 대한 접근 성능 역시 점차 최적화가 될 것이라 기대한다.</p></li><li><p>세 브라우저가 각각의 상황에서 저마다 다른 성능을 보여주었다. 즉 최적화가 얼마나 어떻게 진행되었는지에 따라 성능은 얼마든지 달라질 수 있는 문제이며, 현재의 결론이 1년 뒤에는 또 어떻게 달라질지도 모를 일이다.</p></li><li><p>개인적으로는 파이어폭스처럼 다른 브라우저들도 외부스코프에 대한 접근 성능이 충분히 최적화될 것이라 기대하면서 지금부터 그냥 <code>let</code>을 쓰겠다. 혼용하는 편이 더 헷갈림.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/category-es.png&quot;/&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; 등의 block statement 외부에서 &lt;code&gt;let&lt;/code&gt;으로 선언한 변수를 sta</summary>
      
    
    
    
    <category term="ECMAScript" scheme="http://roy-jung.github.io/categories/ecmascript/"/>
    
    
    <category term="ecmascript" scheme="http://roy-jung.github.io/tags/ecmascript/"/>
    
    <category term="javascript" scheme="http://roy-jung.github.io/tags/javascript/"/>
    
    <category term="es6" scheme="http://roy-jung.github.io/tags/es6/"/>
    
    <category term="es2015" scheme="http://roy-jung.github.io/tags/es2015/"/>
    
    <category term="let" scheme="http://roy-jung.github.io/tags/let/"/>
    
    <category term="var" scheme="http://roy-jung.github.io/tags/var/"/>
    
    <category term="scope" scheme="http://roy-jung.github.io/tags/scope/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript Proposals - ES2016 &amp; ES2017</title>
    <link href="http://roy-jung.github.io/161228_ecmascript-proposals-1-intro/"/>
    <id>http://roy-jung.github.io/161228_ecmascript-proposals-1-intro/</id>
    <published>2016-12-28T04:00:49.000Z</published>
    <updated>2020-10-26T11:22:11.382Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/category-es.png"/><p>tc39에서 진행하고 있는 ECMAScript의 다음 버전들 및 그 후보들을 알아본다.<br>그 중 본 글에서는 Stage 4(ES2016 및 ES2017에 새로 도입되기로 확정된 기능들)을 살펴보겠다.</p><a id="more"></a><p>&nbsp;</p><h1 id="ECMAScript-Proposals"><a href="#ECMAScript-Proposals" class="headerlink" title="ECMAScript Proposals?"></a>ECMAScript Proposals?</h1><p>ECMAScript2015(ES6)가 출범한지 어느덧 1년 반 여의 세월이 흘렀다.<br>그 사이 ECMAScript2016가 릴리즈 되었고(2016. 6.), 내년 중반에는 ES2017이 릴리즈될 예정이다.</p><blockquote><p>ECMAScript2015는 기존 ES3, ES5의 흐름에 따라 ES6로 부르기도 했으나, ECMAScript2016부터는 ‘해마다 표준이 추가됨’을 강조하고자 ES 뒤에 해당 년도를 붙인 것만을 정식 명칭으로 하기로 결정했다고 한다. 사실 ES6와 ES2015, ES7와 ES2016 등을 매칭하기엔 끝의 숫자가 하나씩 달라서 헷갈리던 참이었는데, 본 글을 읽는 독자분들께서도 정식 명칭을 사용하시면 원활한 의사소통을 위해서도 좋을 것 같다.</p></blockquote><p>javascript의 추가 제안사항들을 회의와 테스트를 거쳐 선별, 해마다 javascript 표준안을 정하는 단체인 <a href="http://www.ecma-international.org/memento/TC39.htm">tc39</a>는, 각 제안 내용을 0 ~ 4 단계로 분류하고 있다.</p><p></p><table><thead><tr><th align="center">Stage</th><th align="center">description</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">Strawman</td></tr><tr><td align="center">1</td><td align="center">Proposal</td></tr><tr><td align="center">2</td><td align="center">Draft</td></tr><tr><td align="center">3</td><td align="center">Candidate</td></tr><tr><td align="center">4</td><td align="center">Finished</td></tr></tbody></table><p><em>참고 : <a href="http://www.2ality.com/2015/11/tc39-process.html">2ality - The TC39 process for ECMAScript features</a></em></p><p>앞으로 연재 형태로 4단계부터 1단계까지에 걸쳐 제안된 기능들을 살펴보고자 한다.<br>본 글에서는 우선 Stage 4(ES2016 표준 및 ES2017 도입 예정안)를 살펴보겠다.</p><hr><p>&nbsp;</p><h2 id="Stage-4"><a href="#Stage-4" class="headerlink" title="Stage 4"></a>Stage 4</h2><p>표준안에 추가될 것이 결정된 내용. 이 단계의 제안들은 잠정적으로 다음 년도 ECMAScript 표준안에 도입될 것이나, 경우에 따라 연기될 가능성도 존재한다.<br>이미 ECMAScript 2016는 릴리즈된 상태이며, ECMAScript 2017에 도입될 내용도 거의 결정되었다. ES2016의 경우 대부분의 최신 모던브라우저에 기능 구현이 되어 있다.</p><!-- more --><p><em>(ES2016에 도입된 내용들이 아직도 Stage 4에 표기되어 있는 이유는… 단순히 업데이트를 안한 것일까?)</em></p><p>&nbsp;</p><h3 id="2016-Array-prototype-includes"><a href="#2016-Array-prototype-includes" class="headerlink" title="[2016] Array.prototype.includes"></a>[2016] Array.prototype.includes</h3><p><a href="https://github.com/tc39/Array.prototype.includes/">Array.prototype.includes</a></p><p>기존에는 배열 요소 중에 어떤 값이 있는지 여부를 확인하기 위해 다음과 같은 방식을 이용해왔다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) !== -<span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 방식은</p><ul><li>의미론적으로 와닿지 않는 방식이고,</li><li><code>NaN</code>을 제대로 판별할 수 없는 문제가 있다(<code>[NaN].indexOf(NaN) === -1</code>).</li></ul><p>이에 <code>Array.prototype.includes</code> 메소드가 ES2016 최종스펙에 도입되었다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.includes(value)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>)) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, -<span class="number">0</span>].includes(+<span class="number">0</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, +<span class="number">0</span>].includes(-<span class="number">0</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].includes(<span class="string">&#x27;a&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].includes(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="2016-Exponentiation-Operator"><a href="#2016-Exponentiation-Operator" class="headerlink" title="[2016] Exponentiation Operator **"></a>[2016] Exponentiation Operator <code>**</code></h3><p><a href="https://github.com/rwaldron/exponentiation-operator">Exponentiation Operator</a></p><p>다른 프로그래밍 언어들에서 일반적으로 사용되는 문법을 도입하였다.<br><code>x ** y</code>는 x의 y제곱을 의미하며, 이는 Math.pow(x, y)와 완전히 동일하다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number ** number</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">3</span>) === <span class="number">2</span> ** <span class="number">3</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> ** <span class="number">3</span>) <span class="comment">// 8 ( === 2 * 2 * 2 )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line">a **= <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 81 ( === a * a * a * a )</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span> ** -<span class="number">1</span> <span class="comment">// 0.1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.5</span> ** <span class="number">2</span> <span class="comment">// 6.25</span></span><br><span class="line"><span class="number">3</span> ** <span class="number">2.5</span> <span class="comment">// 15.588457268119896</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> ** (<span class="number">3</span> ** <span class="number">2</span>) <span class="comment">// 512</span></span><br><span class="line"><span class="number">2</span> **</span><br><span class="line">  ((<span class="number">3</span> ** <span class="number">2</span>)(</span><br><span class="line">    <span class="comment">// 512</span></span><br><span class="line">    <span class="number">2</span> ** <span class="number">3</span>,</span><br><span class="line">  ) **</span><br><span class="line">    <span class="number">2</span>) <span class="comment">// 64</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="2017-Object-values-Object-entries"><a href="#2017-Object-values-Object-entries" class="headerlink" title="[2017] Object.values / Object.entries"></a>[2017] Object.values / Object.entries</h3><p><a href="https://github.com/tc39/proposal-object-values-entries">Object.values / Object.entries</a></p><p>ES2015의 <code>Map</code>, <code>Set</code>, <code>Array</code> 등에는 <code>[Map/Set/Array].prototype.keys</code>, <code>[Map/Set/Array].prototype.values</code>, <code>[Map/Set/Array].prototype.entries</code>의 메소드가 있으며,<br>이 메소드들은 각각 이터레이터를 반환한다.<br>한편 <code>Object</code>에는 <code>Object.keys</code> 라는 스태틱 메소드(ES5)만이 존재하며, 결과는 이터레이터가 아닌 배열을 반환한다.</p><p>ES2015에서 추가된 타 데이터타입의 메소드들과의 형평성을 맞추면서 기존 ES5 문법과의 통일성을 유지하기 위해, Object에는 스태틱 메소드로 <code>values</code>와 <code>entries</code>를 추가할 예정이다.<br>각각 값으로만 구성된 배열, [키, 값]의 쌍으로 구성된 2차원배열을 반환한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(object)</span><br><span class="line"><span class="built_in">Object</span>.entries(obj)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)) <span class="comment">// [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)) <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)) <span class="comment">// [ [&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3] ]</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="2017-String-padding"><a href="#2017-String-padding" class="headerlink" title="[2017] String padding"></a>[2017] String padding</h3><p><a href="https://github.com/tc39/proposal-string-pad-start-end">String.prototype.padStart / String.prototype.padEnd</a></p><p>최대 길이보다 짧은 문자열에 대해서 그 여백에 지정한 문자열을 반복하여 채우는 메소드이다.<br>padStart는 문자열의 좌측에 여백을 지정하며, padEnd는 그 반대이다.<br>두 메소드 모두 <code>maxLength</code>보다 긴 문자열에 대해서는 동작하지 않는다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.padStart(maxLength[, padString])</span><br><span class="line"><span class="built_in">String</span>.prototype.padEnd(maxLength[, padString])</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">10</span>) <span class="comment">// &quot;       abc&quot;  (두번째 파라미터 생략시 빈 문자열로 채운다)</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;12&#x27;</span>) <span class="comment">// &quot;1212121abc&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">5</span>, <span class="string">&#x27;1234567&#x27;</span>) <span class="comment">// &quot;12abc&quot;</span></span><br><span class="line"><span class="string">&#x27;abcde&#x27;</span>.padStart(<span class="number">3</span>, <span class="string">&#x27;12&#x27;</span>) <span class="comment">// &quot;abcde&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padEnd(<span class="number">10</span>) <span class="comment">// &quot;abc       &quot;  (두번째 파라미터 생략시 빈 문자열로 채운다)</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padEnd(<span class="number">10</span>, <span class="string">&#x27;12&#x27;</span>) <span class="comment">// &quot;abc1212121&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padEnd(<span class="number">5</span>, <span class="string">&#x27;1234567&#x27;</span>) <span class="comment">// &quot;abc12&quot;</span></span><br><span class="line"><span class="string">&#x27;abcde&#x27;</span>.padEnd(<span class="number">3</span>, <span class="string">&#x27;12&#x27;</span>) <span class="comment">// &quot;abcde&quot;</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="2017-Object-getOwnPropertyDescriptors"><a href="#2017-Object-getOwnPropertyDescriptors" class="headerlink" title="[2017] Object.getOwnPropertyDescriptors"></a>[2017] Object.getOwnPropertyDescriptors</h3><p><a href="https://github.com/tc39/proposal-object-getownpropertydescriptors">Object.getOwnPropertyDescriptors</a></p><p>객체의 프로퍼티 속성들을 기술한 객체를 반환한다. <code>Object.defineProperties</code>의 활용도를 높이는 계기가 될 것으로 예상한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="built_in">Object</span>.getOwnPropertyDescriptors(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res.a)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   configurable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   value: 1,</span></span><br><span class="line"><span class="comment">//   writable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.assign</code>을 이용하면 원본 객체의 getter / setter 가 제대로 복사되지 않는 문제가 있었다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">a</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.b</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">a</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.a = <span class="number">10</span> <span class="comment">// 10 출력</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj)</span><br><span class="line">obj2.a = <span class="number">20</span> <span class="comment">// 출력 없음</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.a) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p><code>Object.getOwnPropertyDescriptors</code>를 이용하면 제대로 복사가 이뤄질 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj3 = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj))</span><br><span class="line">obj3.a = <span class="number">30</span> <span class="comment">// 30 출력</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3.a) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><em>참고 : <a href="http://www.2ality.com/2016/02/object-getownpropertydescriptors.html">2ality - ES proposal: Object.getOwnPropertyDescriptors()</a></em></p><p>&nbsp;</p><h3 id="2017-Trailing-commas-in-function-parameter-lists-and-calls"><a href="#2017-Trailing-commas-in-function-parameter-lists-and-calls" class="headerlink" title="[2017] Trailing commas in function parameter lists and calls"></a>[2017] Trailing commas in function parameter lists and calls</h3><p><a href="https://github.com/tc39/proposal-trailing-function-commas">Proposal to allow trailing commas in function parameter lists</a></p><p>함수 파라미터들 중 마지막 값 뒤에 찍힌 콤마를 오류로 잡지 않게 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure><p>이를 활용하면 다음과 같이 버전관리 도구 등에서 바뀐 내용을 보다 명확하게 확인할 수 있게 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이전 버전</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b)</span><br><span class="line">&#125;</span><br><span class="line">x(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 변경된 버전</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  a,</span></span></span><br><span class="line"><span class="function"><span class="params">  b, <span class="comment">// 변경사항 표시되지 않음.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  c, <span class="comment">// 새로 추가되었음이 표시됨.</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c) <span class="comment">// 변경사항 표시됨.</span></span><br><span class="line">&#125;</span><br><span class="line">x(</span><br><span class="line">  <span class="number">10</span>,</span><br><span class="line">  <span class="number">20</span>, <span class="comment">// 변경사항 표시되지 않음.</span></span><br><span class="line">  <span class="number">30</span>, <span class="comment">// 새로 추가되었음이 표시됨.</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="2017-Async-function"><a href="#2017-Async-function" class="headerlink" title="[2017] Async function"></a>[2017] Async function</h3><p><a href="https://github.com/tc39/ecmascript-asyncawait">Async Function</a></p><p>비동기 데이터처리를 간단한 방식으로 구현할 수 있게 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchJson</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// &#x27;async&#x27; 명령어로 비동기함수임을 명시.</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> request = <span class="keyword">await</span> fetch(url) <span class="comment">// fetch의 결과가 반환될 때까지 대기(&#x27;await&#x27;).</span></span><br><span class="line">    <span class="keyword">let</span> text = <span class="keyword">await</span> request.text() <span class="comment">// request.text() 값이 반환될 때 비로소 진행.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(text)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`ERROR: <span class="subst">$&#123;error.stack&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>표기법은 다음과 같다.</p><ul><li>비동기 함수 선언문 : <code>async function foo() &#123;&#125;</code></li><li>비동기 함수 표현식 : <code>const foo = async function () &#123;&#125;</code></li><li>비동기 메소드 정의 : <code>let obj = &#123; async foo() &#123;&#125; &#125;</code></li><li>비동기 화살표함수 정의 : <code>const foo = async () =&gt; &#123;&#125;</code></li></ul><p><em>참고: <a href="http://www.2ality.com/2016/02/async-functions.html">2ality - async functions</a></em></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;tc39에서 진행하고 있는 ECMAScript의 다음 버전들 및 그 후보들을 알아본다.&lt;br&gt;그 중 본 글에서는 Stage 4(ES2016 및 ES2017에 새로 도입되기로 확정된 기능들)을 살펴보겠다.&lt;/p&gt;</summary>
    
    
    
    <category term="ECMAScript" scheme="http://roy-jung.github.io/categories/ecmascript/"/>
    
    
  </entry>
  
  <entry>
    <title>ReactJS를 작성할 때에 알아두면 좋은 ES6 문법들</title>
    <link href="http://roy-jung.github.io/161128_es6-for-react/"/>
    <id>http://roy-jung.github.io/161128_es6-for-react/</id>
    <published>2016-11-28T02:04:00.000Z</published>
    <updated>2020-11-29T12:37:55.907Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/category-es.png"/><p>ReactJS를 작성할 때에 미리 알아두면 좋은 ES6 문법들을 소개한다.</p><a id="more"></a><h2 id="1-block-scope"><a href="#1-block-scope" class="headerlink" title="1. block scope"></a>1. block scope</h2><p>기존의 함수에 의한 스코프처럼 <code>&#123; &#125;</code>으로 감싼 내부에 별도의 스코프가 생성된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// (1)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// (3)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">  sum += j</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// (1)</span></span><br><span class="line"><span class="built_in">console</span>.log(j) <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="built_in">console</span>.log(j) <span class="comment">// (1)</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(j) <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(j) <span class="comment">// (3)</span></span><br></pre></td></tr></table></figure><h2 id="2-block-scoped-variables"><a href="#2-block-scoped-variables" class="headerlink" title="2. block scoped variables"></a>2. block scoped variables</h2><p><code>let</code>은 기존의 <code>var</code>를 대체하는 블락변수이고, <code>const</code>는 그 중 한 번 선언 및 정의되고 나면 값을 변경할 수 없는 변수이다.<br>블락 스코프 내부에서 선언된 <code>let</code>, <code>const</code>는 해당 스코프 내에서만 존재하며, 이들에 대해서는 ‘TDZ’가 존재한다.</p><blockquote><p><code>TDZ (temporal dead zone, 임시사각지대)</code> : 블락 스코프 내에서는 지역변수/상수에 대한 호이스팅이 이뤄지기는 하나, 선언된 위치 이전까지는 해당 변수/상수를 인식하지 못한다.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// (1)</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// (1)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a, <span class="built_in">window</span>.b) <span class="comment">// (2)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.a, <span class="built_in">this</span>.b) <span class="comment">// (3)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(j) <span class="comment">// (1)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.141593</span></span><br><span class="line">PI = <span class="number">3.14</span> <span class="comment">// (1)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OBJ = &#123;</span><br><span class="line">  prop1: <span class="number">1</span>,</span><br><span class="line">  prop2: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  prop3: &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.freeze(OBJ)</span><br><span class="line">OBJ.prop1 = <span class="number">3</span></span><br><span class="line">OBJ.prop2.push(<span class="number">5</span>)</span><br><span class="line">OBJ.prop3.b = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(OBJ) <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(OBJ.prop2)</span><br><span class="line">OBJ.prop2.push(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log(OBJ) <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">링크 : Object.freeze 및 deep freezing</a></p><h4 id="변수별-스코프-종속성"><a href="#변수별-스코프-종속성" class="headerlink" title="변수별 스코프 종속성"></a>변수별 스코프 종속성</h4><table><thead><tr><th align="center">variables \ scope</th><th align="center">function</th><th align="center">block</th><th align="center">hoisting</th><th align="center">TDZ</th></tr></thead><tbody><tr><td align="center">let</td><td align="center">O</td><td align="center">O</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">const</td><td align="center">O</td><td align="center">O</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">var</td><td align="center">O</td><td align="center">X</td><td align="center">O</td><td align="center">X</td></tr><tr><td align="center">function declaration</td><td align="center">O</td><td align="center">△</td><td align="center">O</td><td align="center">X</td></tr></tbody></table><blockquote><p>함수선언문의 경우 sloppy-mode 모드에서는 block-scope의 영향을 받지 않고, strict-mode에서는 block-scope의 영향을 받는다.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo()</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    foo()</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">;(<span class="string">&#x27;use strict&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  foo()</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    foo()</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><h2 id="3-arrow-function"><a href="#3-arrow-function" class="headerlink" title="3. arrow function"></a>3. arrow function</h2><p>순수 함수로서의 기능만을 담당하기 위해 간소화한 함수.<br><code>=&gt;</code>의 좌측엔 매개변수, 우측엔 return될 내용을 기입한다. 우측이 여러줄로 이루어져있다면 <code>&#123; &#125;</code>로 묶을 수 있으며, 이 경우엔 명시적으로 return을 기술하지 않으면 <code>undefined</code>가 반환된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getDate = <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line"><span class="keyword">let</span> getSquare = <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a * a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> calc = <span class="function">(<span class="params">method, a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;sum&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> a + b</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;sub&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> a - b</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;mul&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> a * b</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;div&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> a / b</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getDate())</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">console</span>.log(getSquare(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">console</span>.log(calc(<span class="string">&#x27;mul&#x27;</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  grades: [<span class="number">80</span>, <span class="number">90</span>, <span class="number">100</span>],</span><br><span class="line">  getTotal: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.total = <span class="number">0</span></span><br><span class="line">    <span class="built_in">this</span>.grades.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.total += v</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.getTotal()</span><br><span class="line"><span class="built_in">console</span>.log(obj.total) <span class="comment">// (1)</span></span><br></pre></td></tr></table></figure><h2 id="4-rest-parameter"><a href="#4-rest-parameter" class="headerlink" title="4. rest parameter"></a>4. rest parameter</h2><ul><li>함수 파라미터에 일정하지 않은 값들을 넘기고자 할 경우에 유용.</li><li>arguments의 대체.</li><li>배열의 얕은복사 목적으로 활용 가능.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, ...rest</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(rest) <span class="comment">// (1)</span></span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arg.length; i++) &#123;</span><br><span class="line">    result += arg[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* const sum = (...arg) =&gt; arg.reduce((p,c)=&gt; p+c); */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)) <span class="comment">// (1)</span></span><br></pre></td></tr></table></figure><h2 id="5-spread-operator"><a href="#5-spread-operator" class="headerlink" title="5. spread operator"></a>5. spread operator</h2><p>문자열의 각 단어, 배열의 요소들이나 객체의 프로퍼티들(stage-2 proposal)을 해체하여 여러개의 값으로 반환해준다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;lorem ipsum&#x27;</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">20</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line"><span class="built_in">console</span>.log(...arr) <span class="comment">// (1)</span></span><br><span class="line"><span class="built_in">console</span>.log([...str]) <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originalArray = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> copiedArray = [...originalArray]</span><br><span class="line"></span><br><span class="line">originalArray.push(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(originalArray) <span class="comment">// (1)</span></span><br><span class="line"><span class="built_in">console</span>.log(copiedArray) <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><h2 id="6-default-parameter"><a href="#6-default-parameter" class="headerlink" title="6. default parameter"></a>6. default parameter</h2><p>파라미터에 값을 할당하지 않거나 빈 값인 상태로 함수를 호출할 경우, 해당 파라미터를 지정한 기본값으로 인식하도록 해줌.<br>각 파라미터는 내부에서 let과 동일하게 동작하며, 따라서 TDZ가 존재한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y = <span class="number">2</span>, z = <span class="number">3</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y, z) <span class="comment">//(1)</span></span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">4</span>, <span class="literal">undefined</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x = y * <span class="number">3</span>, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x * y)</span><br><span class="line">&#125;</span><br><span class="line">multiply(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// (1)</span></span><br><span class="line">multiply(<span class="literal">undefined</span>, <span class="number">2</span>) <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><h2 id="7-Enhanced-Object-Literal"><a href="#7-Enhanced-Object-Literal" class="headerlink" title="7. Enhanced Object Literal"></a>7. Enhanced Object Literal</h2><h3 id="7-1-computed-property-key"><a href="#7-1-computed-property-key" class="headerlink" title="7-1. computed property key"></a>7-1. computed property key</h3><p>프로퍼티의 키값에 표현식을 지정할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> suffix = <span class="string">&#x27; name&#x27;</span></span><br><span class="line"><span class="keyword">const</span> iu = &#123;</span><br><span class="line">  [<span class="string">&#x27;last&#x27;</span> + suffix]: <span class="string">&#x27;이&#x27;</span>,</span><br><span class="line">  [<span class="string">&#x27;first&#x27;</span> + suffix]: <span class="string">&#x27;지은&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(iu) <span class="comment">// (1)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="string">&#x27;bar&#x27;</span> + foo()]: foo(),</span><br><span class="line">  [<span class="string">&#x27;bar&#x27;</span> + foo()]: foo(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// (1)</span></span><br></pre></td></tr></table></figure><h3 id="7-2-property-Shorthand"><a href="#7-2-property-Shorthand" class="headerlink" title="7-2. property Shorthand"></a>7-2. property Shorthand</h3><p>프로퍼티의 키와 값에 할당한 변수명이 동일한 경우, 키를 생략할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">10</span>,</span><br><span class="line">  y = <span class="number">20</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  x,</span><br><span class="line">  y,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// (1)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInformation</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    gender,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iu = setInformation(<span class="string">&#x27;아이유&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;female&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(iu) <span class="comment">// (1)</span></span><br></pre></td></tr></table></figure><h3 id="7-3-method-Shorthand"><a href="#7-3-method-Shorthand" class="headerlink" title="7-3. method Shorthand"></a>7-3. method Shorthand</h3><p>메서드명 뒤의 <code>: function</code> 키워드를 생략할 수 있게 되었다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">printName</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.getName())</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()) <span class="comment">// (1)</span></span><br><span class="line">obj.printName() <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><h3 id="7-4-Object-assign-ES5"><a href="#7-4-Object-assign-ES5" class="headerlink" title="7-4. Object.assign (ES5)"></a>7-4. <code>Object.assign</code> (ES5)</h3><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign()</a><br>첫 번째 파라미터의 객체에 두 번째 파라미터 및 그 이후의 각 객체들을 병합한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetObj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sourceObj = &#123;</span><br><span class="line">  b: <span class="number">4</span>,</span><br><span class="line">  d: <span class="number">5</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(targetObj, sourceObj)</span><br><span class="line"><span class="built_in">console</span>.log(targetObj, sourceObj) <span class="comment">// (1)</span></span><br></pre></td></tr></table></figure><p>이를 활용하면 객체 및 배열의 얕은 복사를 수행할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originalObj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  c: &#123; <span class="attr">d</span>: <span class="number">5</span>, <span class="attr">e</span>: <span class="number">6</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> copiedObj = <span class="built_in">Object</span>.assign(&#123;&#125;, originalObj)</span><br><span class="line">copiedObj.a = <span class="number">11</span></span><br><span class="line">copiedObj.b[<span class="number">0</span>] = <span class="number">12</span></span><br><span class="line">copiedObj.c.d = <span class="number">13</span></span><br><span class="line"><span class="built_in">console</span>.log(originalObj, copiedObj) <span class="comment">// (1)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originalObj = &#123;</span><br><span class="line">  a: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  b: &#123; <span class="attr">d</span>: <span class="number">5</span>, <span class="attr">e</span>: <span class="number">6</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> copiedObj = <span class="built_in">Object</span>.assign(&#123;&#125;, originalObj, &#123; <span class="attr">b</span>: &#123; <span class="attr">f</span>: <span class="number">7</span>, <span class="attr">g</span>: <span class="number">8</span> &#125; &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(copiedObj) <span class="comment">// (1)</span></span><br></pre></td></tr></table></figure><h2 id="8-Destructuring-Assignment"><a href="#8-Destructuring-Assignment" class="headerlink" title="8. Destructuring Assignment"></a>8. Destructuring Assignment</h2><p>배열 혹은 객체를 해체하여 각각 변수에 할당한다.</p><h4 id="1-배열"><a href="#1-배열" class="headerlink" title="1) 배열"></a>1) 배열</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, [b, [, c]], d] = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d) <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><h4 id="2-객체"><a href="#2-객체" class="headerlink" title="2) 객체"></a>2) 객체</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iu = &#123;</span><br><span class="line">  name: <span class="string">&#x27;아이유&#x27;</span>,</span><br><span class="line">  age: <span class="number">23</span>,</span><br><span class="line">  gender: <span class="string">&#x27;female&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: n, <span class="attr">age</span>: a, <span class="attr">gender</span>: g &#125; = iu</span><br><span class="line"><span class="built_in">console</span>.log(n, a, g) <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; name, age, gender &#125; = iu <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  name,</span><br><span class="line">  albums: &#123;</span><br><span class="line">    regular,</span><br><span class="line">    irregular: &#123; 꽃갈피: flower &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  name: <span class="string">&#x27;아이유&#x27;</span>,</span><br><span class="line">  albums: &#123;</span><br><span class="line">    regular: [<span class="string">&#x27;Growing up&#x27;</span>, <span class="string">&#x27;Last Fantasy&#x27;</span>, <span class="string">&#x27;Modern Times&#x27;</span>],</span><br><span class="line">    irregular: &#123;</span><br><span class="line">      Real: <span class="number">2013</span>,</span><br><span class="line">      꽃갈피: <span class="number">2015</span>,</span><br><span class="line">      CHAT_SHIRE: <span class="number">2016</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name, regular, flower) <span class="comment">// (3)</span></span><br></pre></td></tr></table></figure><h2 id="9-template-literals"><a href="#9-template-literals" class="headerlink" title="9. template literals"></a>9. template literals</h2><p>여러줄 문자열, 보간(표현식 삽입) 등을 지원하는 새로운 형태의 문자열.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`a</span></span><br><span class="line"><span class="string">bb</span></span><br><span class="line"><span class="string">ccc`</span>) <span class="comment">// (1)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">20</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a + b&#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.log(str) <span class="comment">// (1)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> characters = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;Aria Stark&#x27;</span>,</span><br><span class="line">    lines: [<span class="string">&#x27;A girl has no name.&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;John Snow&#x27;</span>,</span><br><span class="line">    lines: [<span class="string">&#x27;You know nothing, John Snow.&#x27;</span>, <span class="string">&#x27;Winter is coming.&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> html = characters.reduce(<span class="function">(<span class="params">prevCharacters, currentCaracter</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, lines &#125; = currentCaracter</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;prevCharacters&#125;</span>&lt;article&gt;</span></span><br><span class="line"><span class="string">  &lt;h1&gt;<span class="subst">$&#123;name&#125;</span>&lt;/h1&gt;</span></span><br><span class="line"><span class="string">  &lt;ul&gt;<span class="subst">$&#123;lines.reduce(</span></span></span><br><span class="line"><span class="string"><span class="subst">    (prevLines, currentLine) =&gt;</span></span></span><br><span class="line"><span class="string"><span class="subst">      <span class="string">`<span class="subst">$&#123;prevLines || <span class="string">&#x27;&#x27;</span>&#125;</span></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;li&gt;<span class="subst">$&#123;currentLine&#125;</span>&lt;/li&gt;`</span>,</span></span></span><br><span class="line"><span class="string"><span class="subst">    <span class="string">&#x27;&#x27;</span>,</span></span></span><br><span class="line"><span class="string"><span class="subst">  )&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/article&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">&#125;, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(html) <span class="comment">// (1)</span></span><br></pre></td></tr></table></figure><h2 id="10-class"><a href="#10-class" class="headerlink" title="10. class"></a>10. class</h2><p>Java의 그것과 비슷하지만 private 메서드가 없다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>, <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>세`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">logNames</span>(<span class="params">persons</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> person <span class="keyword">of</span> persons) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(person.name, person.age)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">logNames</span>(<span class="params">persons</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> person <span class="keyword">of</span> persons) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(person.name, person.age, person.title)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age, title</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age)</span><br><span class="line">    <span class="built_in">this</span>.title = title</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">super</span>.toString()&#125;</span>, (<span class="subst">$&#123;<span class="built_in">this</span>.title&#125;</span>)`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> park = <span class="keyword">new</span> Employee(<span class="string">&#x27;Park&#x27;</span>, <span class="number">35</span>, <span class="string">&#x27;CTO&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> jung = <span class="keyword">new</span> Employee(<span class="string">&#x27;Jung&#x27;</span>, <span class="number">30</span>, <span class="string">&#x27;CEO&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(park.toString()) <span class="comment">// (1)</span></span><br><span class="line">Person.logNames([park, jung]) <span class="comment">// (2)</span></span><br><span class="line">Employee.logNames([park, jung]) <span class="comment">// (3)</span></span><br></pre></td></tr></table></figure><h2 id="11-module-import-export"><a href="#11-module-import-export" class="headerlink" title="11. module - import / export"></a>11. module - import / export</h2><h3 id="1-without-‘default’-export"><a href="#1-without-‘default’-export" class="headerlink" title="1) without ‘default’ export"></a>1) without ‘default’ export</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------ lib.js ------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sqrt = <span class="built_in">Math</span>.sqrt</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------ main.js ------</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> lib <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(lib) <span class="comment">// (1)</span></span><br><span class="line"><span class="built_in">console</span>.log(lib.square(<span class="number">5</span>)) <span class="comment">// (2)</span></span><br><span class="line"><span class="built_in">console</span>.log(lib.sqrt(<span class="number">4</span>)) <span class="comment">// (3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* or */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; square, sqrt &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(square(<span class="number">5</span>)) <span class="comment">// (4)</span></span><br><span class="line"><span class="built_in">console</span>.log(sqrt(<span class="number">4</span>)) <span class="comment">// (5)</span></span><br></pre></td></tr></table></figure><h3 id="2-with-‘default’-export"><a href="#2-with-‘default’-export" class="headerlink" title="2) with ‘default’ export"></a>2) with ‘default’ export</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------ lib.js ------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">lib</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;this is lib default function&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sqrt = <span class="built_in">Math</span>.sqrt</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------ main.js ------</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> lib <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(lib.default()) <span class="comment">// (1)</span></span><br><span class="line"><span class="built_in">console</span>.log(lib.square(<span class="number">5</span>)) <span class="comment">// (2)</span></span><br><span class="line"><span class="built_in">console</span>.log(lib.sqrt(<span class="number">4</span>)) <span class="comment">// (3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* or */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lib, &#123; square, sqrt &#125; <span class="keyword">from</span> <span class="string">&#x27;lib&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(lib) <span class="comment">// (4)</span></span><br><span class="line"><span class="built_in">console</span>.log(square(<span class="number">5</span>)) <span class="comment">// (5)</span></span><br><span class="line"><span class="built_in">console</span>.log(sqrt(<span class="number">4</span>)) <span class="comment">// (6)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;ReactJS를 작성할 때에 미리 알아두면 좋은 ES6 문법들을 소개한다.&lt;/p&gt;</summary>
    
    
    
    <category term="ECMAScript" scheme="http://roy-jung.github.io/categories/ecmascript/"/>
    
    
    <category term="ecmascript" scheme="http://roy-jung.github.io/tags/ecmascript/"/>
    
    <category term="javascript" scheme="http://roy-jung.github.io/tags/javascript/"/>
    
    <category term="es6" scheme="http://roy-jung.github.io/tags/es6/"/>
    
    <category term="es2015" scheme="http://roy-jung.github.io/tags/es2015/"/>
    
    <category term="reactjs" scheme="http://roy-jung.github.io/tags/reactjs/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Class에서 private member를 정의하는 방법</title>
    <link href="http://roy-jung.github.io/161127_how-to-make-private-member/"/>
    <id>http://roy-jung.github.io/161127_how-to-make-private-member/</id>
    <published>2016-11-27T08:34:00.000Z</published>
    <updated>2020-10-26T11:22:47.175Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/category-es.png"/><p>es6의 class 문법에는 private data를 직접 지정할 수 있는 기능이 제공되지 않는다.<br>때문에 private data로 쓰고자 하는 변수는 우회적으로 관리하여야 하는데, 그 방법들을 소개한다.</p><a id="more"></a><hr><h2 id="1-naming-convention"><a href="#1-naming-convention" class="headerlink" title="1. naming convention _"></a>1. naming convention <code>_</code></h2><p>변수에 접두어 <code>_</code>를 붙이면 private data로 간주하기로 하는 규칙을 정하는 방법.</p><p>실질적인 접근제한은 전혀 이뤄지지 않는다.</p><h2 id="2-constructor-내부에서-할당"><a href="#2-constructor-내부에서-할당" class="headerlink" title="2. constructor 내부에서 할당"></a>2. <code>constructor</code> 내부에서 할당</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">_count</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> methods = &#123;</span><br><span class="line">      <span class="function"><span class="title">inc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        _count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> _count</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">dec</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        _count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> _count</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">getScore</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _count</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">get</span> <span class="title">score</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> _count</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span> <span class="title">score</span>(<span class="params">v</span>) &#123;</span><br><span class="line">        _count = v</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="built_in">this</span>, methods)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Count(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test.inc()) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(test.inc()) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(test.dec()) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(test.getScore()) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>이 방법은 constructor 내부에서만 접근 가능한 변수를 사용하는 모든 메소드를 constructor에서 정의하고,<br>이를 그대로 인스턴스에 반영하기 위해 <code>Object.assign</code> 메소드를 활용한다.<br>이로써 <code>_count</code> 변수는 값을 외부에 노출하지 않고 오직 내부에서만 접근이 가능해진다.</p><p>그러나 이는 메소드를 인스턴스에 직접 할당하는 것이므로,<br>메소드를 상속받아 사용하겠다는 Class의 본질적인 사용 의미를 무색케 만드는 셈이다.<br>또한 delete로 메소드를 삭제할 수도 있고, 메소드를 override가 아닌 완전한 대체를 할 수도 있다.</p><p>뿐만 아니라 <code>getter/setter</code>는 별도의 데이터(<code>this.score</code>)에 접근하는 등의 문제도 있다<br>(원인은 모르겠다. 아시는 분은 댓글 부탁드립니다).</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(test.score) <span class="comment">// 0</span></span><br><span class="line">test.score = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(test.score) <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(test.getScore()) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>한편 method를 모두 <code>this.constructor.prototype</code>에 할당한다면 _count 변수를 공통으로 사용하는 결과가 되므로,<br>각 인스턴스들의 독립성이 보장되지 않게 되어 마찬가지로 Class를 사용하는 의미가 없다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">_count</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> methods = &#123;</span><br><span class="line">      <span class="function"><span class="title">inc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        _count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> _count</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">dec</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        _count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> _count</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">getScore</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _count</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">get</span> <span class="title">score</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> _count</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span> <span class="title">score</span>(<span class="params">v</span>) &#123;</span><br><span class="line">        _count = v</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="built_in">this</span>.constructor.prototype, methods)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test1 = <span class="keyword">new</span> Count(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> test2 = <span class="keyword">new</span> Count(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test1.inc()) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(test1.inc()) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(test1.getScore()) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(test2.getScore()) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>이래저래 변수보호를 위해 잃는 것이 너무 많은 방법. 비추천.</p><h2 id="3-Symbol-활용"><a href="#3-Symbol-활용" class="headerlink" title="3. Symbol 활용"></a>3. <code>Symbol</code> 활용</h2><p>즉시실행함수 혹은 블록 스코프 내에서 심볼을 통해 접근을 제한하는 방법이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Count = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="built_in">Symbol</span>(<span class="string">&#x27;COUNT&#x27;</span>)</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>[count] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">inc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ++<span class="built_in">this</span>[count]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">dec</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> --<span class="built_in">this</span>[count]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">score</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>[count]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">score</span>(<span class="params">n</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>[count] = n</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Count</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Count()</span><br><span class="line"><span class="built_in">console</span>.log(test.inc()) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(test.inc()) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(test.dec()) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(test.score) <span class="comment">// 1</span></span><br><span class="line">test.score = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(test.score) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(test.inc()) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>이 방법은 Symbol의 접근 루트가 제한적이라서 가능한 방법이지만, 접근 루트가 아예 없는 것은 아니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testSymbol = <span class="built_in">Object</span>.getOwnPropertySymbols(test)[<span class="number">0</span>]</span><br><span class="line">test[testSymbol] = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(test.score) <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(test.inc()) <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testSymbol = <span class="built_in">Reflect</span>.ownKeys(test)[<span class="number">0</span>]</span><br><span class="line">test[testSymbol] = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(test.score) <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(test.dec()) <span class="comment">// 19</span></span><br></pre></td></tr></table></figure><p>비록 완벽한 private member가 되진 않지만, 위와 같은 몇 가지 접근을 제외하고는 다른 모든 접근으로부터는 보호되므로<br>절대적인 보호가 필요한 경우가 아닌 한 적절하게 활용하기 좋은 방법이라 하겠다.</p><h2 id="4-WeakMap-활용"><a href="#4-WeakMap-활용" class="headerlink" title="4. WeakMap 활용"></a>4. <code>WeakMap</code> 활용</h2><p>weakMap의 key에는 오직 참조형 데이터만을 지정할 수 있으며, 이 키값을 정확히 알고 있을 때에만<br>해당 프로퍼티의 값을 받아올 수 있다는 점을 이용한 방법이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Count = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = &#123; <span class="attr">COUNT</span>: <span class="string">&#x27;COUNT&#x27;</span> &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[count, <span class="number">0</span>]])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">inc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.map.set(count, <span class="built_in">this</span>.map.get(count) + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">dec</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.map.set(count, <span class="built_in">this</span>.map.get(count) - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">score</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.map.get(count)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">score</span>(<span class="params">n</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.map.set(count, n)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Count</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Count()</span><br><span class="line"><span class="built_in">console</span>.log(test.inc()) <span class="comment">// WeakMap &#123;Object &#123;COUNT: &quot;COUNT&quot;&#125; =&gt; 1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(test.inc()) <span class="comment">// WeakMap &#123;Object &#123;COUNT: &quot;COUNT&quot;&#125; =&gt; 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(test.dec()) <span class="comment">// WeakMap &#123;Object &#123;COUNT: &quot;COUNT&quot;&#125; =&gt; 1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(test.score) <span class="comment">// 1</span></span><br><span class="line">test.score = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(test.score) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(test.dec()) <span class="comment">// WeakMap &#123;Object &#123;COUNT: &quot;COUNT&quot;&#125; =&gt; 9&#125;</span></span><br></pre></td></tr></table></figure><p>WeakMap 활용법은 private member를 구현하는 가장 완벽한 방법이지만,<br>오직 WeakMap용 method만을 이용할 수 있다는 단점이 있다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>ES6 Class 내부에서 private 변수를 할당할 명시적인 방법이 없어, 이를 우회적으로 구현하기 위한 다양한 방법을 살펴보았다.<br>무엇 하나 ‘이거다’ 싶은 방법은 없지만, Symbol, WeakMap을 이용한 방법은 아쉬운 대로 써먹어볼 만 할 것 같다.</p><p>참고 : <a href="http://exploringjs.com/es6/ch_classes.html#sec_private-data-for-classes">Exploring ES6</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;es6의 class 문법에는 private data를 직접 지정할 수 있는 기능이 제공되지 않는다.&lt;br&gt;때문에 private data로 쓰고자 하는 변수는 우회적으로 관리하여야 하는데, 그 방법들을 소개한다.&lt;/p&gt;</summary>
    
    
    
    <category term="ECMAScript" scheme="http://roy-jung.github.io/categories/ecmascript/"/>
    
    
    <category term="ecmascript" scheme="http://roy-jung.github.io/tags/ecmascript/"/>
    
    <category term="javascript" scheme="http://roy-jung.github.io/tags/javascript/"/>
    
    <category term="class" scheme="http://roy-jung.github.io/tags/class/"/>
    
    <category term="es6" scheme="http://roy-jung.github.io/tags/es6/"/>
    
    <category term="es2015" scheme="http://roy-jung.github.io/tags/es2015/"/>
    
  </entry>
  
  <entry>
    <title>mac에서 `node.js`를 완전히 삭제하는 방법</title>
    <link href="http://roy-jung.github.io/161020_how-to-remove-node-from-macos/"/>
    <id>http://roy-jung.github.io/161020_how-to-remove-node-from-macos/</id>
    <published>2016-10-20T14:46:00.000Z</published>
    <updated>2020-10-26T11:22:53.537Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/category-etc.png"/><p>서로 다른 버전의 node가 하나의 shell 안에서 경쟁하는 구도가 되었다는 점이다. 여러 수단으로 node를 설치했음에도 아무 문제가 없는 분은 이쯤에서 뒤로가기를 살포시 눌러도 무방하나, 그렇지 않은 경우 아래의 방법에 따를 것을 강력히 추천한다.</p><p>(아래 내용은 본론만 소개하자니 어딘가 허전한 느낌이 들어 마구 휘갈긴 글로, 급하신 분들은 문장 건너뛰고 본론 파트로 넘어가시기 바랍니다.)</p><a id="more"></a><hr><h2 id="경험담"><a href="#경험담" class="headerlink" title="경험담"></a>경험담</h2><p>mac에서는 node를 설치하는 경로가 참 다양하다. <a href="https://nodejs.org/"><code>nodejs.org</code></a>에서 pkg파일을 받아 직접 설치할 수도 있고, <code>brew</code>를 이용할 수도 있으며, <a href="https://github.com/creationix/nvm"><code>nvm</code></a>, <a href="https://github.com/tj/n"><code>n</code></a> 등의 버전관리툴을 이용할 수도 있다. 그밖에 필자가 모르는 다른 수단도 상당히 존재할 것이리라 예상한다.</p><p>문제는 MacOS가 불친절하다는 점이다. pkg로 설치한 node조차 삭제하려면 shell에서 여기저기 경로를 찾아다녀야 한다. 설상가상으로 요세미티부터는 <code>sudo</code> 명령으로도 node를 설치할 수 없는 경로가 발생하게 되었다! 이에 따라 nodejs 설치 수단을 제공하던 툴들은 제각각 별개의 경로에 node를 설치하기 시작해버렸다. 필자는 MacOS를 사용한지 얼마 되지 않아 이런 사실을 모른 채 그저 위에 언급한 여러 툴이 제공하는 명령어들을 마구 남발하며 무차별로 node 설치를 시도했던 적이 있다. 그러다 개인적으로 가장 잘 맞는 것 같은 툴을 선택하여 이후로는 해당 툴로만 node를 사용(했다고 착각)하며 지냈다.</p><p>그러다가 최근 npm 3.10.8 버전이 오류가 있는 것 같아 downgrade하려는데 자꾸 충돌이 나길래 홧김에 npm 자체를 지워버리고 다시 설치하고자 했다. 재설치가 안되길래 맥을 재시동하고 <code>npm -v</code>를 찍어보니 <code>2.x.x</code>를 출력하였고, 다시 <code>sudo npm i -g npm</code>을 날려보아도 설치된 척만 하고 제대로 인식이 안되었다. 이 문제를 해결하고자 열심히 구글링하여 얻어낸 결과를 공유드리고자 한다.</p><hr><h2 id="본론"><a href="#본론" class="headerlink" title="본론"></a>본론</h2><p>구글링하고 시도하고 구글링하고 시도하기를 반복하다가 찾은 최고의 솔루션은 바로 이것이다.</p><p><a href="https://gist.github.com/TonyMtz/d75101d9bdf764c890ef">https://gist.github.com/TonyMtz/d75101d9bdf764c890ef</a></p><p>영어 울렁증인 분들을 위해 아래에 번역 내용을 적어보겠다. 사실 번역이랄 것도 없긴 하지만, 그래도 중간중간 내용을 보충한 부분도 있으니 원문보다는 조금 더 참고가 될 것이다.</p><h4 id="1-Mac에서-node-js를-두번다시-쓰지-않을-경우라면-이-단계를-먼저-거치자-혹은-기존에-global로-설치한-npm-패키지가-무엇이-있는지-기억하지-못하는-경우에도-이-단계를-실행하자-npm-패키지들의-global-설치는-나중에-다시-하면-된다"><a href="#1-Mac에서-node-js를-두번다시-쓰지-않을-경우라면-이-단계를-먼저-거치자-혹은-기존에-global로-설치한-npm-패키지가-무엇이-있는지-기억하지-못하는-경우에도-이-단계를-실행하자-npm-패키지들의-global-설치는-나중에-다시-하면-된다" class="headerlink" title="1. Mac에서 node.js를 두번다시 쓰지 않을 경우라면 이 단계를 먼저 거치자. 혹은 기존에 global로 설치한 npm 패키지가 무엇이 있는지 기억하지 못하는 경우에도 이 단계를 실행하자(npm 패키지들의 global 설치는 나중에 다시 하면 된다)."></a>1. Mac에서 node.js를 두번다시 쓰지 않을 경우라면 이 단계를 먼저 거치자. 혹은 기존에 global로 설치한 npm 패키지가 무엇이 있는지 기억하지 못하는 경우에도 이 단계를 실행하자(npm 패키지들의 global 설치는 나중에 다시 하면 된다).</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config get prefix</span><br><span class="line"><span class="built_in">cd</span> [ 위 명령으로 나온 경로. ex) /Users/gomugom/.npm-packages ]</span><br><span class="line"><span class="built_in">cd</span> lib &amp;&amp; rm -rf node_modules</span><br></pre></td></tr></table></figure><h4 id="2-shell을-열어-아무-경로에서나-다음-두-줄을-복붙하자"><a href="#2-shell을-열어-아무-경로에서나-다음-두-줄을-복붙하자" class="headerlink" title="2. shell을 열어 아무 경로에서나 다음 두 줄을 복붙하자."></a>2. shell을 열어 아무 경로에서나 다음 두 줄을 복붙하자.</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsbom -f -l -s -pf /var/db/receipts/org.nodejs.pkg.bom | <span class="keyword">while</span> <span class="built_in">read</span> f; <span class="keyword">do</span>  sudo rm /usr/<span class="built_in">local</span>/<span class="variable">$&#123;f&#125;</span>; <span class="keyword">done</span></span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/lib/node /usr/<span class="built_in">local</span>/lib/node_modules /var/db/receipts/org.nodejs.*</span><br></pre></td></tr></table></figure><p>오류가 날 경우 다음도 시도해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsbom -f -l -s -pf /var/db/receipts/org.node.pkg.bom | <span class="keyword">while</span> <span class="built_in">read</span> f; <span class="keyword">do</span>  sudo rm /usr/<span class="built_in">local</span>/<span class="variable">$&#123;f&#125;</span>; <span class="keyword">done</span></span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/lib/node /usr/<span class="built_in">local</span>/lib/node_modules /var/db/receipts/org.node.*</span><br></pre></td></tr></table></figure><p>엘 캐피탄 이상에서는 이렇게 해야 될 수도 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsbom -f -l -s -pf /var/db/receipts/org.nodejs.node.pkg.bom | <span class="keyword">while</span> <span class="built_in">read</span> f; <span class="keyword">do</span>  sudo rm /usr/<span class="built_in">local</span>/<span class="variable">$&#123;f&#125;</span>; <span class="keyword">done</span></span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/lib/node /usr/<span class="built_in">local</span>/lib/node_modules /var/db/receipts/org.nodejs.*</span><br></pre></td></tr></table></figure><p>그래도 안된다면 그냥 다음 단계로 넘어가면 된다.</p><h4 id="3-usr-local-lib-경로의-node로-시작하는-모든-것-node-node-modules-등-을-삭제한다"><a href="#3-usr-local-lib-경로의-node로-시작하는-모든-것-node-node-modules-등-을-삭제한다" class="headerlink" title="3. /usr/local/lib 경로의 node로 시작하는 모든 것(node, node_modules 등)을 삭제한다."></a>3. <code>/usr/local/lib</code> 경로의 node로 시작하는 모든 것(node, node_modules 등)을 삭제한다.</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/lib &amp;&amp; sudo rm -rf node*</span><br></pre></td></tr></table></figure><h4 id="4-usr-local-include-경로의-node로-시작하는-모든-것-node-node-modules-등-을-삭제한다"><a href="#4-usr-local-include-경로의-node로-시작하는-모든-것-node-node-modules-등-을-삭제한다" class="headerlink" title="4. /usr/local/include 경로의 node로 시작하는 모든 것(node, node_modules 등)을 삭제한다."></a>4. <code>/usr/local/include</code> 경로의 node로 시작하는 모든 것(node, node_modules 등)을 삭제한다.</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/include &amp;&amp; sudo rm -rf node*</span><br></pre></td></tr></table></figure><h4 id="혹시라도-brew로-node를-설치해놓고-기억을-못하고-있을-수도-있으니-brew로는-node를-설치하지-않았음이-확실치-않다면-그냥-아래도-돌려보자"><a href="#혹시라도-brew로-node를-설치해놓고-기억을-못하고-있을-수도-있으니-brew로는-node를-설치하지-않았음이-확실치-않다면-그냥-아래도-돌려보자" class="headerlink" title="혹시라도 brew로 node를 설치해놓고 기억을 못하고 있을 수도 있으니, brew로는 node를 설치하지 않았음이 확실치 않다면 그냥 아래도 돌려보자."></a>혹시라도 brew로 node를 설치해놓고 기억을 못하고 있을 수도 있으니, brew로는 node를 설치하지 않았음이 확실치 않다면 그냥 아래도 돌려보자.</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew uninstall node</span><br></pre></td></tr></table></figure><h4 id="usr-local-bin-경로-내의-node-및-npm을-삭제한다"><a href="#usr-local-bin-경로-내의-node-및-npm을-삭제한다" class="headerlink" title="/usr/local/bin 경로 내의 node 및 npm을 삭제한다."></a><code>/usr/local/bin</code> 경로 내의 node 및 npm을 삭제한다.</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin</span><br><span class="line">sudo rm -rf npm</span><br><span class="line">sudo rm -rf node</span><br></pre></td></tr></table></figure><h4 id="혹시-모르니-아래도-한-번씩-돌려주면-좋다"><a href="#혹시-모르니-아래도-한-번씩-돌려주면-좋다" class="headerlink" title="혹시 모르니 아래도 한 번씩 돌려주면 좋다."></a>혹시 모르니 아래도 한 번씩 돌려주면 좋다.</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/share/man/man1/node.1</span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/lib/dtrace/node.d</span><br><span class="line">sudo rm -rf ~/.npm</span><br></pre></td></tr></table></figure><h4 id="이걸로-끝이다-이제-다시-각자의-입맛에-맞는-툴로-node를-설치하여-충돌없는-노드세상을-만끽하자"><a href="#이걸로-끝이다-이제-다시-각자의-입맛에-맞는-툴로-node를-설치하여-충돌없는-노드세상을-만끽하자" class="headerlink" title="이걸로 끝이다. 이제 다시 각자의 입맛에 맞는 툴로 node를 설치하여 충돌없는 노드세상을 만끽하자!"></a>이걸로 끝이다. 이제 다시 각자의 입맛에 맞는 툴로 node를 설치하여 충돌없는 노드세상을 만끽하자!</h4><h3 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h3><p>brew로 설치한 분들 중에 여전히 오류가 지속된다면 아래 링크를 참고하자.</p><p><a href="https://gist.github.com/DanHerbert/9520689">https://gist.github.com/DanHerbert/9520689</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;서로 다른 버전의 node가 하나의 shell 안에서 경쟁하는 구도가 되었다는 점이다. 여러 수단으로 node를 설치했음에도 아무 문제가 없는 분은 이쯤에서 뒤로가기를 살포시 눌러도 무방하나, 그렇지 않은 경우 아래의 방법에 따를 것을 강력히 추천한다.&lt;/p&gt;
&lt;p&gt;(아래 내용은 본론만 소개하자니 어딘가 허전한 느낌이 들어 마구 휘갈긴 글로, 급하신 분들은 문장 건너뛰고 본론 파트로 넘어가시기 바랍니다.)&lt;/p&gt;</summary>
    
    
    
    <category term="etc" scheme="http://roy-jung.github.io/categories/etc/"/>
    
    
    <category term="nodejs" scheme="http://roy-jung.github.io/tags/nodejs/"/>
    
    <category term="uninstall" scheme="http://roy-jung.github.io/tags/uninstall/"/>
    
    <category term="remove" scheme="http://roy-jung.github.io/tags/remove/"/>
    
    <category term="macos" scheme="http://roy-jung.github.io/tags/macos/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Class는 단지 prototype 상속의 문법설탕일 뿐인가?</title>
    <link href="http://roy-jung.github.io/161007_is-class-only-a-syntactic-sugar/"/>
    <id>http://roy-jung.github.io/161007_is-class-only-a-syntactic-sugar/</id>
    <published>2016-10-06T16:43:00.000Z</published>
    <updated>2020-11-11T01:28:30.774Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/category-es.png"/><p>최근 모 커뮤니티에서 ‘ES6를 공부해야 할 필요는 없다’는 의견을 발견하였는데, 그 분의 견해를 읽던 중 ‘Class는 문법설탕일 뿐’이라는 내용에 대해서 정말로 그러한지 알아보고 싶은 마음이 들었습니다.</p><a id="more"></a><p>/_ 본 글은 지적 호기심에 따른 탐구과정을 <code>의식의 흐름 기법</code>에 따라 적어내려간 것이므로 내용전개가 매끄럽지 못할 수 있음을 미리 밝힙니다. _/</p><p>우선 구글링을 통해 ‘문법설탕’이라고 정의하고 있는 글들을 찾아보았습니다. 그 중 유명한 사이트의 글들을 일부만 발췌해왔는데, 이외에도 매우 많은 것으로 보아 이 견해가 거의 정론처럼 여겨지고 있는 것 같습니다.</p><blockquote><p>JavaScript classes introduced in ECMAScript 6 are <strong>syntactical sugar</strong> over JavaScript’s existing prototype-based inheritance. The class syntax is not introducing a new object-oriented inheritance model to JavaScript. - <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">MDN - Classes</a></p></blockquote><blockquote><p>Many features in ES6 (such as destructuring) are, in fact, <strong>syntactic sugar</strong> – and classes are no exception. - <a href="https://ponyfoo.com/articles/es6-classes-in-depth">ES6 Classes in Depth</a></p></blockquote><blockquote><p>Not “traditional” classes, <strong>syntax sugar</strong> on top of prototypal inheritance - <a href="https://github.com/bevacqua/es6#classes">ES6 Overview in 350 Bullet Points</a></p></blockquote><blockquote><p>In basic use, the class keyword is <strong>syntactic sugar</strong> for writing constructor functions with prototypes. - <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-classes-with-class">JavaScript Allongé</a></p></blockquote><p>심지어 ‘전적으로’ 문법설탕이라고 명확히 선을 긋는 사람들도 보입니다.</p><blockquote><p>They are totally syntactical sugar. - <a href="http://stackoverflow.com/questions/36419713/are-es6-classes-just-syntactic-sugar-for-the-prototypal-pattern-in-javascript">are es6 classes just syntactic sugar for the prototypal pattern in javascript?</a></p></blockquote><p>그런데 위 링크 중 대부분의 글들은 ‘문법설탕이다’에서 그치지 않고 곧바로 ‘하지만 더 엄격한 제약이 생겼다’는 등의 말을 덧붙이고 있습니다.</p><h2 id="What-is-‘Syntatic-Sugar’"><a href="#What-is-‘Syntatic-Sugar’" class="headerlink" title="What is ‘Syntatic Sugar’?"></a>What is ‘Syntatic Sugar’?</h2><blockquote><p>16.10.07. 추가 - 하루동안의 반응을 지켜보니 ‘문법설탕’이라는 표현이 전혀 와닿지 않는게 저뿐은 아닌 것 같습니다. 일단은 업계에서 관용적으로 쓰이고 있는 이상 본문에서는 관례에 따르겠지만, ‘편의문법’으로 바꾸자는 목소리도 있으니 적절히 섞어 쓰면서 점차 바꿔나가는 것은 어떨까 싶기도 합니다.</p></blockquote><p>wikipedia에서는 ‘syntactic sugar’를 다음과 같이 정의하고 있습니다.</p><blockquote><p>Specifically, a construct in a language is called syntactic sugar if it can be removed from the language without any effect on what the language can do: functionality and expressive power will remain the same. - <a href="https://en.wikipedia.org/wiki/Syntactic_sugar">wikipedia</a></p></blockquote><p>없는 영어실력으로 발번역 해보자면, <code>어떤 언어에서 제거하더라도 그 언어가 제공하는 기능과 표현력을 똑같이 유지하는 데에 아무런 노력이 필요하지 않은 구조</code> 정도가 될 것 같습니다.</p><p>이 정의에 따르자면, 앞서 소개한 링크들 중 ‘ES5와 동일한 기능을 하긴 하지만 보다 엄격한 제약이 따른다’는 주장들이 사실일 경우 Class는 문법설탕이 아니라는 결론이 나오게 됩니다. ‘기능과 표현력은 그대로이지만 완전히 동일한 기능을 수행하지는 않는다’라는 모순된 문장이 만들어지기 때문이죠.</p><p>본 글은 문장과 글의 모순을 파헤치려는 목적이 아니므로 단어의 의미를 곱씹는 것은 이정도로 하고, 위 링크들이 말하고자 하는 바를 좀더 알아보고자 합니다. 과연 prototype과 class 사이에 어떤 차이가 있는지 하나하나 살펴보도록 하겠습니다.</p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><h3 id="1-new-keyword"><a href="#1-new-keyword" class="headerlink" title="1) new keyword"></a>1) <code>new</code> keyword</h3><p>기본적으로 ES6 Class의 <code>constructor</code>는 기존의 ‘생성자함수’와 동일한 동작을 합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ES5</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ES6</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> es5 = <span class="keyword">new</span> ES5(<span class="string">&#x27;ES5&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> es6 = <span class="keyword">new</span> ES6(<span class="string">&#x27;ES6&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(es5.name, es6.name) <span class="comment">// ES5 ES6</span></span><br></pre></td></tr></table></figure><p>그런데 ES5에서는 생성자로서의 기능과 일반 함수로서의 기능 모두를 수행할 수 있었던 반면, ES6의 constructor에 같은 방법을 시도하면 문제가 생깁니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ES5</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="keyword">return</span> name + <span class="string">&#x27; es5&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ES6</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="keyword">return</span> name + <span class="string">&#x27; es6&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ES5(<span class="string">&#x27;ES5&#x27;</span>)) <span class="comment">// ES5 es5</span></span><br><span class="line"><span class="built_in">console</span>.log(ES5.prototype.constructor(<span class="string">&#x27;ES5&#x27;</span>)) <span class="comment">// ES5 es5</span></span><br><span class="line"><span class="built_in">console</span>.log(ES6(<span class="string">&#x27;ES6&#x27;</span>)) <span class="comment">// Uncaught TypeError</span></span><br><span class="line"><span class="built_in">console</span>.log(ES6.prototype.constructor(<span class="string">&#x27;ES6&#x27;</span>)) <span class="comment">// Uncaught TypeError</span></span><br></pre></td></tr></table></figure><p>Chrome 개발자도구에서 확인한 오류메시지는 다음과 같습니다.</p><blockquote><p>Uncaught TypeError: Class constructor ES6 cannot be invoked without ‘new’(…)</p></blockquote><p>Class의 constructor는 ‘new’ 명령어 없이는 호출할 수 없다고 하는군요.<br>즉, Class의 constructor는 기존의 생성자함수와 달리 함수로서는 동작하지 않으며 오직 생성자로서만 존재할 수 있겠습니다.</p><p>혹시 모르니 확인을 해보죠.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> ES6(<span class="string">&#x27;ES6&#x27;</span>)) <span class="comment">// ES6 &#123; name: &quot;ES6&quot; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> ES6.prototype.constructor(<span class="string">&#x27;ES6&#x27;</span>)) <span class="comment">// ES6 &#123; name: &quot;ES6&quot; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> es6 = <span class="keyword">new</span> ES6(<span class="string">&#x27;ES6&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> es6.constructor(<span class="string">&#x27;ES6 awesome&#x27;</span>)) <span class="comment">// ES6 &#123; name: &quot;ES6 awesome&quot; &#125;</span></span><br></pre></td></tr></table></figure><p>그렇다면 constructor 메소드 내의 return 값은 return 및 그 이후의 내용은 무시된다는 점을 제외하고는 의미가 없을 것입니다. 어떤 경우에도 return 구문으로부터 결과값을 반환받을 방법이 없을테니까요.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ES6</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="keyword">return</span> name + <span class="string">&#x27; es6&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> es6 = <span class="keyword">new</span> ES6(<span class="string">&#x27;es6&#x27;</span>, <span class="number">2015</span>)</span><br><span class="line"><span class="built_in">console</span>.log(es6) <span class="comment">// ES6 &#123; name: &quot;es6&quot; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-super-and-extends-keyword"><a href="#2-super-and-extends-keyword" class="headerlink" title="2) super and extends keyword"></a>2) <code>super</code> and <code>extends</code> keyword</h3><p>기존 프로토타입 상속 하에서는 자식클래스의 생성자함수가 부모클래스의 생성자 함수의 내용을 덮어씌우는 식으로 동작하므로,<br>기본적으로 부모클래스의 생성자함수를 자식클래스의 생성자함수에서 호출한 것 같은 효과를 얻을 수 없습니다. (물론 프로토타입 체이닝을 통해 값은 전달되겠지만요.)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(obj.a, obj.b) <span class="comment">// 1 2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;b&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>만약 자식 클래스에서 부모 클래스의 생성자함수를 그대로 차용하여 실행하기를 원한다면 다음과 같은 복잡한 수행과정을 거쳐야 합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> parentObj = <span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">this</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> parentObj) &#123;</span><br><span class="line">    <span class="built_in">this</span>[i] = parentObj[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(obj.a, obj.b) <span class="comment">// 1 2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;b&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>그러나 이 역시 완벽하지는 않습니다. 부모 클래스에도 여전히 ‘a’ 프로퍼티가 존재하기 때문이죠.<br>결국은 부모 클래스의 값을 복제한 것 이상의 의미를 지니지는 않습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj).a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj).hasOwnProperty(<span class="string">&#x27;a&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>한편 ES6에서는 <code>extends</code> 키워드로 subClass를 구현할 수 있는 길을 제공해주고 있으며,<br>이 경우 <code>super</code> 키워드를 통해 부모클래스(superClass)의 constructor를 자식클래스에서 호출할 수 있도록 구현하고 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">this</span>.b = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(obj.a, obj.b) <span class="comment">// 1 2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;b&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>또한 Child는 Parent의 인스턴스를 상속받는 것이 아닌 서브클래스로서 Parent의 메소드만을 상속받는 것이므로,<br>Child 인스턴스(obj)의 프로토타입 체인 상에도 Parent의 constructor의 실행 결과는 존재하지 않게 됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj).a) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj).hasOwnProperty(<span class="string">&#x27;a&#x27;</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>물론 ES5에서도 super/subClass를 구현할 수 있긴 하지만, 그러기 위해서는 다음처럼 꽤 복잡한 과정을 거쳐야 합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Proxy</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">Proxy</span>.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line">Child.superClass = Parent.prototype</span><br></pre></td></tr></table></figure><p>위 방법은 임시생성자를 프록시로 활용하는 방법입니다. 위 내용을 토대로 프록시를 외부에 노출시키지 않기 위해 함수로 감싸고, 프록시를 자꾸 생산하지 않게끔 클로저로 감싸고, 최초 실행시부터 클로저가 발동하게끔 즉시실행함수로 감싸는 등을 추가로 수행한 것이 ‘임시생성자(프록시) 활용패턴’으로 알려져 있습니다. 이 프록시 활용패턴의 구현은 중급 자바스크립트 개발자를 위한 교재에서 자주 등장하는 단골 메뉴이기도 했죠.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inherit = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">C, P</span>) </span>&#123;</span><br><span class="line">    F.prototype = P.prototype</span><br><span class="line">    C.prototype = <span class="keyword">new</span> F()</span><br><span class="line">    C.constructor.prototype = C</span><br><span class="line">    C.superClass = P.prototype</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">inherit(Child, Parent)</span><br></pre></td></tr></table></figure><h2 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h2><h3 id="1-static-method-및-method의-상속"><a href="#1-static-method-및-method의-상속" class="headerlink" title="1) static method 및 method의 상속"></a>1) static method 및 method의 상속</h3><p>ES5에서 static method 및 method를 구현하려면 다음과 같이 작성해야 했습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Parent.staticMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.s = <span class="number">11</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;static method&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.m = <span class="number">12</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;method&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Child()</span><br></pre></td></tr></table></figure><p>ES6 Class의 static method 및 method 선언 방식은 다음과 같습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">staticMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.s = <span class="number">11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;static method&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.m = <span class="number">12</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;method&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Child()</span><br></pre></td></tr></table></figure><p>상속관계를 되짚어가며 method를 출력해보면 양 쪽 결과가 같습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj.method()) <span class="comment">// &#x27;method&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(Child.prototype.method()) <span class="comment">// &#x27;method&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.prototype.method()) <span class="comment">// &#x27;method&#x27;</span></span><br></pre></td></tr></table></figure><p>그러나 static method의 경우에는 결과가 다릅니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.staticMethod()) <span class="comment">// Uncaught TypeError</span></span><br><span class="line"><span class="built_in">console</span>.log(Child.staticMethod()) <span class="comment">// Uncaught TypeError</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.staticMethod()) <span class="comment">// &#x27;static&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.staticMethod()) <span class="comment">// Uncaught TypeError</span></span><br><span class="line"><span class="built_in">console</span>.log(Child.staticMethod()) <span class="comment">// &#x27;static&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.staticMethod()) <span class="comment">// &#x27;static&#x27;</span></span><br></pre></td></tr></table></figure><p>앞서 언급한 프록시 생성자 활용패턴을 활용하더라도, superClass의 static method를 subClass에서도 호출 가능하게 하기 위해서는 추가로 해주어야 할 게 있습니다. 즉 Parent의 메소드를 Child에 <strong>복사</strong>하는 것이지요. 단, Child에 같은 이름의 static method가 있다면 Parent의 static method가 덮어씌우게 되니, 그러지 않게끔 접두어나 접미어를 붙여야 합니다. 혹은 프로토타입 체이닝을 통해 직접 superClass에 접근하면 되겠습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inherit = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">C, P</span>) </span>&#123;</span><br><span class="line">    F.prototype = P.prototype</span><br><span class="line">    C.prototype = <span class="keyword">new</span> F()</span><br><span class="line">    C.constructor.prototype = C</span><br><span class="line">    C.superClass = P.prototype</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> <span class="keyword">static</span> <span class="keyword">in</span> P) &#123;</span><br><span class="line">      C[<span class="string">&#x27;super_&#x27;</span> + <span class="keyword">static</span>] = P[<span class="keyword">static</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">Parent.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;super static&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">Child.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;sub static&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">inherit(Child, Parent)</span><br><span class="line"></span><br><span class="line">Child.method() <span class="comment">// sub static method</span></span><br><span class="line">Child.super_method() <span class="comment">// super static method</span></span><br><span class="line">Child.superClass.constructor.method() <span class="comment">// super static method</span></span><br></pre></td></tr></table></figure><p>이밖에도 Klass 등의 ‘흉내’낸 패턴들이 존재하긴 하지만, 어느 방법에 의하더라도 static method는 ‘복사’하는 외엔 마땅한 대안이 없을 뿐 아니라,<br>subClass의 static method 내에서 superClass의 다른 method를 이용하려면 또다른 방법을 잔뜩 강구해야만 합니다.</p><h3 id="2-생성자-함수"><a href="#2-생성자-함수" class="headerlink" title="2) 생성자 함수"></a>2) 생성자 함수</h3><p>ES5의 static method 및 method는 그 자체로 함수이기 때문에 별개의 생성자 함수로 사용할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> methodObj = <span class="keyword">new</span> ES5Parent.prototype.method()</span><br><span class="line"><span class="keyword">var</span> staticObj = <span class="keyword">new</span> ES5Parent.staticMethod()</span><br><span class="line"><span class="built_in">console</span>.log(staticObj) <span class="comment">// P…t.staticMethod &#123;s: 11&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(methodObj) <span class="comment">// P…t.method &#123;m: 12&#125;</span></span><br></pre></td></tr></table></figure><p>반면 ES6의 static method 및 method는 생성자함수로 활용할 수 없습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> methodObj = <span class="keyword">new</span> ES6Parent.prototype.method()</span><br><span class="line"><span class="keyword">var</span> staticObj = <span class="keyword">new</span> ES6Parent.staticMethod()</span><br><span class="line"><span class="built_in">console</span>.log(staticObj) <span class="comment">// Uncaught TypeError</span></span><br><span class="line"><span class="built_in">console</span>.log(methodObj) <span class="comment">// Uncaught TypeError</span></span><br></pre></td></tr></table></figure><p>그 원인은 ES5와 ES6의 각 메소드를 개발자도구로 출력해보면 파악할 수 있습니다.</p><p><img src="/public/img/2016-10-04-01.png" alt="ES5 static method vs. ES6 static method" style="max-width: 400px; width: 80%; margin: auto"/></p><p>그림에서 드러나듯이 ES6의 staticMethod에는 arguments, caller 값이 노출되지 않고 있고, name이 자동으로 지정되어 있으며, prototype이 없습니다. ES6의 shorthand method는 본질적으로는 function에 해당하긴 하지만, 기존 function에서 많은 기능이 제한되어 오직 method로서만 사용할 수 있는 특수한 함수입니다.</p><h3 id="3-superClass-메소드-차용"><a href="#3-superClass-메소드-차용" class="headerlink" title="3) superClass 메소드 차용"></a>3) superClass 메소드 차용</h3><p>constructor 파트에서 이미 어느정도 감은 잡으셨겠지만, 보다 확실히 하는 차원에서 method 차용에 대해서도 살펴보겠습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Parent.prototype.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;super&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line">Child.prototype.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">this</span>).method() + <span class="string">&#x27; sub&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(obj.method()) <span class="comment">// &#x27;super sub sub&#x27;</span></span><br></pre></td></tr></table></figure><p>ES5에서 부모클래스와 자식클래스에 동일한 메소드를 정의한 경우, 부모클래스의 메소드를 자식클래스에서 호출하려면 위와 같은 탐색과정을 거쳐야 합니다. 그마저도 인스턴스에서 method를 호출하면 <code>__proto__</code>에 위치한 메소드를 마치 인스턴스 자신의 것처럼 사용하기 때문에, 위 메소드에는 최초 실행시 this에는 ‘obj’가 할당되었다가, 재귀적으로 <code>Child.prototype</code>가 할당되었다가, 다시 <code>Parent.prototype</code>이 할당되기 때문에, 본래 의도한 ‘super sub’라는 결과 대신 ‘ sub’가 한 번 더 출력되고 말았습니다. 이 문제를 해결하기 위해서는 조건을 설정하는 등의 노력이 추가되어야 할 것입니다.</p><p><code>this</code>를 사용할 경우의 문제점은 ES6 클래스에서도 똑같이 확인됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;super&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">this</span>).method() + <span class="string">&#x27; sub&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(obj.method()) <span class="comment">// &#x27;super sub sub&#x27;</span></span><br></pre></td></tr></table></figure><p>그러나 ES6에는 <code>super</code> 키워드가 있어서, <code>this</code> 활용시의 문제점을 피해갈 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;super&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.method() + <span class="string">&#x27; sub&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(obj.method()) <span class="comment">// &#x27;super sub&#x27;</span></span><br></pre></td></tr></table></figure><p><code>super</code> 키워드는 상위클래스’만’을 가리키므로 재귀적으로 여러번 호출될 염려 없이 오직 Parent Class의 메소드만을 상속받아 활용할 수 있습니다.</p><h2 id="hoisting"><a href="#hoisting" class="headerlink" title="hoisting"></a>hoisting</h2><p>제가 읽은 거의 모든 자료들은 하나같이 <code>클래스는 호이스팅이 일어나지 않는다</code>고 하고 있습니다. 그 근거로 클래스 선언 전에 해당 클래스를 호출하면 <code>Reference Error</code>를 던지고, 블록 스코프의 영향을 받는 등을 들고 있습니다. 아래는 그 중 몇 개를 발췌한 것이며, 이외에도 굉장히 많습니다.</p><blockquote><p>class declarations are not hoisted. Therefore, a class only exists after execution reached its definition and it was evaluated. Accessing it beforehand leads to a ReferenceError - <a href="http://exploringjs.com/es6/ch_classes.html#_base-classes-1">Exploring ES6</a>, <a href="http://www.2ality.com/2015/02/es6-classes-final.html">2ality</a></p></blockquote><blockquote><p>An important difference between function declarations and class declarations is that function declarations are hoisted and class declarations are not. You first need to declare your class and then access it, otherwise code like the following will throw a ReferenceError - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">MDN</a></p></blockquote><blockquote><p>The difference between class declarations and function declarations is that functions are hoisted and classes are not. - <a href="http://stackabuse.com/es6-classes/">stackAbuse</a></p></blockquote><blockquote><p>class declarations can’t be hoisted. - <a href="https://strongloop.com/strongblog/an-introduction-to-javascript-es6-classes/">StrongLoop</a></p></blockquote><blockquote><p>Class declarations are not hoisted as function declarations are. - <a href="https://medium.freecodecamp.com/learn-es6-the-dope-way-part-v-classes-browser-compatibility-transpiling-es6-code-47f62267661">freeCodeCamp</a></p></blockquote><p>반면 ‘hoisting은 일어난다’는 내용은 오직 stackOverflow의 몇몇 질문에 대한 대답에서만 발견할 수 있었습니다.</p><blockquote><p><a href="http://stackoverflow.com/questions/35537619/why-are-es6-classes-not-hoisted">Why are ES6 classes not hoisted?</a></p></blockquote><blockquote><p><a href="http://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6">Are variables declared with let or const not hoisted in ES6?</a></p></blockquote><p>호이스팅이 발생하느냐 발생하지 않느냐에 대한 확인은 뒤로 미루고, 일단 위의 ‘근거’ 두 가지가 모두 사실인지부터 확인해 봅시다. 그런 후에 다시 호이스팅에 대해 다루도록 하겠습니다.</p><h3 id="1-ReferenceError"><a href="#1-ReferenceError" class="headerlink" title="1) ReferenceError"></a>1) ReferenceError</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> es5 = <span class="keyword">new</span> ES5()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ES5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(es5) <span class="comment">// ES5 &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">const</span> es6 = <span class="keyword">new</span> ES6()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ES6</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(es6) <span class="comment">// Uncaught ReferenceError</span></span><br></pre></td></tr></table></figure><p>ES6 Class는 ES5의 생성자함수와 달리 선언 전에 미리 인스턴스를 생성하고자 할 때 ReferenceError가 발생하는 것이 확인되었습니다.</p><h3 id="2-Block-Scope"><a href="#2-Block-Scope" class="headerlink" title="2) Block Scope"></a>2) Block Scope</h3><p>ES5의 함수는 ES6의 <code>strict mode</code>에서만 block scope의 영향을 받습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> A()) <span class="comment">// A &#123;a: 2&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> A()) <span class="comment">// A &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> A()) <span class="comment">// A &#123;a: 2&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> A()) <span class="comment">// A &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure><p>한편 ES6의 Class는 언제나 block scope에 종속됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.a = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> A()) <span class="comment">// A &#123;a: 2&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> A()) <span class="comment">// A &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure><p>간단하게 확인이 되었네요. 정리해보면, 클래스는 선언 전에 해당 클래스의 인스턴스를 생성하려 하면 <code>ReferenceError</code>를 던지며, ‘strict mode’ 여부에 무관하게 언제나 block scope의 영향 하에서만 존재할 수 있습니다.</p><h3 id="3-hoisting"><a href="#3-hoisting" class="headerlink" title="3) hoisting"></a>3) hoisting</h3><p>다시 한 번 호이스팅을 살펴봅시다.</p><p>tc39는 <code>var</code>에 대해 다음과 같이 정의하고 있습니다.</p><blockquote><p>A <code>var</code> statement declares variables that are scoped to the running execution context’s VariableEnvironment. <strong>Var variables are created when their containing Lexical Environment is instantiated and are initialized to undefined when created.</strong> - <a href="https://tc39.github.io/ecma262/#sec-variable-statement">Variable statement</a></p></blockquote><p>한편 <code>let</code>, <code>const</code>에 대해서는 다음과 같이 정의하고 있습니다.</p><blockquote><p><code>let</code> and <code>const</code> declarations define variables that are scoped to the running execution context’s LexicalEnvironment. <strong>The variables are created when their containing Lexical Environment is instantiated but may not be accessed in any way until the variable’s LexicalBinding is evaluated.</strong> A variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer’s AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created. - <a href="https://tc39.github.io/ecma262/#sec-let-and-const-declarations">let and const declarations</a></p></blockquote><p>위의 정의를 요약해보면 다음과 같습니다. <code>var</code>는 <em>LexicalEnvironment</em> 가 형성될 때 함께 생성되면서 동시에 undefined로 초기화됩니다. 반면 <code>let</code> 및 <code>const</code>는 <em>LexicalEnvironment</em> 가 형성될 때 함께 생성되지만, 이들의 <em>LexicalBinding</em> 이 평가되기 전까지는 접근할 수 없으며, LexicalBinding이 평가되는 시점에 비로소 초기값이 할당됩니다.</p><p>여기서 ‘Lexical Environment가 형성될 때 함께 생성됨’ 부분이 hoisting의 정의입니다. <code>var</code>의 ‘undefined 할당’과 <code>let</code> 및 <code>const</code>의 ‘LexicalBinding이 평가되기 전까지는 접근 불가’ 부분은 hoisting과는 별도로 분리하여 논해야 합니다. 그리고 이러한 ‘접근불가’영역을 통상 <strong>TDZ</strong>(Temporal Dead Zone, 임시사각지대)라고 부릅니다.</p><blockquote><p>TDZ에 대한 자세한 내용은 아래 링크를 참조하세요.</p><ul><li><a href="http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified/">Temporal Dead Zone Demystified</a></li><li><a href="http://www.2ality.com/2015/10/why-tdz.html">Why there is a TDZ in ES6?</a></li></ul></blockquote><p>TDZ 영역에서 값을 얻으려 하면 ‘ReferenceError’ 오류를 던집니다. Chrome의 오류메시지는 다음과 같습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>위 예제를 놓고 ‘hoisting이 일어나지 않은 것과 다를 바 없지 않느냐’고 생각하실 수도 있겠으나, 다음과 같은 상황에선 생각이 달라지실 것입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>‘hoisting’이 일어나지 않은 상황이라면 전역스코프에서 선언한 a변수의 값 <code>1</code>이 출력되었어야 마땅한 곳에서 ‘ReferenceError’가 발생하고 있습니다. 새로운 블록스코프가 생성됨과 동시에 해당 스코프 내의 <code>a</code> 변수가 생성되었으나, 아직 변수에 초기값이 할당되기 전 상태이기 때문에 ReferenceError를 던지는 것이죠.</p><p>앞서 “<code>var</code>의 ‘undefined 할당’과 <code>let</code> 및 <code>const</code>의 ‘LexicalBinding이 평가되기 전까지는 접근 불가’ 부분은 hoisting과는 별도로 분리하여 논해야 한다” 라고 말씀드린 이유가 바로 이것 때문입니다. ES5 환경에서는 변수가 <code>var</code>만 존재했으므로(함수선언문은 논외) hoisting과 undefined 할당을 동일시해도 문제되지 않았으나, 새로운 변수 유형이 생긴 ES6 환경에서는 이를 분리할 필요성이 생긴 것입니다.</p><p>뜬금없이 웬 변수 얘기를 하고 있냐면, 위 둘의 차이가 <code>function</code>과 <code>class</code> 사이에도 똑같이 발견되고 있어서 그렇습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> A()) <span class="comment">// A &#123;a: 2&#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> A()) <span class="comment">// Uncaught ReferenceError: A is not defined</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.a = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class가 선언되기 전 위치에서는 ‘ReferenceError’를 던질 뿐 아니라 class가 block scope의 영향 하에 있는 것에서 미루어보면, hoisting과 관련해서는 <code>class</code>를 <code>let</code> 및 <code>const</code>와 동일하게 취급하고 있다고 볼 수 있겠습니다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><table><thead><tr><th align="center">기능</th><th align="center">ES5</th><th align="center">ES6</th></tr></thead><tbody><tr><td align="center">constructor를 함수로 실행</td><td align="center">O</td><td align="center">X</td></tr><tr><td align="center">superClass의 constructor 호출</td><td align="center">X(기본). 흉내는 가능하나 한계가 있음</td><td align="center">O. super 키워드</td></tr><tr><td align="center">methods 상속</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">methods를 생성자함수로 실행</td><td align="center">O</td><td align="center">X</td></tr><tr><td align="center">static methods : 상속</td><td align="center">X(기본). 흉내는 가능하나 한계가 있음</td><td align="center">O</td></tr><tr><td align="center">static methods를 생성자함수로 실행</td><td align="center">O</td><td align="center">X</td></tr><tr><td align="center">methods: superClass의 메소드 호출</td><td align="center">X(기본). 흉내는 가능하나 한계가 있음</td><td align="center">O. super 키워드</td></tr><tr><td align="center">hoisting</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">TDZ</td><td align="center">X</td><td align="center">O</td></tr></tbody></table><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>ES6의 클래스가 ‘prototype’ 상속의 ‘문법설탕’에 불과한지 여부를 확인하기 위해 먼 길을 돌아왔습니다. 기존의 생성자함수와 ES6의 Class는 ‘prototype’을 이용하여 상속관계를 구현했다는 점에서는 같으나 구체적인 성질은 전혀 다른 부분이 많습니다. 특히 super 키워드로 처리 가능한 것들을 기존 방식으로 구현하기 위해서는 매우 많은 노력이 필요할뿐 아니라, subClass 메소드가 superClass 메소드를 호출한 다음 다시 자신만의 내용을 이어갈지 여부는 구체적 상황에 따라 달라질 수밖에 없는 문제이니 이를 패턴화하기도 어려워 보입니다. 기존 생성자함수가 하던 형태를 그대로 유지하면서 Class로 전환하는 것은 가능하고 어렵지 않을 것 같지만, 반대로 ES6의 Class를 기존 방식으로 전환하는 건 어렵거나 불가능에 가까운 경우도 존재할 것 같습니다.</p><p>ES6는 기본적으로 하위호환성을 유지한 채로 새로운 기능을 추가하면서도 언어가 갑자기 너무 비대해지는 것은 막아야 했기에, 최대한 새로운 기능들이 기존 기능을 토대로 동작하도록 구현되었습니다. Class가 prototype 상속을 차용한 것은 이러한 <a href="http://exploringjs.com/es6/ch_one-javascript.html#ch_one-javascript">One Javascript</a> 전략에 따르기 위한 것이었으며, 기존 문법으로는 구현할 수 없는 기능도 포함되어 있는 이상 ‘문법설탕’ 취급을 하는 것은 너무 야박한 평가가 아닌가 싶네요. ㅎㅎ</p><p>중간중간 모르는 내용을 근거도 없이 추측하거나 추정했을 수도 있고, 잘못된 내용을 단정적으로 확신하며 언급했을 가능성도 있을 것 같습니다. 혹시라도 틀렸거나 보충이 필요한 내용이 있다면 기탄없이 알려주시면 감사하겠습니다.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;최근 모 커뮤니티에서 ‘ES6를 공부해야 할 필요는 없다’는 의견을 발견하였는데, 그 분의 견해를 읽던 중 ‘Class는 문법설탕일 뿐’이라는 내용에 대해서 정말로 그러한지 알아보고 싶은 마음이 들었습니다.&lt;/p&gt;</summary>
    
    
    
    <category term="ECMAScript" scheme="http://roy-jung.github.io/categories/ecmascript/"/>
    
    
    <category term="ecmascript" scheme="http://roy-jung.github.io/tags/ecmascript/"/>
    
    <category term="javascript" scheme="http://roy-jung.github.io/tags/javascript/"/>
    
    <category term="class" scheme="http://roy-jung.github.io/tags/class/"/>
    
    <category term="es6" scheme="http://roy-jung.github.io/tags/es6/"/>
    
    <category term="es2015" scheme="http://roy-jung.github.io/tags/es2015/"/>
    
  </entry>
  
</feed>
