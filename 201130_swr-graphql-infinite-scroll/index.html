<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>infinite scroll 구현하기 (2) swr-graphql | FE재남</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="http://roy-jung.github.io/201130_swr-graphql-infinite-scroll/"/>
<meta name="description" content="최근 swr이라는 fetch 전용 라이브러리가 핫합니다. 내용을 살펴보았는데, apollo-graphql을 이용할 때와 뭐가 얼마나 다를지가 잘 그려지지 않아서 이참에 연습을 좀 해보았습니다. 전체 코드는 제 깃헙에 올려 놓았습니다. 1부에서는…">
<meta property="og:type" content="article">
<meta property="og:title" content="infinite scroll 구현하기 (2) swr-graphql">
<meta property="og:url" content="http://roy-jung.github.io/201130_swr-graphql-infinite-scroll/">
<meta property="og:site_name" content="FE재남">
<meta property="og:description" content="최근 swr이라는 fetch 전용 라이브러리가 핫합니다. 내용을 살펴보았는데, apollo-graphql을 이용할 때와 뭐가 얼마나 다를지가 잘 그려지지 않아서 이참에 연습을 좀 해보았습니다. 전체 코드는 제 깃헙에 올려 놓았습니다. 1부에서는…">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="http://roy-jung.github.io/201130_swr-graphql-infinite-scroll/0.png">
<meta property="article:published_time" content="2020-11-29T12:07:08.000Z">
<meta property="article:modified_time" content="2025-04-02T11:37:01.500Z">
<meta property="article:author" content="Jaenam Jung">
<meta property="article:tag" content="React.js">
<meta property="article:tag" content="graphQL">
<meta property="article:tag" content="swr">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://roy-jung.github.io/201130_swr-graphql-infinite-scroll/0.png"><meta property="article:author" content="Jaenam Jung"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2020-11-29 21:07:08"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="Jaenam Jung"><link rel="icon" href="/images/logo.png"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="FE재남"><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/logo.png" alt="FE재남"><span class="menu__item__link--brand__label">FE재남</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">infinite scroll 구현하기 (2) swr-graphql</h1><div class="article__meta"><time class="article__meta__time" datetime="2020-11-29T12:07:08.000Z" itemprop="datePublished">2020-11-29 21:07:08</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/fe/">FE</a><span class="article__meta__categories__separator">></span><a class="article__meta__categories__item" href="/categories/fe/react-js/">React.js</a></div></div><div class="article__contents"><img src="/201130_swr-graphql-infinite-scroll/0.png"/><p>최근 <a target="_blank" rel="noopener" href="https://swr.vercel.app/">swr</a>이라는 fetch 전용 라이브러리가 핫합니다. 내용을 살펴보았는데, apollo-graphql을 이용할 때와 뭐가 얼마나 다를지가 잘 그려지지 않아서 이참에 연습을 좀 해보았습니다. 전체 코드는 <a target="_blank" rel="noopener" href="https://github.com/roy-jung/swr-gql/tree/swr">제 깃헙</a>에 올려 놓았습니다.</p>
<p>1부에서는 apollo-graphql로 간단한 앱을 하나 만들었습니다. 이번 편에서는 이를 토대로 swr로 migration 해보겠습니다.</p>
<h2 id="lastMsgId-gt-page"><a href="#lastMsgId-gt-page" class="headerlink" title="lastMsgId -&gt; page"></a>lastMsgId -&gt; page</h2><p>1부에서 데이터의 실시간 정합성 등의 이유를 들어 fetchMore에 page 대신 lastMsgId를 활용한 방법을 소개하였습니다. 그런데 만약 데이터의 정합성을 라이브러리가 알아서 어느정도 해결해준다면 어떨까요? swr은 <code>refreshInterval</code>, <code>revalidateOnFocus</code>, <code>revalidateOnReconnect</code> 등 화면상의 데이터와 DB 데이터 간의 차이를 없애주는 다양한 옵션이 제공되고 있습니다. 그렇다면 이 부분을 크게 고려하지 않고도 충분히 신뢰할 수 있는 실시간 서비스 제공이 가능할 것 같아, 과감하게 lastMsgId를 제거하고 대신 page 단위의 fetchMore를 도입하기로 결정했습니다. 이 결정으로 많은 부분에서 코드가 상당히 가벼워졌습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  back/src/resolvers/message.js </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="attr">messages</span>: <span class="function">(<span class="params">parent, &#123; lastMsgId = <span class="string">&#x27;&#x27;</span>, limit = <span class="number">15</span> &#125;, &#123; models &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> messageIds = <span class="title class_">Object</span>.<span class="title function_">keys</span>(models.<span class="property">messages</span>).<span class="title function_">reverse</span>()</span><br><span class="line">  <span class="keyword">const</span> nextIndex = messageIds.<span class="title function_">indexOf</span>(lastMsgId)</span><br><span class="line">  <span class="keyword">return</span> (nextIndex === -<span class="number">1</span> ? messageIds.<span class="title function_">slice</span>(<span class="number">0</span>, limit) : messageIds.<span class="title function_">slice</span>(nextIndex, nextIndex + limit + <span class="number">1</span>)).<span class="title function_">map</span>(</span><br><span class="line">    <span class="function"><span class="params">id</span> =&gt;</span> models.<span class="property">messages</span>[id],</span><br><span class="line">  )</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// to</span></span><br><span class="line"><span class="attr">messages</span>: <span class="function">(<span class="params">parent, &#123; page = <span class="number">0</span>, limit = <span class="number">15</span> &#125;, &#123; models &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> messageIds = <span class="title class_">Object</span>.<span class="title function_">keys</span>(models.<span class="property">messages</span>).<span class="title function_">reverse</span>()</span><br><span class="line">  <span class="keyword">return</span> messageIds.<span class="title function_">slice</span>(page * limit, (page + <span class="number">1</span>) * limit).<span class="title function_">map</span>(<span class="function"><span class="params">id</span> =&gt;</span> models.<span class="property">messages</span>[id])</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="mutation시-cache-update를-직접-제어-gt-swr에게-맡기기"><a href="#mutation시-cache-update를-직접-제어-gt-swr에게-맡기기" class="headerlink" title="mutation시 cache update를 직접 제어 -&gt; swr에게 맡기기"></a>mutation시 cache update를 직접 제어 -&gt; swr에게 맡기기</h2><p>apollo 체계에서는 글의 생성/수정/삭제 등의 mutation시 실제 리스트에 반영하기 위해 각각의 상황에 맞게 cache를 udpate해주는 동작에 대한 정의가 필요했습니다. swr을 쓰면 이런 부분을 모두 과감히 걷어내도 됩니다. 서비스의 성격에 따라 실시간성이 엄청나게 크리티컬하지 않은 경우라면 refreshInterval의 수치를 적절하게 조절하는 것만으로 충분합니다. 예를 들어 refreshInterval 값을 30초로 설정했다면, 어떤 변경이 있은 후 최대 30초 후에는 변경사항이 반영될 것입니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/components/MsgInput.js </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="title function_">mutate</span>(&#123;</span><br><span class="line">  <span class="attr">variables</span>: &#123; ...variables, text &#125;,</span><br><span class="line">  <span class="attr">update</span>: <span class="function">(<span class="params">cache, &#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!variables.<span class="property">id</span>) &#123;</span><br><span class="line">      cache.<span class="title function_">writeQuery</span>(&#123;</span><br><span class="line">        <span class="attr">query</span>: updateQuery,</span><br><span class="line">        <span class="attr">data</span>: &#123; [updateTarget]: [data[mutationTarget]] &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = cache.<span class="title function_">readQuery</span>(&#123; <span class="attr">query</span>: updateQuery &#125;)</span><br><span class="line">    <span class="keyword">const</span> source = [...res[updateTarget]]</span><br><span class="line">    <span class="keyword">const</span> targetIndex = source.<span class="title function_">findIndex</span>(<span class="function"><span class="params">m</span> =&gt;</span> m.<span class="property">id</span> === variables.<span class="property">id</span>)</span><br><span class="line">    <span class="keyword">if</span> (targetIndex &lt; <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">    source[targetIndex] = data[mutationTarget]</span><br><span class="line">    cache.<span class="title function_">writeQuery</span>(&#123;</span><br><span class="line">      <span class="attr">query</span>: updateQuery,</span><br><span class="line">      <span class="attr">data</span>: &#123; [updateTarget]: source &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// to</span></span><br><span class="line"><span class="title function_">mutate</span>(&#123; <span class="attr">variables</span>: <span class="title function_">getVariablesFromArray</span>([...variables, <span class="string">&#x27;text&#x27;</span>, text]) &#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/components/MsgItem.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onDelete</span> = e =&gt; &#123;</span><br><span class="line">  e.<span class="title function_">stopPropagation</span>()</span><br><span class="line">  <span class="title function_">deleteMessage</span>(&#123;</span><br><span class="line">    <span class="attr">variables</span>: &#123; id &#125;,</span><br><span class="line">    <span class="attr">update</span>: <span class="function">(<span class="params">cache, &#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = cache.<span class="title function_">readQuery</span>(&#123; <span class="attr">query</span>: updateQuery &#125;)</span><br><span class="line">      cache.<span class="title function_">writeQuery</span>(&#123;</span><br><span class="line">        <span class="attr">query</span>: updateQuery,</span><br><span class="line">        <span class="attr">data</span>: &#123; [updateTarget]: res[target].<span class="title function_">filter</span>(<span class="function"><span class="params">m</span> =&gt;</span> m.<span class="property">id</span> !== id) &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onDelete</span> = e =&gt; &#123;</span><br><span class="line">  e.<span class="title function_">stopPropagation</span>()</span><br><span class="line">  <span class="title function_">deleteMessage</span>(&#123; <span class="attr">variables</span>: &#123; id &#125; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useSWR"><a href="#useSWR" class="headerlink" title="useSWR"></a>useSWR</h2><p>본격적으로 useSWR 문법을 살펴봅시다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fetcher</span> = (<span class="params">...args</span>) =&gt; <span class="title function_">fetch</span>(...args)</span><br><span class="line"><span class="keyword">const</span> &#123; data, error &#125; = <span class="title function_">useSWR</span>(<span class="string">&#x27;/api/user&#x27;</span>, fetcher, options)</span><br></pre></td></tr></table></figure>

<p>이게 기본입니다. 만약 추가로 id를 넘겨줘야 하는 경우에는 다음과 같이 템플릿 리터럴을 이용하길 권장하고 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; data, error &#125; = <span class="title function_">useSWR</span>(<span class="string">`/api/user/<span class="subst">$&#123;id&#125;</span>`</span>, fetcher, options)</span><br></pre></td></tr></table></figure>

<p>여러개의 params를 넘겨줘야 하는 경우 fetcher를 변형하여 첫번째 인자를 배열로 넘기는 방법도 제안하고 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fetchUser</span> = (<span class="params">url, id, page</span>) =&gt; <span class="title function_">fetch</span>(url, &#123; id, page &#125;)</span><br><span class="line"><span class="keyword">const</span> &#123; data, error &#125; = <span class="title function_">useSWR</span>([<span class="string">&#x27;/api/user&#x27;</span>, id, page], fetchUser)</span><br></pre></td></tr></table></figure>

<p>useSWR은 얕은비교만을 수행하기 때문에, 다음과 같이 배열 안에 객체를 전달하면 안된다고 합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fetchUser</span> = (<span class="params">url, params</span>) =&gt; <span class="title function_">fetch</span>(url, params)</span><br><span class="line"><span class="keyword">const</span> &#123; data, error &#125; = <span class="title function_">useSWR</span>([<span class="string">&#x27;/api/user&#x27;</span>, &#123; id, page &#125;], fetchUser) <span class="comment">// DON&quot;T DO THIS!</span></span><br></pre></td></tr></table></figure>

<p>그렇다면 param 값들을 한 데 모아 객체로 전달하지 않으면서도 실제 fetch시에는 객체로 만들어줘야 한다는게 관건이겠네요. 공식문서는 이 문제를 최대한 단순하게 소개하기 위해 각 상황에 맞는 fetcher 함수를 만드는 방식을 취하고 있지만, 저는 이런걸 원하지 않습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fetcher</span> = (<span class="params">url, ...variables</span>) =&gt; <span class="title function_">fetch</span>(url, variables)</span><br></pre></td></tr></table></figure>

<p>대충 이런 형태로 동작할 수 있다면 가장 좋을 것 같은데, 그러자니 나머지 인자로 취합한 variables는 배열이고, 실제 api 호출에 필요한 variables는 객체입니다. 배열을 객체로 전환하려면 각각의 ‘key’값도 전달해야 하겠습니다. 그러기 위해 우선적으로 떠오르는건 key-value pair로 이루어진 배열 형태입니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; data, error &#125; = <span class="title function_">useSWR</span>([<span class="string">&#x27;/api/user&#x27;</span>, [<span class="string">&#x27;id&#x27;</span>, id], [<span class="string">&#x27;page&#x27;</span>, page]], fetcher)</span><br></pre></td></tr></table></figure>

<p>그런데 이 방식은 앞서 언급한 ‘shallow compare’의 문제를 그대로 안게 되므로 사용할 수 없습니다. 따라서 다음과 같이 할 수밖에 없겠습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fetcher</span> = (<span class="params">url, ...variableArr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> variables = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; variableArr.<span class="property">length</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">    variables[variableArr[i]] = variableArr[i + <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(url, variables)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; data, error &#125; = <span class="title function_">useSWR</span>([<span class="string">&#x27;/api/user&#x27;</span>, <span class="string">&#x27;id&#x27;</span>, id, <span class="string">&#x27;page&#x27;</span>, page], fetcher)</span><br></pre></td></tr></table></figure>

<p>이 함수를 graphql에서 사용하려면 아주 살짝만 바꿔주면 됩니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fetcher</span> = (<span class="params">query, ...variableArr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> variables = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; variableArr.<span class="property">length</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">    variables[variableArr[i]] = variableArr[i + <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(<span class="string">&#x27;/graphql&#x27;</span>, query, variables)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useSWRInfinite"><a href="#useSWRInfinite" class="headerlink" title="useSWRInfinite"></a>useSWRInfinite</h2><p>infinite scroll을 구현하기 위해 가장 중요한 부분입니다. useSWR 대신 useSWRInfinite를 씁니다. useSWRInfinite의 문법은 기본적으로는 useSWR과 동일하고, infinite loading을 위한 페이징 처리 및 revalidate 관련한 옵션 몇개가 추가되어 있습니다. 그런데 이 ‘page’를 처리하기 위해서, 첫번쨰 인자로 url string이나 배열을 넘기는 대신 getKey라는 함수를 이용하도록 정의되어 있습니다.</p>
<p>getKey 함수에는 현재 페이지의 index값과 마지막으로 불러온 데이터 정보가 들어옵니다. 이 둘을 잘 이용해서 ‘다음 페이지’의 정보를 만들어 배열로 반환하도록 함수를 작성하면 됩니다. 즉 다음과 같은 결과를 얻을 수 있으면 됩니다. useSWRInfinite 함수는 자동으로 getKey함수를 호출하여 배열 또는 문자열을 받고, 이를 바탕으로 useSWR과 동일한 요청을 수행하도록 구현되어 있는 것 같습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getKey</span> = (<span class="params">prevIndex, prevData</span>) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(prevIndex, prevData)</span><br><span class="line">  <span class="keyword">return</span> [query, ...variables]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; data, error &#125; = <span class="title function_">useSWRInfinite</span>(getKey, fetcher, options)</span><br></pre></td></tr></table></figure>

<p>getKey가 어떤 방식으로 동작하는지 확인해보기 위해 콘솔로 출력을 해보았습니다. 그 결과는 다음과 같습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 null</span><br></pre></td></tr></table></figure>

<p>이 상태에서는 최초의 fetch 이후로는 아무리 스크롤을 내려도 다음 데이터를 로드하지 않습니다. 0페이지만 불러오기 때문인 것 같습니다. 그래서 공식문서를 다시 살펴보니, <code>size, setSize</code>가 보입니다. 현재는 size가 1인 상태인데, intersecting에 이 값을 변경해줘야만 fetchMore가 수행되는 방식인 것 같습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; data, error, size, setSize &#125; = <span class="title function_">useSWRInfinite</span>(getKey, fetcher, options)</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (intersecting) <span class="title function_">setSize</span>(size + <span class="number">1</span>)</span><br><span class="line">&#125;, [intersecting])</span><br></pre></td></tr></table></figure>

<p>이렇게 바꾸니 다음과 같은 데이터를 얻을 수 있었습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 첫번쨰 intersecting</span><br><span class="line">1 &#123;messages: Array(15)&#125;</span><br><span class="line"></span><br><span class="line">// 두번쨰 intersecting</span><br><span class="line">1 &#123;messages: Array(15)&#125;</span><br><span class="line">2 &#123;messages: Array(15)&#125;</span><br><span class="line"></span><br><span class="line">// 세번째 intersecting</span><br><span class="line">1 &#123;messages: Array(15)&#125;</span><br><span class="line">2 &#123;messages: Array(15)&#125;</span><br><span class="line">3 &#123;messages: Array(15)&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>결과를 보니 getKey 함수는 이전 데이터의 페이지별로 호출되는 방식인 것 같습니다. 그렇다면 useSWRInfinite 역시 getKey의 개수만큼 query를 날리겠네요. 첫번째 intersecting시에는 2번을(page 0, 1), 3번쨰 intersecting 시에는 4번을 호출하는 식일 것입니다(page 0, 1, 2, 3). 확인해보니 실제로도 network상에 쿼리요청이 다만 swr의 컨셉 자체가 서버에의 요청을 받고 나서만 화면에 보여주는 것이 아닌 cache를 먼저 보낸 다음 나중에 revalidate하는 방식이므로, 이미 불러온 페이지들에 대해서는 캐시가 동작하여 성능상의 문제는 크지 않으리란 추측이 가능합니다.</p>
<figure>
  <image src="./1.png" alt="">
  <figcaption style="text-align: center">[ 최초 요청시 vs. 첫 intersecting시 ]</figcaption>
</figure>

<p>추가로 모든 데이터가 로드된 시점에는 size가 더이상 늘어나지 않도록 처리해야 하겠습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getKey</span> = (<span class="params">prevIndex, prevData</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevData &amp;&amp; prevData.<span class="property">messages</span>.<span class="property">length</span> &lt; <span class="number">15</span>) &#123;</span><br><span class="line">    <span class="title function_">setLoadFinished</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [query, ...variables]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!loadFinished &amp;&amp; intersecting) <span class="title function_">setSize</span>(size + <span class="number">1</span>)</span><br><span class="line">&#125;, [intersecting, loadFinished])</span><br></pre></td></tr></table></figure>

<p>나아가 서버로부터 전달받은 data 객체의 구조도 조금 살펴볼 필요가 있겠습니다. 일반적인 useQuery 또는 useSWR에 의한 결과는 data 내부에 바로 messages 객체가 들어있습니다. 그런데 useSWRInfinite는 페이지 단위로 나뉜 배열 형태를 띕니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; data: [ &#123;messages: Array(15)&#125;, &#123;messages: Array(15)&#125;, &#123;messages: Array(15)&#125;, ...] &#125;</span><br></pre></td></tr></table></figure>

<p>이들 각 데이터를 하나의 배열로 취합하여 처리하기로 합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mergeMsgs</span> = data =&gt; data.<span class="title function_">flatMap</span>(<span class="function"><span class="params">d</span> =&gt;</span> d.<span class="property">messages</span>)</span><br></pre></td></tr></table></figure>

<p>이상의 내용을 반영하여 Migration한 MsgList 코드는 다음과 같습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/components/MsgList.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MsgList</span> = (<span class="params">&#123; updateQuery, updateTarget, variables = &#123;&#125;, smsgs &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [lastMsgId, setLastMsgId] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> [editingMsgId, setEditingMsgId] = <span class="title function_">useState</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> [msgs, setMsgs] = <span class="title function_">useState</span>(smsgs || [])</span><br><span class="line">  <span class="keyword">const</span> &#123; data, error, fetchMore &#125; = <span class="title function_">useQuery</span>(updateQuery, &#123; variables &#125;)</span><br><span class="line">  <span class="keyword">const</span> fetchMoreEl = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> [intersecting, loadFinished, setLoadFinished] = <span class="title function_">useInfiniteScroll</span>(fetchMoreEl, !!smsgs)</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">id</span>: incomingId &#125; = msgs[msgs.<span class="property">length</span> - <span class="number">1</span>] || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> messages = data?.[updateTarget]</span><br><span class="line">    <span class="keyword">if</span> (messages) <span class="title function_">setMsgs</span>(messages)</span><br><span class="line">  &#125;, [data?.[updateTarget]])</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!intersecting || loadFinished || !incomingId) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: fetchMoreData &#125; = <span class="keyword">await</span> <span class="title function_">fetchMore</span>(&#123;</span><br><span class="line">      <span class="attr">variables</span>: &#123; ...variables, <span class="attr">lastMsgId</span>: incomingId &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">setLastMsgId</span>(incomingId)</span><br><span class="line">    <span class="keyword">if</span> (fetchMoreData[updateTarget].<span class="property">length</span> &lt; <span class="number">15</span>) <span class="title function_">setLoadFinished</span>(<span class="literal">true</span>)</span><br><span class="line">  &#125;, [intersecting])</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// to</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MsgList</span> = (<span class="params">&#123; updateQuery, updateTarget, variables = [], smsgs &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [editingMsgId, setEditingMsgId] = <span class="title function_">useState</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> [msgs, setMsgs] = <span class="title function_">useState</span>(smsgs || [])</span><br><span class="line">  <span class="keyword">const</span> fetchMoreEl = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> [intersecting, loadFinished, setLoadFinished] = <span class="title function_">useInfiniteScroll</span>(fetchMoreEl, !!smsgs)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getKey</span> = (<span class="params">pageIndex, prevData</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevData &amp;&amp; prevData[updateTarget].<span class="property">length</span> &lt; <span class="number">15</span>) &#123;</span><br><span class="line">      <span class="title function_">setLoadFinished</span>()</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [updateQuery, ...variables, <span class="string">&#x27;page&#x27;</span>, pageIndex]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, error, size, setSize &#125; = <span class="title function_">useSWRInfinite</span>(getKey, fetcher)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data?.<span class="property">length</span>) <span class="title function_">setMsgs</span>(<span class="title function_">mergeMsgs</span>(data, updateTarget))</span><br><span class="line">  &#125;, [data])</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!loadFinished &amp;&amp; intersecting) <span class="title function_">setSize</span>(size + <span class="number">1</span>)</span><br><span class="line">  &#125;, [intersecting, loadFinished])</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>여기까지만 하고 구동시켜보면 동작은 잘 되지만, 아직 한가지 문제가 남아 있습니다. useSWRInfinite 역시 useSWR을 그대로 사용하기 때문인지, 기본적으로는 revalidate이 오직 0페이지에 대해서만 이뤄집니다. 이 상태로는 오래전 글이 수정/삭제되어도 화면에는 반영되지 않는 결과가 초래될 수 있습니다. 옵션 하나만 추가해주면 간단하게 해결됩니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; data, error, size, setSize &#125; = <span class="title function_">useSWRInfinite</span>(getKey, fetcher, &#123;</span><br><span class="line">  <span class="attr">revalidateAll</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="mutation-to-server"><a href="#mutation-to-server" class="headerlink" title="mutation to server"></a>mutation to server</h2><p>fetcher 함수가 graphql-request 라이브러리를 이용하고 있으니, 꼭 ‘query’에만 국한지어 사용할 이유가 없을 것 같습니다. mutation을 모두 fetcher로 대체하면 apollo-client를 아예 걷어낼 수 있겠네요.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/components/MsgInput.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">const</span> [mutate, &#123; data &#125;] = <span class="title function_">useMutation</span>(mutationQuery)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onSubmit</span> = <span class="keyword">async</span> e =&gt; &#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>()</span><br><span class="line">  <span class="keyword">const</span> text = textRef.<span class="property">current</span>.<span class="property">value</span></span><br><span class="line">  <span class="title function_">mutate</span>(&#123; <span class="attr">variables</span>: &#123; ...variables, text &#125; &#125;)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// to</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onSubmit</span> = <span class="keyword">async</span> e =&gt; &#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>()</span><br><span class="line">  <span class="keyword">const</span> text = textRef.<span class="property">current</span>.<span class="property">value</span></span><br><span class="line">  <span class="title function_">fetcher</span>(mutationQuery, ...variables, <span class="string">&#x27;text&#x27;</span>, text)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/components/MsgItem.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">const</span> [deleteMessage] = <span class="title function_">useMutation</span>(<span class="variable constant_">DELETE_MESSAGE</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onDelete</span> = <span class="keyword">async</span> e =&gt; &#123;</span><br><span class="line">  <span class="title function_">deleteMessage</span>(&#123; <span class="attr">variables</span>: &#123; id &#125; &#125;)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// to</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onDelete</span> = <span class="keyword">async</span> e =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">fetcher</span>(<span class="variable constant_">DELETE_MESSAGE</span>, <span class="string">&#x27;id&#x27;</span>, id)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>


<h2 id="apollo-setting"><a href="#apollo-setting" class="headerlink" title="apollo setting"></a>apollo setting</h2><p>이제 모든 graphql request를 swr 및 fetcher가 담당하게 되었으니, apollo는 필요가 없습니다.</p>
<h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p>getServerSideProps 내부도 상당히 단순해집니다. 앞서 만들어둔 fetcher 함수를 그대로 사용하면 됩니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/pages/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getServerSideProps</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> apolloClient = <span class="keyword">await</span> <span class="title function_">getStandaloneApolloClient</span>()</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> apolloClient.<span class="title function_">query</span>(&#123; <span class="attr">query</span>: <span class="variable constant_">GET_MESSAGES</span> &#125;)</span><br><span class="line">  <span class="keyword">const</span> initialState = apolloClient.<span class="property">cache</span>.<span class="title function_">extract</span>()</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      initialState,</span><br><span class="line">      <span class="attr">smsgs</span>: res.<span class="property">data</span>?.[msgTarget],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getServerSideProps</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> msgData = <span class="keyword">await</span> <span class="title function_">fetcher</span>(<span class="variable constant_">GET_MESSAGES</span>)</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">props</span>: &#123; <span class="attr">smsgs</span>: msgData?.[msgTarget] &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mutation-gt-revalidate"><a href="#mutation-gt-revalidate" class="headerlink" title="mutation -&gt; revalidate"></a>mutation -&gt; revalidate</h2><p>타인의 수정/삭제/추가에 대한 반영은 refreshInterval, revalidateOnFocus 등의 옵션만 적절히 지정해주면 충분하겠지만, 현재 화면에서 이뤄진 동작은 즉시 반영하지 않으면 난감할 수 있습니다. 삭제하라고 명령했는데 화면상에선 그대로라면 난감하겠죠. apollo에서는 이런 상황을 처리하기 위해서 useQuery 내부에 update 메서드를 두었던 것인데, 지금은 이걸 제거하였으니 대신하여 처리할 무언가가 필요합니다. useSWR, useSWRInfinite에는 이 역할을 수행해줄 ‘mutate’라는 함수가 마련되어 있습니다. useSWR은 하나의 데이터를 처리하고, useSWRInfinite는 배열의 각 요소를 처리합니다.</p>
<p>mutate 함수는 두 군데에서 존재하는데, 하나는 swr에서 직접 import할 수 있는 함수이고, 다른 하나는 useSWR의 실행 결과로 얻을 수 있는 것입니다. 전자는 mutation이 발생한 key와 변경된 value를 넘겨주면 해당 key로 등록된 모든 useSWR 함수들에 broadcast 되는 함수이고, 후자는 호출한 useSWR 하나의 변경에만 국한된(bounded) 함수입니다. 두 함수 모두 그 자체로 서버에의 put / post / patch / delete 등의 요청을 수행하는 함수가 아닌, 어디까지나 화면상의 ‘데이터 갱신’에 관련한 함수입니다(필자가 공식문서를 잘못 이해한 것일지도 모르겠습니다. 만약 그렇다면 알려주시면 감사하겠습니다).</p>
<p>그런데 rest api의 경우 key는 곧 문자열이기 때문에 broadcast가 의미가 있겠으나, 아쉽게도 graphql의 경우에는 그렇지가 못합니다. query문 자체가 참조형 데이터이다 보니 각 useSWR에서 생성한 query는 모두 다르기 때문입니다. (이 역시 제가 이해하는 한에서는 그렇다는 것입니다. 틀렸기를 바랍니다 ㅠ)</p>
<p>하여 현재로서는 몹시 아쉽지만 mutation을 catch하여 변경사항을 반영하거나 revalidate하는 로직은 별도의 처리가 필요합니다. 전역에서 쓰일 context를 생성하여 mutate시에 updateTarget을 지정해주고, 각 컴포넌트에서 지정된 target과 일치할 때에 useSWR에 있는 mutate를 호출해주는 방식을 떠올렸습니다. mutate를 호출하자마자 context에 지정된 target을 지워주면 될 것 같습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/contexts/mutationObserver.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createContext, useContext, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MutationObserverContext</span> = <span class="title function_">createContext</span>(&#123; <span class="attr">target</span>: <span class="string">&#x27;&#x27;</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MutationObserverProvider</span> = (<span class="params">&#123; children &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [mutated, setMutated] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">MutationObserverContext.Provider</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">value</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">mutated</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">setMutated</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">MutationObserverContext.Provider</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useMutationObserver</span> = (<span class="params"></span>) =&gt; <span class="title function_">useContext</span>(<span class="title class_">MutationObserverContext</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/component/MsgInput.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; setMutated &#125; = <span class="title function_">useMutationObserver</span>()</span><br><span class="line"><span class="keyword">const</span> textRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onSubmit</span> = e =&gt; &#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>()</span><br><span class="line">  <span class="keyword">const</span> text = textRef.<span class="property">current</span>.<span class="property">value</span></span><br><span class="line">  <span class="title function_">fetcher</span>(mutationQuery, ...variables, <span class="string">&#x27;text&#x27;</span>, text)</span><br><span class="line">  <span class="title function_">setMutated</span>(updateTarget)</span><br><span class="line">  textRef.<span class="property">current</span>.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  doneEdit &amp;&amp; <span class="title function_">doneEdit</span>()</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front/component/MsgList.js</span></span><br><span class="line"><span class="keyword">const</span> [intersecting, loadFinished, setLoadFinished] = <span class="title function_">useInfiniteScroll</span>(fetchMoreEl, !!smsgs)</span><br><span class="line"><span class="keyword">const</span> &#123; mutated, setMutated &#125; = <span class="title function_">useMutationObserver</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getKey</span> = (<span class="params">pageIndex, prevData</span>) =&gt; &#123; ... &#125;</span><br><span class="line"><span class="keyword">const</span> &#123; data, error, mutate, size, setSize &#125; = <span class="title function_">useSWRInfinite</span>(getKey, fetcher, &#123;</span><br><span class="line">  <span class="attr">revalidateAll</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (mutated === updateTarget) &#123;</span><br><span class="line">    <span class="title function_">mutate</span>()</span><br><span class="line">    <span class="title function_">setMutated</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [mutated])</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이상으로 마이그레이션을 모두 마쳤습니다. 전체 변경사항은 <a target="_blank" rel="noopener" href="https://github.com/roy-jung/swr-gql/compare/graphql...swr?diff=split">PR</a>을 보시면 더 용이하겠네요.</p>
<p>‘swr이라는 라이브러리를 한 번 써보기나 하자’ 라는 취지로 시작했던 것이 어쩌다보니 일이 커져버렸는데, 그래도 어떻게든 끝마쳐서 다행이네요. 실제로 사용해보니 swr은 생각보다 강력한 녀석 같습니다. 당장 실무에 적용해도 아무런 문제가 없을 것 같고, 기존 대비 상당히 적은 노력으로 더욱 훌륭한 퍼포먼스를 기대할 수 있을 것 같네요.</p>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/react-js/">React.js</a><a class="article__tags__item" href="/tags/graphql/">graphQL</a><a class="article__tags__item" href="/tags/swr/">swr</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="https://www.gravatar.com/avatar/02e9f56a3202da2e6e0e36a5a23facbb" alt="Jaenam Jung"><a class="article__author__link" title="About Jaenam Jung" rel="author">Jaenam Jung</a><p class="article__author__desc">할 수 있는걸 합니다.</p><div class="article__author__socials"><a class="article__author__socials__item" href="http://github.com/roy-jung" title="github" target="_blank"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="Jaenam Jung"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><div id="disqus_thread"></div><script>(function() {
  var d = document, s = d.createElement('script');
  s.src = '//gomugom.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Enable JavaScript to see comments.</noscript><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2025-04-02T11:37:01.500Z"><meta itemprop="articleBody" content="최근 swr이라는 fetch 전용 라이브러리가 핫합니다. 내용을 살펴보았는데, apollo-graphql을 이용할 때와 뭐가 얼마나 다를지가 잘 그려지지 않아서 이참에 연습을 좀 해보았습니다. 전체 코드는 제 깃헙에 올려 놓았습니다.
1부에서는 apollo-graphql로 간단한 앱을 하나 만들었습니다. 이번 편에서는 이를 토대로 swr로..."><meta itemprop="url" content="http://roy-jung.github.io/201130_swr-graphql-infinite-scroll/"><meta itemprop="mainEntityOfPage" content="http://roy-jung.github.io/201130_swr-graphql-infinite-scroll/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="FE재남"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="http://roy-jung.github.io/images/logo.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="http://roy-jung.github.io/201130_swr-graphql-infinite-scroll/0.png"><meta itemprop="url" content="http://roy-jung.github.io/201130_swr-graphql-infinite-scroll/0.png"><meta itemprop="width" content="200"><meta itemprop="height" content="200"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/201129_apollo-graphql-infinite-scroll/"><div class="related-posts__item__background" style="background-image:url('/201129_apollo-graphql-infinite-scroll/0.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">infinite scroll 구현하기 (1) apollo-graphql</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/201111-concise-redux-saga/"><div class="related-posts__item__background" style="background-image:url('/images/post-cover4.jpg');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">redux-saga를 간결하게 사용해보자!</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/250414-react-reconciliation-deep-dive/"><div class="related-posts__item__background" style="background-image:url('/images/React Reconciliation Engine.webp');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">React Reconciliation: 컴포넌트 뒤에 숨겨진 엔진</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/250414-react-reconciliation-deep-dive/">React Reconciliation: 컴포넌트 뒤에 숨겨진 엔진</a></li><li class="recent-posts__item"><a href="/250323-react-server-components/">리액트 서버 컴포넌트 톺아보기 (번역)</a></li><li class="recent-posts__item"><a href="/211231-review-2021/">2021 회고</a></li><li class="recent-posts__item"><a href="/201130_swr-graphql-infinite-scroll/">infinite scroll 구현하기 (2) swr-graphql</a></li><li class="recent-posts__item"><a href="/201129_apollo-graphql-infinite-scroll/">infinite scroll 구현하기 (1) apollo-graphql</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">2025 4월</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">2022 1월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">2020 11월</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">2020 10월</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">2017 1월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">2016 12월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">2016 11월</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">2016 10월</a><span class="archive-list-count">2</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ecmascript/">ECMAScript</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fe/">FE</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/fe/react-js/">React.js</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/fe/react-js/next-js/">Next.js</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/fe/javascript/">javascript</a><span class="category-list-count">6</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/etc/">etc</a><span class="category-list-count">2</span></li></ul></div></div></div><p class="copyright"><small>© 2025 Jaenam Jung<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>