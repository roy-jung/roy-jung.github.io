<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>간략한 자바스크립트 역사 (번역) | FE재남</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="http://roy-jung.github.io/250701-history-of-js/"/>
<meta name="description" content="원문: https:&#x2F;&#x2F;deno.com&#x2F;blog&#x2F;history-of-javascript   올해 자바스크립트가 30살이 되었습니다.   지난 30년 동안 자바스크립트는 단 10일 만에 만들어진 이상한 스크립트 언어에서 세계에서 가장 인기 있는…">
<meta property="og:type" content="article">
<meta property="og:title" content="간략한 자바스크립트 역사 (번역)">
<meta property="og:url" content="http://roy-jung.github.io/250701-history-of-js/">
<meta property="og:site_name" content="FE재남">
<meta property="og:description" content="원문: https:&#x2F;&#x2F;deno.com&#x2F;blog&#x2F;history-of-javascript   올해 자바스크립트가 30살이 되었습니다.   지난 30년 동안 자바스크립트는 단 10일 만에 만들어진 이상한 스크립트 언어에서 세계에서 가장 인기 있는…">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="http://roy-jung.github.io/250701-history-of-js/30th-bday.webp">
<meta property="article:published_time" content="2025-07-01T06:50:09.000Z">
<meta property="article:modified_time" content="2025-08-25T09:53:30.028Z">
<meta property="article:author" content="Jaenam Jung">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://roy-jung.github.io/250701-history-of-js/30th-bday.webp"><meta property="article:author" content="Jaenam Jung"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2025-07-01 15:50:09"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="Jaenam Jung"><link rel="icon" href="/images/logo.png"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="FE재남"><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/logo.png" alt="FE재남"><span class="menu__item__link--brand__label">FE재남</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">간략한 자바스크립트 역사 (번역)</h1><div class="article__meta"><time class="article__meta__time" datetime="2025-07-01T06:50:09.000Z" itemprop="datePublished">2025-07-01 15:50:09</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/javascript/">javascript</a></div></div><div class="article__contents"><img src="/250701-history-of-js/30th-bday.webp"/><blockquote>
<p>원문: <a target="_blank" rel="noopener" href="https://deno.com/blog/history-of-javascript">https://deno.com/blog/history-of-javascript</a></p>
</blockquote>
<!-- This year, JavaScript turns 30. -->
<p style="font-size: 1.5rem;">올해 자바스크립트가 30살이 되었습니다.</p>

<!-- Within three decades, JavaScript went from being a weird little scripting language developed in 10 days to the world's most popular programming language. Here are some key moments in its history to show how JavaScript has evolved and where it is headed. -->
<p>지난 30년 동안 자바스크립트는 단 10일 만에 만들어진 이상한 스크립트 언어에서 세계에서 가장 인기 있는 프로그래밍 언어로 성장했습니다. 자바스크립트가 어떻게 발전해왔고 앞으로 어떤 방향으로 나아갈지를 보여주는 역사적 순간들을 살펴보겠습니다.</p>
<section>

<h2 id="1994"><a href="#1994" class="headerlink" title="1994"></a>1994</h2><h3 id="1994년-12월"><a href="#1994년-12월" class="headerlink" title="1994년 12월"></a>1994년 12월</h3><!-- #### Netscape releases Netscape Navigator 1.0 -->
<h4 id="Netscape-Netscape-Navigator-1-0-출시"><a href="#Netscape-Netscape-Navigator-1-0-출시" class="headerlink" title="Netscape, Netscape Navigator 1.0 출시"></a>Netscape, Netscape Navigator 1.0 출시</h4><!-- Netscape Navigator 1.0 was a watershed moment for the web. It quickly became the most popular web browser, as it was faster and easier to use than [Mosaic](https://en.wikipedia.org/wiki/NCSA_Mosaic) (a web browser released in 1993). It had a slick graphical UI, unlike many of the earlier text-based browsers. Also it supported emerging standards like HTML 2.0, and eventually... JavaScript. -->
<p>Netscape Navigator 1.0은 웹 역사의 분기점이었습니다. 1993년에 출시된 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NCSA_Mosaic">모자이크</a>보다 훨씬 빠르고 사용하기 쉬워서 순식간에 최고 인기 브라우저가 되었습니다. 기존 텍스트 기반 브라우저들과는 차원이 다른 세련된 그래픽 인터페이스를 제공했고, HTML 2.0 같은 신기술을 지원했으며, 나중에는 자바스크립트까지 지원하게 됩니다.</p>
<p><img src="./netscape-navigator.webp" alt="Netscape Navigator 1.0"></p>
</section><section>

<h2 id="1995"><a href="#1995" class="headerlink" title="1995"></a>1995</h2><h3 id="1995년-5월"><a href="#1995년-5월" class="headerlink" title="1995년 5월"></a>1995년 5월</h3><!-- #### [Brendan Eich creates the very first version of JavaScript](https://cybercultural.com/p/1995-the-birth-of-javascript/) -->
<h4 id="Brendan-Eich-자바스크립트의-첫-번째-버전-생성"><a href="#Brendan-Eich-자바스크립트의-첫-번째-버전-생성" class="headerlink" title="Brendan Eich, 자바스크립트의 첫 번째 버전 생성"></a>Brendan Eich, <a target="_blank" rel="noopener" href="https://cybercultural.com/p/1995-the-birth-of-javascript/">자바스크립트의 첫 번째 버전</a> 생성</h4><!-- Netscape wanted to add interactivity to the early web, which at the time was mostly written in HTML. Around the same time, Sun Microsystems launched Java, and as part of that launch, Netscape licensed Java for use in the browser. But Java was a little too complicated for web designers. -->
<p>Netscape는 당시 대부분 HTML로만 이루어진 정적인 웹에 동적인 요소를 추가하고 싶어했습니다. 마침 같은 시기에 Sun Microsystems가 Java를 출시했고, Netscape는 브라우저에서 Java를 사용할 수 있도록 라이선스를 취득했습니다. 하지만 Java는 웹 디자이너들에게는 너무 복잡했습니다.</p>
<!-- Netscape asked Brendan Eich to develop a scripting language that looks like Java, but be object oriented rather than class based. And in ten short days, the language that powers most of the internet today was born. They arrived at the name "JavaScript" for marketing reasons, as Java, at the time, was the hot new programming language, so the name exploited that popularity. -->
<p>그래서 Netscape는 Brendan Eich에게 Java처럼 생겼지만 클래스 기반이 아닌 객체 지향 스크립트 언어를 만들어달라고 요청했습니다. 그리고 단 10일 만에 오늘날 인터넷 대부분을 움직이는 언어가 탄생했습니다. “자바스크립트”라는 이름은 마케팅 전략의 일환으로 지어진 이름입니다. 당시 Java가 핫한 신기술이었기 때문에 그 인기를 활용하려는 의도였습니다.</p>
<h3 id="1995년-12월"><a href="#1995년-12월" class="headerlink" title="1995년 12월"></a>1995년 12월</h3><!-- #### [Netscape and Sun announce JavaScript](https://www.tech-insider.org/java/research/1995/1204.html), the open, cross-platform object-oriented scripting language for enterprise networks and the internet -->
<h4 id="Netscape와-Sun-엔터프라이즈-네트워크와-인터넷을-위한-오픈-크로스플랫폼-객체지향-스크립트-언어인-자바스크립트-발표"><a href="#Netscape와-Sun-엔터프라이즈-네트워크와-인터넷을-위한-오픈-크로스플랫폼-객체지향-스크립트-언어인-자바스크립트-발표" class="headerlink" title="Netscape와 Sun, 엔터프라이즈 네트워크와 인터넷을 위한 오픈 크로스플랫폼 객체지향 스크립트 언어인 자바스크립트 발표"></a>Netscape와 Sun, 엔터프라이즈 네트워크와 인터넷을 위한 오픈 크로스플랫폼 객체지향 스크립트 언어인 <a target="_blank" rel="noopener" href="https://www.tech-insider.org/java/research/1995/1204.html">자바스크립트 발표</a></h4><!-- JavaScript was introduced as an easy-to-use, lightweight scripting language for adding interactivity to HTML. In this announcement, Netscape and Sun laid out their vision for the new web: Java objects being served to the client, where JavaScript scripts can modify them. Also notable is the industry support from 28 technology companies, ranging from America Online to Toshiba Corporation. -->
<p>자바스크립트는 HTML에 상호작용 기능을 더하는 쉽고 가벼운 스크립트 언어로 세상에 선보였습니다. 이 발표에서 Netscape와 Sun은 새로운 웹의 비전을 제시했는데, Java 객체를 클라이언트에 전달하고 자바스크립트 스크립트로 이를 조작할 수 있다는 것이었습니다. America Online부터 Toshiba Corporation까지 28개 기술 회사가 지원에 나선 것도 눈에 띄는 부분입니다.</p>
</section><section>

<h2 id="1996"><a href="#1996" class="headerlink" title="1996"></a>1996</h2><h3 id="1996년-3월"><a href="#1996년-3월" class="headerlink" title="1996년 3월"></a>1996년 3월</h3><!-- #### Microsoft introduces **[JScript](https://cybercultural.com/p/1996-microsoft-activates-the-internet-with-activex-jscript/)** in Internet Explorer 3 to compete with Netscape Navigator -->
<h4 id="Microsoft-Netscape-Navigator에-대항하여-Internet-Explorer-3에-JScript-도입"><a href="#Microsoft-Netscape-Navigator에-대항하여-Internet-Explorer-3에-JScript-도입" class="headerlink" title="Microsoft, Netscape Navigator에 대항하여 Internet Explorer 3에 JScript 도입"></a>Microsoft, Netscape Navigator에 대항하여 Internet Explorer 3에 <a target="_blank" rel="noopener" href="https://cybercultural.com/p/1996-microsoft-activates-the-internet-with-activex-jscript/">JScript</a> 도입</h4><!-- JScript, named to avoid the copyrighted word "Java", was an open implementation of JavaScript molded to the Windows ecosystem. Unlike Netscape's JavaScript, JScript could interact with Window's ActiveXObject, allowing developers to connect from Internet Explorer to an Excel spreadsheet for instance. -->
<p>상표권이 있는 “Java”라는 단어를 피하기 위해 지어진 JScript는 Windows 생태계에 맞춰진 자바스크립트의 오픈 구현체였습니다. Netscape의 자바스크립트와 달리, JScript는 Windows의 ActiveXObject와 상호작용할 수 있어서 개발자들이 Internet Explorer에서 Excel 스프레드시트에 연결하는 등의 작업을 할 수 있었습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">ExcelSheet</span>;</span><br><span class="line"><span class="title class_">ExcelSheet</span> = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Excel.Sheet&quot;</span>);</span><br><span class="line"><span class="comment">// Make Excel visible through the Application object.</span></span><br><span class="line"><span class="title class_">ExcelSheet</span>.<span class="property">Application</span>.<span class="property">Visible</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// Place some text in the first cell of the sheet.</span></span><br><span class="line"><span class="title class_">ExcelSheet</span>.<span class="property">ActiveSheet</span>.<span class="title class_">Cells</span>(<span class="number">1</span>,<span class="number">1</span>).<span class="property">Value</span> = <span class="string">&quot;This is column A, row 1&quot;</span>;</span><br><span class="line"><span class="comment">// Save the sheet.</span></span><br><span class="line"><span class="title class_">ExcelSheet</span>.<span class="title class_">SaveAs</span>(<span class="string">&quot;C:TEST.XLS&quot;</span>);</span><br><span class="line"><span class="comment">// Close Excel with the Quit method on the Application object.</span></span><br><span class="line"><span class="title class_">ExcelSheet</span>.<span class="property">Application</span>.<span class="title class_">Quit</span>();</span><br><span class="line"><span class="comment">// Release the object variable.</span></span><br><span class="line"><span class="title class_">ExcelSheet</span> = <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1996년-3월-1"><a href="#1996년-3월-1" class="headerlink" title="1996년 3월"></a>1996년 3월</h3><!-- #### Netscape Navigator 2.0 is released with JavaScript 1.0 -->
<h4 id="Netscape-Navigator-2-0-자바스크립트-1-0을-포함하여-출시"><a href="#Netscape-Navigator-2-0-자바스크립트-1-0을-포함하여-출시" class="headerlink" title="Netscape Navigator 2.0, 자바스크립트 1.0을 포함하여 출시"></a>Netscape Navigator 2.0, 자바스크립트 1.0을 포함하여 출시</h4><!-- This is JavaScript's debut, landing in millions of homes with Netscape Navigator 2.0. With JavaScript 1.0 came another key innovation that became a fundamental model of the web — the Document Object Model (DOM). -->
<p>자바스크립트가 Netscape Navigator 2.0과 함께 수백만 가정에 첫 선을 보인 순간입니다. 자바스크립트 1.0과 함께 등장한 문서 객체 모델(DOM)은 웹의 기본 구조가 된 또 다른 혁신적 기술이었습니다.</p>
<p><img src="./netscape-navigator-2.webp" alt="Netscape Navigator 2.0"></p>
</section><section>

<h2 id="1997"><a href="#1997" class="headerlink" title="1997"></a>1997</h2><h3 id="1997년-6월"><a href="#1997년-6월" class="headerlink" title="1997년 6월"></a>1997년 6월</h3><!-- #### Netscape submits JavaScript to ECMA International -->
<h4 id="Netscape-자바스크립트를-ECMA-인터내셔널에-제출"><a href="#Netscape-자바스크립트를-ECMA-인터내셔널에-제출" class="headerlink" title="Netscape, 자바스크립트를 ECMA 인터내셔널에 제출"></a>Netscape, 자바스크립트를 ECMA 인터내셔널에 제출</h4><!-- To avoid a fractured browser ecosystem, with JavaScript and Microsoft's JScript, Netscape submitted JavaScript to [ECMA International](https://ecma-international.org/), aiming to create a vendor-neutral standardized language that everyone can use. The standard spec was called ECMA-262 and the language "ECMAScript" ([not named JavaScript due to trademark issues](https://javascript.tm/)), of which JavaScript and JScript became dialects. Additionally, a technical committee named [TC39](https://tc39.es/) was formed, consisting of representatives from Netscape, Microsoft, Sun Microsystems, and more, to govern the evolution of ECMAScript. -->
<p>자바스크립트 생태계가 자바스크립트와 Microsoft의 JScript로 분열되는 것을 막기 위해, Netscape는 자바스크립트를 <a target="_blank" rel="noopener" href="https://ecma-international.org/">ECMA 인터내셔널</a>에 제출했습니다. 누구나 사용할 수 있는 벤더 중립적인 표준 언어를 만들겠다는 취지였습니다. 표준 사양을 ECMA-262, 언어명을 “ECMAScript”(<a target="_blank" rel="noopener" href="https://javascript.tm/">상표권 문제로 자바스크립트라는 이름을 쓸 수 없었음</a>)라고 정했고, 자바스크립트와 JScript는 이 표준의 구현체가 되었습니다. 아울러 Netscape, Microsoft, Sun Microsystems 등의 대표들로 구성된 <a target="_blank" rel="noopener" href="https://tc39.es/">TC39</a> 기술 위원회를 만들어 ECMAScript의 발전 방향을 관리하게 했습니다.</p>
</section><section>

<h2 id="1998"><a href="#1998" class="headerlink" title="1998"></a>1998</h2><h3 id="1998년-1월"><a href="#1998년-1월" class="headerlink" title="1998년 1월"></a>1998년 1월</h3><!-- #### Amid declining market share, Netscape open sources Navigator, leading to the creation of **[The Mozilla Project](https://www.mozilla.org/en-US/about/history/)** -->
<h4 id="Netscape-시장-점유율-감소에-대응하여-Navigator를-오픈소스화한-Mozilla-프로젝트-설립"><a href="#Netscape-시장-점유율-감소에-대응하여-Navigator를-오픈소스화한-Mozilla-프로젝트-설립" class="headerlink" title="Netscape, 시장 점유율 감소에 대응하여 Navigator를 오픈소스화한 Mozilla 프로젝트 설립"></a>Netscape, 시장 점유율 감소에 대응하여 Navigator를 오픈소스화한 <a target="_blank" rel="noopener" href="https://www.mozilla.org/en-US/about/history/">Mozilla 프로젝트</a> 설립</h4><!-- Since Microsoft bundled Internet Explorer with Windows, Netscape Navigator saw a rapid decline in market share. In a bold effort to save the company and compete with Microsoft, Netscape open sources its browser code, "Mozilla" (its internal codename, a portmanteau of "Mosaic" and "killer"), to allow the community to contribute to the development of a more advanced and standards-compliant browser. The next day, [Jamie Zawinksi](https://en.wikipedia.org/wiki/Jamie_Zawinski) of Netscape registered mozilla.org. The Mozilla project created several impactful technologies and products: Firefox, tabbed browsing, browser extensions, and [the programming language, Rust](https://en.wikipedia.org/wiki/Rust_(programming_language)#:~:text=Software%20developer%20Graydon%20Hoare%20created,sponsored%20the%20project%20in%202009.). -->
<p>Microsoft가 Windows에 Internet Explorer를 끼워팔기 시작하면서 Netscape Navigator의 시장 점유율이 급락했습니다. 회사를 살리고 Microsoft에 맞서기 위한 대담한 결정으로, Netscape는 브라우저 코드를 오픈소스화하여 “Mozilla”(내부 코드명으로 “모자이크”와 “킬러”를 합친 말)를 공개했습니다. 커뮤니티가 더 발전되고 표준을 잘 지키는 브라우저 개발에 참여할 수 있도록 한 것입니다. 그 다음날 Netscape의 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Jamie_Zawinski">Jamie Zawinski</a>가 mozilla.org 도메인을 등록했습니다. Mozilla 프로젝트는 Firefox, 탭 브라우징, 브라우저 확장 기능, 그리고 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rust_(programming_language)#:~:text=Software%20developer%20Graydon%20Hoare%20created,sponsored%20the%20project%20in%202009.">Rust 프로그래밍 언어</a>까지 여러 혁신적인 기술과 제품을 탄생시켰습니다.</p>
<p><img src="./mozilla-logo.webp" alt="Mozilla Logo"></p>
<h3 id="1998년-9월"><a href="#1998년-9월" class="headerlink" title="1998년 9월"></a>1998년 9월</h3><!-- #### [Official release of the **[first ECMAScript language specification](https://ecma-international.org/wp-content/uploads/ECMA-262_2nd_edition_august_1998.pdf)** (ECMAScript 2) -->
<h4 id="첫-번째-ECMAScript-언어-사양-ECMAScript-2-공식-출시"><a href="#첫-번째-ECMAScript-언어-사양-ECMAScript-2-공식-출시" class="headerlink" title="첫 번째 ECMAScript 언어 사양 (ECMAScript 2) 공식 출시"></a><strong><a target="_blank" rel="noopener" href="https://ecma-international.org/wp-content/uploads/ECMA-262_2nd_edition_august_1998.pdf">첫 번째 ECMAScript 언어 사양</a></strong> (ECMAScript 2) 공식 출시</h4><!-- Though no new features were added to the ECMAScript language, it ensured the spec was clean, consistent, and standardized. This set the groundwork for all future editions. -->
<p>ECMAScript 언어에 새로운 기능이 추가되지는 않았지만, 사양을 깔끔하고 일관성 있게 정리하고 표준화했습니다. 이는 앞으로 나올 모든 버전의 토대가 되었습니다.</p>
<p><img src="./ecmascript2.webp" alt="ECMAScript 2"></p>
</section><section>

<h2 id="1999"><a href="#1999" class="headerlink" title="1999"></a>1999</h2><h3 id="1999년-3월"><a href="#1999년-3월" class="headerlink" title="1999년 3월"></a>1999년 3월</h3><!-- #### Microsoft releases Internet Explorer 5, which uses more proprietary technology than before. -->
<h4 id="Microsoft-더-많은-독점-기술을-사용하는-Internet-Explorer-5-출시"><a href="#Microsoft-더-많은-독점-기술을-사용하는-Internet-Explorer-5-출시" class="headerlink" title="Microsoft, 더 많은 독점 기술을 사용하는 Internet Explorer 5 출시"></a>Microsoft, 더 많은 독점 기술을 사용하는 Internet Explorer 5 출시</h4><!-- More importantly, Microsoft introduces `XMLHttpRequest` — the first practical way to send HTTP requests via JavaScript: -->
<p>Microsoft는 Internet Explorer 5에 <code>XMLHttpRequest</code>를 도입했습니다. XMLHttpRequest는 자바스크립트를 통해 HTTP 요청을 보낼 수 있도록 하는 최초의 실용적 방법이었습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// How to send an HTTP request in IE5.</span></span><br><span class="line"><span class="comment">// IE5에서 HTTP 요청을 보내는 방법.</span></span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">makeRequest</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Create the ActiveXObject (specific to IE5/IE6)</span></span><br><span class="line">    <span class="comment">// ActiveXObject 생성 (IE5/IE6 전용)</span></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open a GET request (async = true)</span></span><br><span class="line">    <span class="comment">// GET 요청 열기 (비동기 = true)</span></span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://example.com/data.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define a callback to run when the response is ready</span></span><br><span class="line">    <span class="comment">// 응답이 준비되면 실행할 콜백 정의</span></span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Response received: &quot;</span> + xhr.<span class="property">responseText</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send the request</span></span><br><span class="line">    <span class="comment">// 요청 전송</span></span><br><span class="line">    xhr.<span class="title function_">send</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;makeRequest()&quot;</span>&gt;</span>Send HTTP Request<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="1999년-4월"><a href="#1999년-4월" class="headerlink" title="1999년 4월"></a>1999년 4월</h3><!-- #### [JSDoc](https://jsdoc.app/) debuts -->
<h4 id="JSDoc-데뷔"><a href="#JSDoc-데뷔" class="headerlink" title="JSDoc 데뷔"></a><a target="_blank" rel="noopener" href="https://jsdoc.app/">JSDoc</a> 데뷔</h4><!-- JSDoc, loosely based off [Javadoc](https://en.wikipedia.org/wiki/Javadoc) for Java, introduced a formal structured way to document JavaScript. This brought professionalism to the language, laid the groundwork for IDE support, and enabled documentation generation (it powers [`deno doc`](https://docs.deno.com/runtime/reference/cli/doc/) as well as the docs generation for modules on [jsr.io](https://jsr.io/)). -->
<p>자바의 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Javadoc">Javadoc</a>을 참고해 개발한 JSDoc은 자바스크립트 문서화에 체계적인 표준을 제시했습니다. 이로써 자바스크립트는 보다 전문적인 언어로 거듭나게 되었고, 현대 IDE의 자동완성과 타입 힌트 기능의 토대를 마련했습니다. 오늘날에도 <a target="_blank" rel="noopener" href="https://docs.deno.com/runtime/reference/cli/doc/"><code>deno doc</code></a>이나 <a target="_blank" rel="noopener" href="https://jsr.io/">jsr.io</a>의 자동 문서 생성 등 다양한 도구에서 핵심 역할을 하고 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds two numbers together and returns the result.</span></span><br><span class="line"><span class="comment"> * * 두 숫자를 더하고 결과를 반환합니다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; value1 The first value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; value2 The second value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addNumbers</span>(<span class="params">value1, value2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value1 + value2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1999년-12월"><a href="#1999년-12월" class="headerlink" title="1999년 12월"></a>1999년 12월</h3><!-- #### [ECMAScript 3](https://www-archive.mozilla.org/js/language/e262-3.pdf) is released with `do-while`, regex, new string methods (`concat`, `match`, `replace`, `slice`, `split`), exception handling, and more -->
<h4 id="ECMAScript-3-출시-do-while-정규식-새로운-문자열-메서드-concat-match-replace-slice-split-예외-처리-등-포함"><a href="#ECMAScript-3-출시-do-while-정규식-새로운-문자열-메서드-concat-match-replace-slice-split-예외-처리-등-포함" class="headerlink" title="ECMAScript 3 출시 - do-while, 정규식, 새로운 문자열 메서드(concat, match, replace, slice, split), 예외 처리 등 포함"></a><a target="_blank" rel="noopener" href="https://www-archive.mozilla.org/js/language/e262-3.pdf">ECMAScript 3</a> 출시 - <code>do-while</code>, 정규식, 새로운 문자열 메서드(<code>concat</code>, <code>match</code>, <code>replace</code>, <code>slice</code>, <code>split</code>), 예외 처리 등 포함</h4><!-- ECMAScript 3 was an important early milestone in JavaScript, as it transformed it from a toy scripting language into a serious programming tool. It would become the baseline language for browser scripting for over a decade, and widely considered as the version of JavaScript that defined the language for the web. -->
<p>ECMAScript 3은 자바스크립트 역사상 중요한 전환점이었습니다. 이전까지 단순한 스크립트 언어로 여겨지던 자바스크립트가 본격적인 프로그래밍 도구로 거듭났습니다. 이후 10년 넘게 브라우저 스크립팅의 표준이 되었고, 웹 개발 언어로서 자바스크립트의 정체성을 확립한 버전으로 평가받고 있습니다.</p>
</section><section>

<h2 id="2001"><a href="#2001" class="headerlink" title="2001"></a>2001</h2><h3 id="2001년-4월"><a href="#2001년-4월" class="headerlink" title="2001년 4월"></a>2001년 4월</h3><!-- #### The **[first JSON message](https://twobithistory.org/2017/09/21/the-rise-and-rise-of-json.html)** is sent -->
<h4 id="첫-번째-JSON-메시지가-전송됨"><a href="#첫-번째-JSON-메시지가-전송됨" class="headerlink" title="첫 번째 JSON 메시지가 전송됨"></a><a target="_blank" rel="noopener" href="https://twobithistory.org/2017/09/21/the-rise-and-rise-of-json.html">첫 번째 JSON 메시지</a>가 전송됨</h4><!-- And it looks something like this: -->
<p>주요 내용은 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;fudco&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  parent.<span class="property">session</span>.<span class="title function_">receive</span>(</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#123; <span class="attr">to</span>: <span class="string">&quot;session&quot;</span>, <span class="attr">do</span>: <span class="string">&quot;test&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">text</span>: <span class="string">&quot;Hello world&quot;</span> &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  )</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span>&lt;/html&gt;</span><br></pre></td></tr></table></figure>

</section><section>

<h2 id="2002"><a href="#2002" class="headerlink" title="2002"></a>2002</h2><h3 id="2002년-6월"><a href="#2002년-6월" class="headerlink" title="2002년 6월"></a>2002년 6월</h3><!-- #### [JSLint](https://web.archive.org/web/20180226015758/https://codekitapp.com/help/jslint/), the "grandfather of all JavaScript syntax checkers" is introduced -->
<h4 id="모든-자바스크립트-구문-검사기의-원조-JSLint-등장"><a href="#모든-자바스크립트-구문-검사기의-원조-JSLint-등장" class="headerlink" title="모든 자바스크립트 구문 검사기의 원조, JSLint 등장"></a>모든 자바스크립트 구문 검사기의 원조, <a target="_blank" rel="noopener" href="https://web.archive.org/web/20180226015758/https://codekitapp.com/help/jslint/">JSLint</a> 등장</h4><!-- JSLint, created by Douglas Crockford, was the first major static code analysis tool for JavaScript. At the time, JavaScript was widely used but poorly understood, and written without discipline. JSLint sought to level up the code quality. The strong opinions enforced by JSLint helped form Crockford's book, **["JavaScript: The Good Parts"](https://www.oreilly.com/library/view/javascript-the-good/9780596517748/)**. -->
<p>Douglas Crockford가 만든 JSLint는 최초의 자바스크립트 정적 코드 분석 도구였습니다. 당시 자바스크립트는 널리 사용되었지만 제대로 이해되지 않았고, 규율 없이 작성되었습니다. JSLint는 코드 품질을 향상시키고자 했습니다. JSLint가 강제한 강한 의견들은 Crockford의 책 <a target="_blank" rel="noopener" href="https://www.oreilly.com/library/view/javascript-the-good/9780596517748/">JavaScript: The Good Parts」 (한국어판: 「자바스크립트 핵심 가이드」)</a>에 영향을 주었습니다.</p>
<h3 id="2002년-9월"><a href="#2002년-9월" class="headerlink" title="2002년 9월"></a>2002년 9월</h3><!-- #### Mozilla releases Phoenix 0.1, precursor to Firefox, to compete with Internet Explorer -->
<h4 id="Mozilla-Internet-Explorer와-경쟁하기-위해-Firefox의-전신인-Phoenix-0-1-출시"><a href="#Mozilla-Internet-Explorer와-경쟁하기-위해-Firefox의-전신인-Phoenix-0-1-출시" class="headerlink" title="Mozilla, Internet Explorer와 경쟁하기 위해 Firefox의 전신인 Phoenix 0.1 출시"></a>Mozilla, Internet Explorer와 경쟁하기 위해 Firefox의 전신인 Phoenix 0.1 출시</h4><!-- Fed up with how slow and bloated the Mozilla Application Suite was, a small team built a minimalist stripped down version of a web browser called Phoenix (to signify the rebirth of the browser from the ashes of Netscape and Mozilla Suite). At the time, Internet Explorer had 90% of market share, and innovation stagnated. Phoenix offered something new to internet users: speed, simple UI, tabbed browsing, and pop-up blockers. This marked the rebirth of user-focused, open-source browsers, became the foundation of Firefox, and broke Microsoft's monopoly on the browser market. -->
<p>Mozilla Application Suite의 느리고 무거운 성능에 한계를 느낀 소규모 팀이 Phoenix(Netscape와 Mozilla Suite의 잿더미에서 브라우저가 다시 태어남을 의미)라는 미니멀한 웹 브라우저를 만들었습니다. 당시 Internet Explorer는 90%의 시장 점유율을 차지했고, 혁신은 정체되어 있었습니다. Phoenix는 인터넷 사용자들에게 빠른 속도, 간단한 UI, 탭 브라우징, 팝업 차단 기능 등 새로운 가치를 제공했습니다. 이는 사용자 중심의 오픈소스 브라우저의 재탄생을 의미했고, Firefox의 기반이 되었으며, 브라우저 시장에서 Microsoft의 독점을 깨뜨렸습니다.</p>
<p><img src="./2002_phoenix.webp" alt="Phoenix 0.1"></p>
</section><section>

<h2 id="2003"><a href="#2003" class="headerlink" title="2003"></a>2003</h2><h3 id="2003년-1월"><a href="#2003년-1월" class="headerlink" title="2003년 1월"></a>2003년 1월</h3><!-- #### Apple introduces Safari and WebKit -->
<h4 id="Apple-Safari-및-WebKit-도입"><a href="#Apple-Safari-및-WebKit-도입" class="headerlink" title="Apple, Safari 및 WebKit 도입"></a>Apple, Safari 및 WebKit 도입</h4><!-- Apple CEO Steve Jobs announces [Safari](https://www.apple.com/newsroom/2003/01/07Apple-Unveils-Safari/), "a turbo browser for Mac OS X". Most importantly, it ended Apple's dependence on Microsoft, as before Mac users relied on Internet Explorer for Mac. Additionally, this paved the way for Apple's Mobile Safari a few years later with the iPhone. It is based on WebKit, an internal fork of the KHTML browser engine. -->
<p>Apple CEO Steve Jobs가 <a target="_blank" rel="noopener" href="https://www.apple.com/newsroom/2003/01/07Apple-Unveils-Safari/">Safari</a>를 “Mac OS X용 터보 브라우저”로 발표했습니다. 가장 중요한 것은 이전에 Mac용 Internet Explorer에 의존했던 Apple의 Microsoft 종속성을 끝냈다는 것입니다. 또한 이는 몇 년 후 iPhone과 함께 등장할 Mobile Safari의 길을 열었습니다. Safari는 KHTML 브라우저 엔진을 포크한 WebKit을 기반으로 합니다.</p>
<p><img src="./safari.webp" alt="Safari 1.0"></p>
</section><section>

<h2 id="2004"><a href="#2004" class="headerlink" title="2004"></a>2004</h2><h3 id="2004년-4월"><a href="#2004년-4월" class="headerlink" title="2004년 4월"></a>2004년 4월</h3><!-- #### A beta version of Gmail is released, which uses a new asynchronous JavaScript protocol, "AJAX" -->
<h4 id="새로운-비동기-자바스크립트-프로토콜-“AJAX”를-사용하는-Gmail-베타-버전-출시"><a href="#새로운-비동기-자바스크립트-프로토콜-“AJAX”를-사용하는-Gmail-베타-버전-출시" class="headerlink" title="새로운 비동기 자바스크립트 프로토콜 “AJAX”를 사용하는 Gmail 베타 버전 출시"></a>새로운 비동기 자바스크립트 프로토콜 “AJAX”를 사용하는 Gmail 베타 버전 출시</h4><!-- The launch of Gmail was a turning point in web development. AJAX allowed Gmail to offer a highly responsive, interactive user experience that was unprecedented for a web site at the time, ushering a new Web 2.0 era of web applications. -->
<p>Gmail 출시는 웹 개발 역사에 한 획을 그은 사건이었습니다. AJAX 덕분에 Gmail은 당시로서는 상상할 수 없었던 빠르고 반응성 좋은 사용자 경험을 제공할 수 있었고, 이로써 웹 애플리케이션의 새로운 Web 2.0 시대가 열렸습니다.</p>
<p><img src="./gmail-2004.webp" alt="Gmail"></p>
</section><section>

<h2 id="2005"><a href="#2005" class="headerlink" title="2005"></a>2005</h2><h3 id="2005년-2월"><a href="#2005년-2월" class="headerlink" title="2005년 2월"></a>2005년 2월</h3><!-- #### Jesse James Garrett coins "AJAX" in his white paper, ["Ajax: A New Approach to Web Applications"](https://designftw.mit.edu/lectures/apis/ajax_adaptive_path.pdf) -->
<h4 id="Jesse-James-Garrett-「Ajax-웹-애플리케이션의-새로운-접근법」에서-“AJAX”-용어-창안"><a href="#Jesse-James-Garrett-「Ajax-웹-애플리케이션의-새로운-접근법」에서-“AJAX”-용어-창안" class="headerlink" title="Jesse James Garrett, 「Ajax: 웹 애플리케이션의 새로운 접근법」에서 “AJAX” 용어 창안"></a>Jesse James Garrett, <a target="_blank" rel="noopener" href="https://designftw.mit.edu/lectures/apis/ajax_adaptive_path.pdf">「Ajax: 웹 애플리케이션의 새로운 접근법」</a>에서 “AJAX” 용어 창안</h4><!-- Ajax, short for asynchronous JavaScript and XML, is a set of client-side techniques to create web apps that can send and receive data from a server asynchronously without needing a page reload. This unlocked a whole new class of web apps, as well as frameworks, that can deliver a rich and seamless user experience. -->
<p>Ajax는 asynchronous JavaScript and XML(비동기 자바스크립트와 XML)의 줄임말로, 페이지를 새로고침하지 않고도 서버와 데이터를 주고받을 수 있게 해주는 클라이언트 사이드 기술 모음입니다. 이 기술 덕분에 풍부하고 끊김 없는 사용자 경험을 제공하는 완전히 새로운 종류의 웹 앱과 프레임워크가 등장할 수 있었습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">createXHR</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123;</span><br><span class="line">      <span class="comment">// Modern browsers (Mozilla, Safari, IE7+)</span></span><br><span class="line">      <span class="comment">// 현대 브라우저 (Mozilla, Safari, IE7+)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">ActiveXObject</span>) &#123;</span><br><span class="line">      <span class="comment">// Older versions of IE (IE5, IE6)</span></span><br><span class="line">      <span class="comment">// 이전 버전의 IE (IE5, IE6)</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Msxml2.XMLHTTP&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="title function_">alert</span>(<span class="string">&quot;AJAX not supported in your browser.&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">loadData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="title function_">createXHR</span>();</span><br><span class="line">    <span class="keyword">if</span> (!xhr) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;result&quot;</span>).<span class="property">innerHTML</span> = xhr.<span class="property">responseText</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">alert</span>(<span class="string">&quot;Request failed: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/messages/latest&quot;</span>, <span class="literal">true</span>); <span class="comment">// Simulated Gmail-style endpoint</span></span><br><span class="line">                                               <span class="comment">// Gmail 스타일 엔드포인트 시뮬레이션</span></span><br><span class="line">    xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;loadData()&quot;</span>&gt;</span>Load Latest Message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span>Waiting for response...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2005년-3월"><a href="#2005년-3월" class="headerlink" title="2005년 3월"></a>2005년 3월</h3><!-- #### The Mozilla Corporation launches DevMo By Mozilla, which becomes MDN -->
<h4 id="Mozilla-Corporation-MDN의-전신인-DevMo-By-Mozilla-출시"><a href="#Mozilla-Corporation-MDN의-전신인-DevMo-By-Mozilla-출시" class="headerlink" title="Mozilla Corporation, MDN의 전신인 DevMo By Mozilla 출시"></a>Mozilla Corporation, MDN의 전신인 DevMo By Mozilla 출시</h4><!-- [Mozilla launches DevMo By Mozilla](https://developer.mozilla.org/en-US/about#our_journey), which later became known as [MDN](https://developer.mozilla.org/en-US/) (Mozilla Developer Network). MDN provided an accurate, vendor-neutral, and standards-based documentation, and functioned as a central place for learning web standards. This came at a critical time when browser incompatibility was a major pain point, and documentation was fragmented, outdated, and inconsistent. MDN quickly became the go-to resource for web developers, and set a new standard for developer documentation. -->
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/about#our_journey">Mozilla가 DevMo By Mozilla를 시작</a>했고, 이것이 나중에 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/">MDN</a> (Mozilla Developer Network)이 되었습니다. MDN은 정확하고 벤더 중립적이며 표준에 기반한 문서를 제공하면서 웹 표준을 배우는 허브 역할을 했습니다. 브라우저 호환성 문제가 심각하고 문서들이 여기저기 흩어져 있거나 오래되어 일관성이 없던 상황에서 등장한 것입니다. MDN은 순식간에 웹 개발자들의 바이블이 되었고, 개발자 문서의 새로운 기준을 제시했습니다.</p>
<p><img src="./mdn-v1.webp" alt="MDN"></p>
</section><section>

<h2 id="2006"><a href="#2006" class="headerlink" title="2006"></a>2006</h2><h3 id="2006년-3월"><a href="#2006년-3월" class="headerlink" title="2006년 3월"></a>2006년 3월</h3><!-- #### John Resig creates [first commit to a project named jQuery](https://github.com/jquery/jquery/commit/8a4a1edf047f2c272f663866eb7b5fcd644d65b3) -->
<h4 id="John-Resig-jQuery-첫-커밋-생성"><a href="#John-Resig-jQuery-첫-커밋-생성" class="headerlink" title="John Resig, jQuery 첫 커밋 생성"></a>John Resig, <a target="_blank" rel="noopener" href="https://github.com/jquery/jquery/commit/8a4a1edf047f2c272f663866eb7b5fcd644d65b3">jQuery 첫 커밋</a> 생성</h4><!-- jQuery, a JavaScript library designed to simplify HTML DOM tree traversal, event handling, Ajax, and more, was created to address frustrating issues related to cross-browser compatibility. It also provides a well documented terse API that sets a new standard for the developer experience and remains the most widely used JavaScript library in terms of actual page loads. -->
<p>jQuery는 HTML DOM 조작, 이벤트 처리, Ajax 등을 쉽게 만들어주는 자바스크립트 라이브러리로, 골치 아픈 브라우저 호환성 문제를 해결하기 위해 탄생했습니다. 잘 정리된 간결한 API로 개발자 경험의 새로운 기준을 제시했고, 실제 웹페이지 사용량 기준으로는 지금도 가장 많이 쓰이는 자바스크립트 라이브러리입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://code.jquery.com/jquery-1.0.0.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">sendRequest</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $.<span class="title function_">ajax</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">url</span>: <span class="string">&quot;https://example.com/data&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">type</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;result&quot;</span>).<span class="property">innerHTML</span> = res;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params">xhr, status, error</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(<span class="string">&quot;Request failed: &quot;</span> + status);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;sendRequest()&quot;</span>&gt;</span>Fetch data<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span>Waiting for response...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

</section><section>

<h2 id="2007"><a href="#2007" class="headerlink" title="2007"></a>2007</h2><h3 id="2007년-1월"><a href="#2007년-1월" class="headerlink" title="2007년 1월"></a>2007년 1월</h3><!-- #### [The first Apple iPhone is released](https://www.apple.com/newsroom/2007/01/09Apple-Reinvents-the-Phone-with-iPhone/) with its mobile safari not supporting Flash -->
<h4 id="최초의-Apple-iPhone-모바일-사파리에-플래시-배제하고-출시"><a href="#최초의-Apple-iPhone-모바일-사파리에-플래시-배제하고-출시" class="headerlink" title="최초의 Apple iPhone, 모바일 사파리에 플래시 배제하고 출시"></a><a target="_blank" rel="noopener" href="https://www.apple.com/newsroom/2007/01/09Apple-Reinvents-the-Phone-with-iPhone/">최초의 Apple iPhone</a>, 모바일 사파리에 플래시 배제하고 출시</h4><!-- The exclusion of Flash was a deliberate and controversial decision. At the time, Flash was responsible for 90% of interactive multimedia. However, Steve Jobs was against Flash, due to its high resource needs, prone to crashing, and proprietary nature. Developers took this as a sign that the future of mobile web content would not rely on Flash. -->
<p>플래시를 배제한 것은 의도적이면서도 논란이 많은 결정이었습니다. 당시 플래시는 인터랙티브 멀티미디어의 90%를 담당했습니다. 하지만 Steve Jobs는 높은 리소스 요구사항, 충돌 발생 가능성, 그리고 독점적 성격 때문에 플래시에 반대했습니다. 개발자들은 이것을 모바일 웹 콘텐츠의 미래가 플래시에 의존하지 않을 것이라는 신호로 받아들였습니다.</p>
<p><img src="./iphone-safari.webp" alt="iPhone Safari"></p>
</section><section>

<h2 id="2008"><a href="#2008" class="headerlink" title="2008"></a>2008</h2><h3 id="2008년-2월"><a href="#2008년-2월" class="headerlink" title="2008년 2월"></a>2008년 2월</h3><!-- #### [Netscape Navigator is sunset](https://techcrunch.com/2007/12/28/a-sad-milestone-aol-to-discontinue-netscape-browser-development/), marking the end of the "First Browser War" -->
<h4 id="Netscape-내비게이터-서비스-종료로-“첫-번째-브라우저-전쟁”-종결"><a href="#Netscape-내비게이터-서비스-종료로-“첫-번째-브라우저-전쟁”-종결" class="headerlink" title="Netscape 내비게이터 서비스 종료로 “첫 번째 브라우저 전쟁” 종결"></a><a target="_blank" rel="noopener" href="https://techcrunch.com/2007/12/28/a-sad-milestone-aol-to-discontinue-netscape-browser-development/">Netscape 내비게이터 서비스 종료</a>로 “첫 번째 브라우저 전쟁” 종결</h4><!-- AOL officially discontinues Netscape Navigator, which was a dominant browser in the 90's with over 90% market share at its peak, marking the end of an era for one of the most influential web browsers of the early internet. It lost ground to Internet Explorer, because Microsoft bundled with Windows, which led to a landmark anti-trust lawsuit against Microsoft that reshaped tech regulations. -->
<p>AOL이 공식적으로 Netscape Navigator 개발을 중단했습니다. Netscape Navigator는 90년대 전성기에 90% 이상의 시장 점유율을 차지했던 지배적인 브라우저로, 초기 인터넷에서 가장 영향력 있는 웹 브라우저 중 하나였습니다. 이로써 한 시대가 막을 내렸습니다. Microsoft가 Internet Explorer를 Windows에 기본 탑재하면서 시장 주도권을 빼앗았고, 이는 결국 기술 업계 규제의 판도를 바꾼 Microsoft 반독점 소송으로 이어졌습니다.</p>
<p><img src="./browser-wars-1.webp" alt="Browser Wars"></p>
<h3 id="2008년-5월"><a href="#2008년-5월" class="headerlink" title="2008년 5월"></a>2008년 5월</h3><!-- #### Douglas Crockford publishes [「JavaScript: The Good Parts」](https://www.oreilly.com/library/view/javascript-the-good/9780596517748/) -->
<h4 id="Douglas-Crockford-「JavaScript-The-Good-Parts」-한국어판-「자바스크립트-핵심-가이드」-출판"><a href="#Douglas-Crockford-「JavaScript-The-Good-Parts」-한국어판-「자바스크립트-핵심-가이드」-출판" class="headerlink" title="Douglas Crockford, 「JavaScript: The Good Parts」(한국어판: 「자바스크립트 핵심 가이드」) 출판"></a>Douglas Crockford, <a target="_blank" rel="noopener" href="https://www.oreilly.com/library/view/javascript-the-good/9780596517748/">「JavaScript: The Good Parts」(한국어판: 「자바스크립트 핵심 가이드」)</a> 출판</h4><!-- This book reframed JavaScript as a serious language when previously it had been mocked for poor design and confusing behavior. -->
<p>이 책은 이전에 나쁜 설계와 혼란스러운 동작으로 조롱받았던 자바스크립트를 진지한 언어로 재평가했습니다.</p>
<p><img src="./javascript-the-good-parts.webp" alt="JavaScript: The Good Parts"></p>
<h3 id="2008년-9월"><a href="#2008년-9월" class="headerlink" title="2008년 9월"></a>2008년 9월</h3><!-- #### [Google releases the Chrome browser](https://googleblog.blogspot.com/2008/12/google-chrome-beta.html), the fastest web browser at the time, and with it, the V8 engine -->
<h4 id="Google-당시-가장-빠른-웹-브라우저인-Chrome-브라우저-출시-V8-엔진과-함께-제공"><a href="#Google-당시-가장-빠른-웹-브라우저인-Chrome-브라우저-출시-V8-엔진과-함께-제공" class="headerlink" title="Google, 당시 가장 빠른 웹 브라우저인 Chrome 브라우저 출시. V8 엔진과 함께 제공"></a>Google, 당시 가장 빠른 웹 브라우저인 <a target="_blank" rel="noopener" href="https://googleblog.blogspot.com/2008/12/google-chrome-beta.html">Chrome 브라우저</a> 출시. V8 엔진과 함께 제공</h4><!-- At the time, browsers like Internet Explorer, Firefox, and Safari were relatively slow, with limited focus on JavaScript execution speed. Chrome was designed with a focus on speed, using the new V8 JavaScript engine. V8 was innovative in that it compiled JavaScript into native machine code before execution, implemented just-in-time compilation, and managed memory more efficiently through garbage collection. Google would soon open source V8, allowing developers to build on top of it, most notably the Node.js project. -->
<p>당시 Internet Explorer, Firefox, Safari 같은 브라우저들은 상대적으로 느렸고, 자바스크립트 실행 속도에는 별로 신경 쓰지 않았습니다. Chrome은 새로운 V8 자바스크립트 엔진으로 속도에 올인한 브라우저였습니다. V8의 혁신적인 점은 자바스크립트를 실행 전에 네이티브 머신 코드로 컴파일하고, JIT 컴파일을 구현하며, 가비지 컬렉션으로 메모리를 더 효율적으로 관리한다는 것이었습니다. Google은 곧 V8을 오픈소스로 공개해서 개발자들이 이를 기반으로 뭔가를 만들 수 있게 했는데, 그 중에서도 가장 주목할 만한 것이 바로 Node.js 프로젝트입니다.</p>
<p><img src="./chrome-2008.webp" alt="Chrome"></p>
</section><section>

<h2 id="2009"><a href="#2009" class="headerlink" title="2009"></a>2009</h2><h3 id="2009년-1월"><a href="#2009년-1월" class="headerlink" title="2009년 1월"></a>2009년 1월</h3><!-- #### A specification for sharing JavaScript code, CommonJS (originally named ServerJS), is created -->
<h4 id="자바스크립트-코드-공유를-위한-사양인-CommonJS-원래-이름은-ServerJS-등장"><a href="#자바스크립트-코드-공유를-위한-사양인-CommonJS-원래-이름은-ServerJS-등장" class="headerlink" title="자바스크립트 코드 공유를 위한 사양인 CommonJS(원래 이름은 ServerJS) 등장"></a>자바스크립트 코드 공유를 위한 사양인 CommonJS(원래 이름은 ServerJS) 등장</h4><!-- At this point, JavaScript began expanding beyond the browser to the server. Bigger projects were being built and JavaScript needed a better way to handle a lot of source code. It needed modularization. For more information on the history of CommonJS and how we got to where we are today, check out this [blog post](https://deno.com/blog/commonjs-is-hurting-javascript). -->
<p>이 시점부터 자바스크립트가 브라우저를 벗어나 서버 영역으로 진출하기 시작했습니다. 점점 더 큰 프로젝트들이 만들어지면서 자바스크립트에는 방대한 소스 코드를 관리할 수 있는 더 나은 방법, 즉 모듈화가 필요해졌습니다. CommonJS의 역사와 오늘날까지의 발전 과정에 대한 자세한 내용은 이 <a target="_blank" rel="noopener" href="https://deno.com/blog/commonjs-is-hurting-javascript">블로그 포스트</a>를 참고하시기 바랍니다.</p>
<h3 id="2009년-3월"><a href="#2009년-3월" class="headerlink" title="2009년 3월"></a>2009년 3월</h3><!-- #### Ryan Dahl [begins work on Node.js](https://github.com/nodejs/node/blob/1afe6d26dbcf76de15df7e2c8fc3aadbbb8b117d/README) -->
<h4 id="Ryan-Dahl-Node-js-작업-시작"><a href="#Ryan-Dahl-Node-js-작업-시작" class="headerlink" title="Ryan Dahl, Node.js 작업 시작"></a>Ryan Dahl, <a target="_blank" rel="noopener" href="https://github.com/nodejs/node/blob/1afe6d26dbcf76de15df7e2c8fc3aadbbb8b117d/README">Node.js</a> 작업 시작</h4><!-- Node.js, a cross-platform, open source JavaScript runtime environment, allowed the execution of JavaScript outside a web browser. With the introduction of Node.js, developers were able to create web servers and effectively full stack applications entirely in Javascript. Today, Node is used by [~3.5% of all websites](https://w3techs.com/technologies/details/ws-nodejs) (with known servers) and continues to be a predominant technology for building for the web. -->
<p>크로스플랫폼 오픈소스 자바스크립트 런타임 환경인 Node.js는 웹 브라우저 밖에서도 자바스크립트를 실행할 수 있게 해줬습니다. Node.js 덕분에 개발자들은 웹 서버부터 풀스택 애플리케이션까지 모든 것을 자바스크립트 하나로 만들 수 있게 되었습니다. 현재 Node는 <a target="_blank" rel="noopener" href="https://w3techs.com/technologies/details/ws-nodejs">전체 웹사이트의 약 3.5%</a>(서버 정보가 알려진 사이트 기준)에서 사용되고 있으며, 여전히 웹 개발의 핵심 기술로 자리잡고 있습니다.</p>
<p><img src="./ryan-introduces-node.webp" alt="Ryan introduces Node.js"></p>
<!-- Ryan introduces Node.js in a talk a few years later. For an in-depth look at the Node.js project, check out [this one hour-long documentary](https://www.youtube.com/watch?v=LB8KwiiUGy0). -->
<div style="text-align: center">라이언이 몇 년 후 강연에서 Node.js를 소개하고 있습니다.<br/>Node.js 프로젝트에 대한 심층적인 내용은 <a href="https://www.youtube.com/watch?v=LB8KwiiUGy0" target="_blank">이 1시간짜리 다큐멘터리</a>를 확인하시기 바랍니다.</div>

<h3 id="2009년-4월"><a href="#2009년-4월" class="headerlink" title="2009년 4월"></a>2009년 4월</h3><!-- #### [Oracle acquires Sun Microsystems](https://www.oracle.com/corporate/pressrelease/oracle-buys-sun-042009.html), and with it, the JavaScript trademark -->
<h4 id="Oracle-Sun-Microsystems-인수-및-자바스크립트-상표권-획득"><a href="#Oracle-Sun-Microsystems-인수-및-자바스크립트-상표권-획득" class="headerlink" title="Oracle, Sun Microsystems 인수 및 자바스크립트 상표권 획득"></a><a target="_blank" rel="noopener" href="https://www.oracle.com/corporate/pressrelease/oracle-buys-sun-042009.html">Oracle, Sun Microsystems 인수</a> 및 자바스크립트 상표권 획득</h4><!-- Oracle bolsters its position in the enterprise technology market with the purchase of Sun Microsystems and its ownership of Java. As part of the deal, Oracle acquires the trademark for JavaScript, creating confusion for the future of the language. Read more about [our current effort to #FreeJavaScript from Oracle about the trademark.](https://javascript.tm/) -->
<p>Oracle은 Sun Microsystems와 Java 소유권을 인수하여 엔터프라이즈 기술 시장에서의 입지를 강화했습니다. 거래의 일환으로 Oracle은 자바스크립트 상표권을 획득하여 언어의 미래에 혼란을 야기했습니다. <a target="_blank" rel="noopener" href="https://javascript.tm/">상표권에 대한 오라클로부터 #FreeJavaScript를 위한 우리의 현재 노력</a>에 대해 더 자세히 읽어보시기 바랍니다.</p>
<p><img src="./oracle-sun.webp" alt="Oracle Sun"></p>
<h3 id="2009년-6월"><a href="#2009년-6월" class="headerlink" title="2009년 6월"></a>2009년 6월</h3><!-- #### The [first commit on Express.js](https://github.com/expressjs/express/commit/9998490f93d3ad3d56c00d23c0aa13fac41c3f6b) is created -->
<h4 id="Express-js의-첫-번째-커밋-생성됨"><a href="#Express-js의-첫-번째-커밋-생성됨" class="headerlink" title="Express.js의 첫 번째 커밋 생성됨"></a><a target="_blank" rel="noopener" href="https://github.com/expressjs/express/commit/9998490f93d3ad3d56c00d23c0aa13fac41c3f6b">Express.js의 첫 번째 커밋</a> 생성됨</h4><!-- Express.js, a minimal, flexible, extensible web framework for Node.js, is one of the most widely used frameworks in the ecosystem. It introduces a modular middleware architecture with a focus on building RESTful APIs. It's influence on the ecosystem is unparalleled, inspiring frameworks like Koa, Nest, Fastify, and more. Though there was a period of time when the Express project did not receive active commits, today, it is on version 5, and is actively maintained. -->
<p>Express.js는 Node.js 생태계의 절대 강자로 자리잡은 웹 프레임워크입니다. 미니멀하면서도 강력한 설계 철학으로 모듈형 미들웨어 아키텍처를 도입해 RESTful API 개발의 새로운 패러다임을 제시했습니다. 이후 등장한 Koa, Nest, Fastify 등 수많은 프레임워크들이 Express의 영향을 받았을 정도로 업계 표준이 되었습니다. 한때 개발이 정체되어 커뮤니티가 우려했던 시기도 있었지만, 현재는 버전 5까지 발전하며 여전히 활발한 생명력을 보여주고 있습니다.</p>
<p><img src="./express.webp" alt="Express"></p>
<h3 id="2009년-12월"><a href="#2009년-12월" class="headerlink" title="2009년 12월"></a>2009년 12월</h3><!-- #### [ECMAScript 5](https://ecma-international.org/wp-content/uploads/ECMA-262_5th_edition_december_2009.pdf) adds a `strict mode`, getters and setters, new array methods, JSON support, `string.trim()`, trailing commas for object literals -->
<h4 id="ECMAScript-5-출시-strict-mode-getter와-setter-새로운-배열-메서드-JSON-지원-string-trim-객체-리터럴의-후행-쉼표-등이-추가됨"><a href="#ECMAScript-5-출시-strict-mode-getter와-setter-새로운-배열-메서드-JSON-지원-string-trim-객체-리터럴의-후행-쉼표-등이-추가됨" class="headerlink" title="ECMAScript 5 출시 - strict mode, getter와 setter, 새로운 배열 메서드, JSON 지원, string.trim(), 객체 리터럴의 후행 쉼표 등이 추가됨"></a><a target="_blank" rel="noopener" href="https://ecma-international.org/wp-content/uploads/ECMA-262_5th_edition_december_2009.pdf">ECMAScript 5</a> 출시 - <code>strict mode</code>, getter와 setter, 새로운 배열 메서드, JSON 지원, <code>string.trim()</code>, 객체 리터럴의 후행 쉼표 등이 추가됨</h4><!-- ECMAScript 5 marked the first major update to the language in 10 years, and introduced features that made JavaScript more powerful, secure, and maintainable. -->
<p>ECMAScript 5는 10년 만에 나온 언어의 첫 번째 대규모 업데이트였습니다. 자바스크립트를 더욱 강력하고 안전하며 유지보수하기 쉽게 만드는 기능들이 대거 추가되었습니다.</p>
<h3 id="2009년-12월-1"><a href="#2009년-12월-1" class="headerlink" title="2009년 12월"></a>2009년 12월</h3><!-- #### The [first commit](https://github.com/jashkenas/coffeescript/commit/8e9d637985d2dc9b44922076ad54ffef7fa8e9c2) to a project named CoffeeScript is created -->
<h4 id="CoffeeScript-프로젝트에-첫-번째-커밋-생성됨"><a href="#CoffeeScript-프로젝트에-첫-번째-커밋-생성됨" class="headerlink" title="CoffeeScript 프로젝트에 첫 번째 커밋 생성됨"></a>CoffeeScript 프로젝트에 <a target="_blank" rel="noopener" href="https://github.com/jashkenas/coffeescript/commit/8e9d637985d2dc9b44922076ad54ffef7fa8e9c2">첫 번째 커밋</a> 생성됨</h4><!-- CoffeeScript was quickly adopted due to cleaner syntax (less boilerplate), arrow functions (before arrow functions), destructuring before ES6, and other quality of life improvements. -->
<p>CoffeeScript는 더 깔끔한 문법(불필요한 코드 줄임), 화살표 함수(정식 화살표 함수보다 먼저), ES6 이전의 구조 분해 할당 등 개발 편의성을 높여주는 기능들 덕분에 빠르게 인기를 얻었습니다.</p>
<p><img src="./coffee-script.webp" alt="CoffeeScript"></p>
</section><section>

<h2 id="2010"><a href="#2010" class="headerlink" title="2010"></a>2010</h2><h3 id="2010년-1월"><a href="#2010년-1월" class="headerlink" title="2010년 1월"></a>2010년 1월</h3><!-- #### [npm 1.0 is released](https://nodejs.org/en/blog/npm/npm-1-0-released/) -->
<h4 id="npm-1-0-출시"><a href="#npm-1-0-출시" class="headerlink" title="npm 1.0 출시"></a><a target="_blank" rel="noopener" href="https://nodejs.org/en/blog/npm/npm-1-0-released/">npm 1.0</a> 출시</h4><!-- A registry for Node and JavaScript, npm, forever changes the way that JavaScript is shared. Now, it is the biggest open source registry in the world, with over 3 million packages. -->
<p>Node와 자바스크립트를 위한 패키지 저장소인 npm은 자바스크립트 공유 방식을 완전히 바꿔놓았습니다. 지금은 300만 개가 넘는 패키지를 보유한 세계 최대의 오픈소스 저장소가 되었습니다.</p>
<p><img src="./npm.webp" alt="npm"></p>
<h3 id="2010년-5월"><a href="#2010년-5월" class="headerlink" title="2010년 5월"></a>2010년 5월</h3><!-- #### [WebStorm 1.0](https://blog.jetbrains.com/phpstorm/2010/05/phpstorm-1-0-webstorm-1-0-are-public-it-is-official/), a new JavaScript IDE by JetBrains, is released -->
<h4 id="JetBrains의-새로운-자바스크립트-IDE인-WebStorm-1-0-출시"><a href="#JetBrains의-새로운-자바스크립트-IDE인-WebStorm-1-0-출시" class="headerlink" title="JetBrains의 새로운 자바스크립트 IDE인 WebStorm 1.0 출시"></a>JetBrains의 새로운 자바스크립트 IDE인 <a target="_blank" rel="noopener" href="https://blog.jetbrains.com/phpstorm/2010/05/phpstorm-1-0-webstorm-1-0-are-public-it-is-official/">WebStorm 1.0</a> 출시</h4><!-- Prior to WebStorm, text editors provided minimal support for JavaScript. WebStorm was the first dedicated JavaScript IDE that offered advance features like code analysis, error detection, code completion for JS/HTML/CSS, and debugging tools tailored to JavaScript. -->
<p>WebStorm 이전의 텍스트 에디터들은 자바스크립트에 대한 기본적인 기능만 제공했습니다. WebStorm은 코드 분석, 오류 감지, JS/HTML/CSS 자동완성, 자바스크립트 전용 디버깅 도구 등의 고급 기능을 갖춘 최초의 전문 자바스크립트 IDE였습니다.</p>
<h3 id="2010년-10월"><a href="#2010년-10월" class="headerlink" title="2010년 10월"></a>2010년 10월</h3><!-- #### AngularJS and [Backbone.js](https://cdn.statically.io/gh/jashkenas/backbone/0.1.0/index.html) are released -->
<h4 id="AngularJS와-Backbone-js-출시"><a href="#AngularJS와-Backbone-js-출시" class="headerlink" title="AngularJS와 Backbone.js 출시"></a>AngularJS와 <a target="_blank" rel="noopener" href="https://cdn.statically.io/gh/jashkenas/backbone/0.1.0/index.html">Backbone.js</a> 출시</h4><!-- As JavaScript improves and developers are searching for newer, faster, easier ways to build more complex servers and applications, two full stack frameworks — AngularJS and Backbone — are released. They become popular for different reasons: Angular was declarative and opinionated; while Backbone was imperative and minimal. This also loosely marks the beginning of the modern Single Page Application ("SPA") and "Framework churn", a term that defines the manic emergence and retirement of several JavaScript frameworks in this era. -->
<p>자바스크립트가 발전하고 개발자들이 더 복잡한 서버와 애플리케이션을 만들 더 새롭고 빠르고 쉬운 방법을 찾으면서, 두 개의 풀스택 프레임워크 — AngularJS와 Backbone — 이 등장했습니다. 각기 다른 이유로 인기를 얻었는데, Angular는 선언적이고 강한 주장이 있었고, Backbone은 명령형이면서 미니멀했습니다. 이 시점은 현대적인 단일 페이지 애플리케이션(“SPA”)의 시작이자, 수많은 자바스크립트 프레임워크가 급속히 등장했다 사라지는 “프레임워크 대혼란”의 서막이기도 합니다.</p>
<p><img src="./angular-backbone.webp" alt="Angular Backbone"></p>
</section><section>

<h2 id="2011"><a href="#2011" class="headerlink" title="2011"></a>2011</h2><h3 id="2011년-6월"><a href="#2011년-6월" class="headerlink" title="2011년 6월"></a>2011년 6월</h3><!-- #### Microsoft and Joyent [ported Node.js to Windows](https://nodejs.org/en/blog/uncategorized/porting-node-to-windows-with-microsofts-help) -->
<h4 id="Microsoft와-Joyent-Node-js를-Windows로-이식"><a href="#Microsoft와-Joyent-Node-js를-Windows로-이식" class="headerlink" title="Microsoft와 Joyent, Node.js를 Windows로 이식"></a>Microsoft와 Joyent, <a target="_blank" rel="noopener" href="https://nodejs.org/en/blog/uncategorized/porting-node-to-windows-with-microsofts-help">Node.js를 Windows로 이식</a></h4><!-- In 2011, [Ryan Dahl of Joyent and Bert Belder (current Deno co-founder/CTO) ported Node.js to Windows](https://tinyclouds.org/iocp_links), a significant milestone that expanded Node.js's reach beyond Unix-based systems. One result from this effort was [libuv](https://github.com/libuv/libuv), a library that offers a unified interface for asynchronous networking on Linux, OSX, and Windows. This not only accelerated Node.js's growth but also set the stage for Microsoft's broader open-source strategy, ultimately transforming its developer ecosystem and paving the way for future initiatives like TypeScript, VS Code, and Azure Cloud Integration. -->
<p>2011년에 <a target="_blank" rel="noopener" href="https://tinyclouds.org/iocp_links">Joyent의 Ryan Dahl과 Bert Belder(현재 Deno 공동 창립자/CTO)가 Node.js를 Windows로 이식</a>했는데, 이는 Node.js가 Unix 계열 시스템을 넘어 확장되는 중요한 전환점이었습니다. 이 작업의 산물 중 하나가 Linux, OSX, Windows에서 비동기 네트워킹을 위한 통합 인터페이스를 제공하는 라이브러리 <a target="_blank" rel="noopener" href="https://github.com/libuv/libuv">libuv</a>였습니다. 이는 Node.js의 성장을 가속화했을 뿐만 아니라 Microsoft의 광범위한 오픈소스 전략의 발판을 마련했고, 결국 개발자 생태계를 변화시키며 TypeScript, VS Code, Azure Cloud Integration 같은 미래 프로젝트들의 길을 열었습니다.</p>
<p><img src="./libuv.webp" alt="libuv"></p>
</section><section>

<h2 id="2012"><a href="#2012" class="headerlink" title="2012"></a>2012</h2><h3 id="2012년-3월"><a href="#2012년-3월" class="headerlink" title="2012년 3월"></a>2012년 3월</h3><!-- #### [Webpack, a module bundler, is introduced](https://libraries.io/npm/webpack/0.1.0) -->
<h4 id="모듈-번들러-Webpack-등장"><a href="#모듈-번들러-Webpack-등장" class="headerlink" title="모듈 번들러 Webpack 등장"></a>모듈 번들러 <a target="_blank" rel="noopener" href="https://libraries.io/npm/webpack/0.1.0">Webpack</a> 등장</h4><!-- Webpack allowed developers to import anything to the client-side and eventually became the core build system behind React, Angular, Vue, and more. It laid the groundwork for Rollup, Parcel, Vite, and esbuild. -->
<p>Webpack은 개발자들이 클라이언트 사이드에서 뭐든지 임포트할 수 있게 해줬고, 결국 React, Angular, Vue 등의 핵심 빌드 시스템이 되었습니다. 이후 Rollup, Parcel, Vite, esbuild 같은 도구들의 토대를 마련하기도 했습니다.</p>
<p><img src="./webpack.webp" alt="Webpack"></p>
<h3 id="2012년-10월"><a href="#2012년-10월" class="headerlink" title="2012년 10월"></a>2012년 10월</h3><!-- #### [Microsoft makes TypeScript 0.8 available for the public](https://devblogs.microsoft.com/typescript/announcing-typescript-0-8-1/) -->
<h4 id="Microsoft-TypeScript-0-8-공개"><a href="#Microsoft-TypeScript-0-8-공개" class="headerlink" title="Microsoft, TypeScript 0.8 공개"></a>Microsoft, <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-0-8-1/">TypeScript 0.8</a> 공개</h4><!-- In 2010, Anders Heljsberg (who also created C# and Turbo Pascal) began developing a static typed superset of JavaScript, named TypeScript. The goal of this project was to make it easier to write and maintain JavaScript at scale. In 2012, Microsoft makes it available for the public. TypeScript paved the way for enterprise-grade development in the JavaScript ecosystem, influenced the design of ECMAScript itself, and changed how large applications are built with JavaScript. -->
<p>2010년에 Anders Heljsberg(C#과 Turbo Pascal을 만든 그 사람)이 TypeScript라는 자바스크립트의 정적 타입 확장판을 개발하기 시작했습니다. 이 프로젝트의 목표는 대규모 자바스크립트 작성과 유지보수를 쉽게 만드는 것이었습니다. 2012년에 Microsoft가 이를 공개했습니다. TypeScript는 자바스크립트 생태계에서 기업급 개발의 문을 열었고, ECMAScript 자체 설계에도 영향을 주었으며, 자바스크립트로 대형 애플리케이션을 만드는 방식을 완전히 바꿔놓았습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</section><section>

<h2 id="2013"><a href="#2013" class="headerlink" title="2013"></a>2013</h2><h3 id="2013년-3월"><a href="#2013년-3월" class="headerlink" title="2013년 3월"></a>2013년 3월</h3><!-- #### The first commit to Atom Shell (later renamed to Electron) was created -->
<h4 id="Atom-Shell-나중에-Electron으로-이름-변경-에-첫-번째-커밋-생성됨"><a href="#Atom-Shell-나중에-Electron으로-이름-변경-에-첫-번째-커밋-생성됨" class="headerlink" title="Atom Shell(나중에 Electron으로 이름 변경)에 첫 번째 커밋 생성됨"></a>Atom Shell(나중에 Electron으로 이름 변경)에 첫 번째 커밋 생성됨</h4><!-- Atom Shell (renamed to [Electron](https://www.electronjs.org/) in 2015) lowered the barrier to building cross-platform desktop applications by using web technologies like HTML, CSS, JavaScript. It uses Node.js and Chromium, so developers could access the filesystem, network, and native OS APIs. Originally built to power GitHub's Atom text editor, which launched in public beta in April 2014, Atom Shell was used by some high profile early adopters, such as Slack. This framework played a pivotal role in ushering in an era where web technologies could be used to create desktop applications. -->
<p>Atom Shell(2015년에 <a target="_blank" rel="noopener" href="https://www.electronjs.org/">Electron</a>으로 개명)은 HTML, CSS, 자바스크립트 같은 웹 기술로 크로스플랫폼 데스크톱 앱을 만드는 진입장벽을 확 낮춰줬습니다. Node.js와 Chromium을 사용해서 개발자들이 파일시스템, 네트워크, 네이티브 OS API에 접근할 수 있었습니다. 원래 2014년 4월 공개 베타로 나온 GitHub의 Atom 텍스트 에디터를 위해 만들어졌는데, Slack 같은 유명한 얼리어답터들이 Atom Shell을 사용했습니다. 이 프레임워크는 웹 기술로 데스크톱 애플리케이션을 만들 수 있는 새로운 시대를 여는 데 결정적인 역할을 했습니다.</p>
<p><img src="./electron-downloads.webp" alt="Electron Downloads"></p>
<h3 id="2013년-2월"><a href="#2013년-2월" class="headerlink" title="2013년 2월"></a>2013년 2월</h3><!-- #### Mozilla releases asm.js -->
<h4 id="Mozilla-asm-js-출시"><a href="#Mozilla-asm-js-출시" class="headerlink" title="Mozilla, asm.js 출시"></a>Mozilla, asm.js 출시</h4><!-- asm.js is a strict subset of JavaScript designed to bring near-native performance to the web. Before, JavaScript was not considered suitable for CPU-intensive applications like 3D games and video processing. Developers could convert C/C++ code to asm.js, allowing for existing native applications to run in the browser. This was a huge step forward in the evolution of JavaScript as a serious runtime for computationally expensive applications, and paved the way for WebAssembly a few years later. -->
<p>asm.js는 웹에서 네이티브급 성능을 구현하기 위해 설계된 자바스크립트의 엄격한 부분집합입니다. 이전까지 자바스크립트는 3D 게임이나 동영상 처리 같은 CPU 집약적인 애플리케이션에는 부적합하다고 여겨졌습니다. 개발자들은 C/C++ 코드를 asm.js로 변환해서 기존 네이티브 애플리케이션을 브라우저에서 돌릴 수 있게 되었습니다. 이는 연산 집약적 애플리케이션을 위한 본격적인 런타임으로서 자바스크립트가 진화하는 데 있어 엄청난 도약이었고, 몇 년 후 WebAssembly가 나올 수 있는 토대를 마련했습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">Module</span>(<span class="params">stdlib, foreign, heap</span>) &#123;</span><br><span class="line">  <span class="string">&quot;use asm&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    x = x | <span class="number">0</span>;</span><br><span class="line">    y = y | <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (x + y) | <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">add</span>: add &#125;;</span><br><span class="line">&#125;)(<span class="variable language_">this</span>, &#123;&#125;, <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Module</span>.<span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>)); <span class="comment">// Outputs: 30</span></span><br></pre></td></tr></table></figure>

<h3 id="2013년-4월"><a href="#2013년-4월" class="headerlink" title="2013년 4월"></a>2013년 4월</h3><!-- #### [Valeri Karpov coins the term "MEAN" stack](https://thecodebarbarian.wordpress.com/2013/04/29/easy-web-prototyping-with-mongodb-and-nodejs/) -->
<h4 id="Valeri-Karpov-“MEAN”-스택-용어-창안"><a href="#Valeri-Karpov-“MEAN”-스택-용어-창안" class="headerlink" title="Valeri Karpov, “MEAN” 스택 용어 창안"></a>Valeri Karpov, <a target="_blank" rel="noopener" href="https://thecodebarbarian.wordpress.com/2013/04/29/easy-web-prototyping-with-mongodb-and-nodejs/">“MEAN” 스택</a> 용어 창안</h4><!-- The MEAN stack represents a full stack JavaScript framework that includes MongoDB, Express.js, AngularJS, and Node.js. This terminology became highly influential in shaping modern JavaScript-based web development. -->
<p>MEAN 스택은 MongoDB, Express.js, AngularJS, Node.js를 아우르는 풀스택 자바스크립트 프레임워크를 의미합니다. 이 용어는 현대 자바스크립트 기반 웹 개발을 형성하는 데 엄청난 영향을 미쳤습니다.</p>
<p><img src="./mean-stack.webp" alt="MEAN Stack"></p>
<h3 id="2013년-5월"><a href="#2013년-5월" class="headerlink" title="2013년 5월"></a>2013년 5월</h3><!-- #### Facebook releases React -->
<h4 id="Facebook-React-출시"><a href="#Facebook-React-출시" class="headerlink" title="Facebook, React 출시"></a>Facebook, React 출시</h4><!-- [React](https://react.dev/), created by Jordan Walke, a software engineer at Facebook (now Meta), is a JavaScript library for declaratively building user interfaces. It was first introduced in the Facebook Newsfeed in 2011, and open sourced for the public in May 2013 at JSConf US. React's component-driven approach for building interfaces solidified declarative UI patterns used in apps today. -->
<p>Facebook(현재 Meta)의 소프트웨어 엔지니어 Jordan Walke가 만든 React는 선언적으로 사용자 인터페이스를 만들기 위한 자바스크립트 라이브러리입니다. 2011년 Facebook 뉴스피드에서 처음 도입되었고, 2013년 5월 JSConf US에서 일반에 오픈소스로 공개되었습니다. React의 컴포넌트 중심 인터페이스 구축 방식은 오늘날 앱에서 쓰이는 선언적 UI 패턴을 확실히 자리잡게 했습니다.</p>
<p><img src="./react.webp" alt="React"></p>
<h3 id="2013년-6월"><a href="#2013년-6월" class="headerlink" title="2013년 6월"></a>2013년 6월</h3><!-- #### [Work on ESLint begins](https://github.com/eslint/eslint/commit/a658d7b0e7d915750f18d666823d54ef2129a9af) -->
<h4 id="ESLint-작업-시작"><a href="#ESLint-작업-시작" class="headerlink" title="ESLint 작업 시작"></a><a target="_blank" rel="noopener" href="https://github.com/eslint/eslint/commit/a658d7b0e7d915750f18d666823d54ef2129a9af">ESLint</a> 작업 시작</h4><!-- Nicholas C. Zakas, a prominent JavaScript developer and former lead developer of the Yahoo! User Interface Library (YUI), began work on ESLint, a pluggable and configurable linter tool for identifying and fixing problems in JavaScript code. ESLint quickly became a crucial tool for JavaScript developers, addressing limitations in existing linting tools and setting new standards for code quality and consistency. -->
<p>유명한 자바스크립트 개발자이자 Yahoo! User Interface Library(YUI)의 전 리드 개발자인 Nicholas C. Zakas가 자바스크립트 코드 문제를 찾아내고 고치는 플러그인 방식의 설정 가능한 린터 도구 ESLint 작업을 시작했습니다. ESLint는 순식간에 자바스크립트 개발자들의 필수 도구가 되었고, 기존 린팅 도구의 한계를 해결하며 코드 품질과 일관성의 새로운 기준을 제시했습니다.</p>
<p><img src="./eslint.webp" alt="ESLint"></p>
<h3 id="2013년-7월"><a href="#2013년-7월" class="headerlink" title="2013년 7월"></a>2013년 7월</h3><!-- #### [Gulp is released](https://libraries.io/npm/gulp/0.0.1) -->
<h4 id="Gulp-출시"><a href="#Gulp-출시" class="headerlink" title="Gulp 출시"></a><a target="_blank" rel="noopener" href="https://libraries.io/npm/gulp/0.0.1">Gulp</a> 출시</h4><!-- Eric Schoffstall releases Gulp.js, a streaming build system for automating tasks in web development. Gulp introduced a new way to handle repetitive tasks like minification, compilation, linting, and testing by using a simple, code-centric approach. It quickly gained popularity as a powerful, code-centric alternative to older task runners like Grunt, which was configuration-heavy, and influenced the evolution of modern build tools. -->
<p>Eric Schoffstall이 웹 개발 작업 자동화를 위한 스트리밍 빌드 시스템 Gulp.js를 출시했습니다. Gulp은 간단하고 코드 중심적인 방식으로 압축, 컴파일, 린팅, 테스트 같은 반복 작업을 처리하는 새로운 방법을 제시했습니다. 설정이 복잡했던 Grunt 같은 기존 태스크 러너의 강력하고 코드 중심적인 대안으로 빠르게 인기를 얻었고, 현대 빌드 도구 발전에도 영향을 미쳤습니다.</p>
<p><img src="./gulpjs.webp" alt="Gulp"></p>
</section><section>

<h2 id="2014"><a href="#2014" class="headerlink" title="2014"></a>2014</h2><h3 id="2014년-2월"><a href="#2014년-2월" class="headerlink" title="2014년 2월"></a>2014년 2월</h3><!-- #### [Vue.js is released](https://github.com/vuejs/vue/releases/tag/v0.10.0) -->
<h4 id="Vue-js-출시"><a href="#Vue-js-출시" class="headerlink" title="Vue.js 출시"></a><a target="_blank" rel="noopener" href="https://github.com/vuejs/vue/releases/tag/v0.10.0">Vue.js</a> 출시</h4><!-- Evan You, a former Google engineer, releases Vue.js, a progressive JavaScript framework for building user interfaces. Unlike other frameworks of its time, Vue.js was designed to be approachable, incrementally adoptable, and highly performant, making it one of the most popular and influential frameworks in the modern JavaScript ecosystem. -->
<p>전 Google 엔지니어 Evan You가 사용자 인터페이스 구축을 위한 점진적 자바스크립트 프레임워크 Vue.js를 출시했습니다. 당시 다른 프레임워크들과 달리 Vue.js는 접근하기 쉽고, 단계별로 도입할 수 있으며, 고성능으로 설계되어 현대 자바스크립트 생태계에서 가장 인기 있고 영향력 있는 프레임워크 중 하나가 되었습니다.</p>
<p><img src="./vuejs.webp" alt="Vue.js"></p>
<h3 id="2014년-7월"><a href="#2014년-7월" class="headerlink" title="2014년 7월"></a>2014년 7월</h3><!-- #### [Strongloop purchases open source framework Express](https://web.archive.org/web/20140801150932/http://strongloop.com/strongblog/tj-holowaychuk-sponsorship-of-express/) -->
<h4 id="StrongLoop-오픈소스-프레임워크-Express-인수"><a href="#StrongLoop-오픈소스-프레임워크-Express-인수" class="headerlink" title="StrongLoop, 오픈소스 프레임워크 Express 인수"></a>StrongLoop, 오픈소스 프레임워크 <a target="_blank" rel="noopener" href="https://web.archive.org/web/20140801150932/http://strongloop.com/strongblog/tj-holowaychuk-sponsorship-of-express/">Express 인수</a></h4><!-- StrongLoop (co-founded by Deno co-founder, Bert Belder), a company specializing in enterprise-grade Node.js solutions, acquired the rights to Express.js, with the goal of integrating it into a broader suite of tools focused on APIs and microservices. The community felt that Express's independence would be lost in the acquisition, which led to creating other frameworks such as Koa. Later, IBM acquired StrongLoop in 2015, and in 2019, Express.js joined the OpenJS Foundation, securing its governance and ensuring its long-term sustainability. After 10 years of being at Express 4.x, [Express 5](https://expressjs.com/2024/10/15/v5-release.html) was finally released in October 2024. -->
<p>엔터프라이즈급 Node.js 솔루션을 전문으로 하는 StrongLoop(Deno 공동 창립자 Bert Belder도 공동 창립)이 Express.js의 소유권을 획득했습니다. 목표는 API와 마이크로서비스에 특화된 통합 도구 생태계의 핵심으로 만드는 것이었습니다. 하지만 커뮤니티는 Express의 독립성이 기업 인수로 인해 훼손될 것을 우려했고, 이런 불안감이 Koa 같은 대안 프레임워크 탄생의 원동력이 되었습니다. 이후 2015년 IBM이 StrongLoop을 인수했고, 2019년에 Express.js가 OpenJS Foundation에 합류하면서 중립적 거버넌스를 되찾고 장기적 지속가능성을 확보했습니다. Express 4.x에서 무려 10년을 보낸 후, <a target="_blank" rel="noopener" href="https://expressjs.com/2024/10/15/v5-release.html">Express 5</a>가 드디어 2024년 10월에 세상의 빛을 보게 되었습니다.</p>
<p><img src="./strongloop.webp" alt="StrongLoop"></p>
<h3 id="2014년-9월"><a href="#2014년-9월" class="headerlink" title="2014년 9월"></a>2014년 9월</h3><!-- #### The [first commit to Babel.js](https://github.com/babel/babel/commit/68cf48fd80b526f1ebb26cd7ec45f8d7c95696db) is created -->
<h4 id="Babel-js에-첫-번째-커밋-생성됨"><a href="#Babel-js에-첫-번째-커밋-생성됨" class="headerlink" title="Babel.js에 첫 번째 커밋 생성됨"></a>Babel.js에 <a target="_blank" rel="noopener" href="https://github.com/babel/babel/commit/68cf48fd80b526f1ebb26cd7ec45f8d7c95696db">첫 번째 커밋</a> 생성됨</h4><!-- Originally named [6to5](https://babeljs.io/blog/2015/01/12/6to5-esnext), Babel.js is a JavaScript compiler that allows developers to write modern JavaScript and make it backwards-compatible for older browsers and engines. Babel soon established itself as a standard tool in the ecosystem, being integrated into popular frameworks like React, Vue, and Angular, as well as module bundlers like Webpack, Rollup, and Parcel. -->
<p>원래 <a target="_blank" rel="noopener" href="https://babeljs.io/blog/2015/01/12/6to5-esnext">6to5</a>라는 이름이었던 Babel.js는 개발자들이 현대적인 자바스크립트를 작성하고 오래된 브라우저와 엔진에서 하위 호환되도록 만드는 자바스크립트 컴파일러입니다. Babel은 곧 생태계의 표준 도구로 자리잡았고, React, Vue, Angular와 같은 인기 있는 프레임워크와 Webpack, Rollup, Parcel과 같은 모듈 번들러에 통합되었습니다.</p>
<p><img src="./babel.webp" alt="Babel"></p>
<h3 id="2014년-10월"><a href="#2014년-10월" class="headerlink" title="2014년 10월"></a>2014년 10월</h3><!-- #### [Meteor reaches 1.0](https://blog.meteor.com/meteor-1-0-d0702aab3ef) -->
<h4 id="Meteor-1-0-배포"><a href="#Meteor-1-0-배포" class="headerlink" title="Meteor 1.0 배포"></a><a target="_blank" rel="noopener" href="https://blog.meteor.com/meteor-1-0-d0702aab3ef">Meteor 1.0</a> 배포</h4><!-- Meteor made a splash in web development communities for being a radically simpler way to build real-time, JavaScript-only, full-stack applications. It played a major role in shaping how developers thought about building modern, reactive, real-time web applications. Although Meteor's overall popularity waned as the ecosystem evolved, it's influence can be seen in React, Redux, Firebase, GraphQL, and more. -->
<p>Meteor은 실시간, 자바스크립트 전용, 전체 스택 애플리케이션을 구축하는 근본적으로 더 간단한 방법으로 웹 개발 커뮤니티에서 큰 반향을 일으켰습니다. 개발자들이 현대적이고 반응적이며 실시간 웹 애플리케이션을 구축하는 방법에 대해 생각하는 방식을 형성하는 데 중요한 역할을 했습니다. 생태계가 발전하면서 Meteor의 전반적인 인기는 줄어들었지만, 생태계에 미친 영향은 React, Redux, Firebase, GraphQL 등에서 볼 수 있습니다.</p>
<p><img src="./meteor.webp" alt="Meteor"></p>
<h3 id="2014년-11월"><a href="#2014년-11월" class="headerlink" title="2014년 11월"></a>2014년 11월</h3><!-- #### [Facebook launches Flow](https://engineering.fb.com/2014/11/18/web/flow-a-new-static-type-checker-for-javascript/), a static type checker for JavaScript -->
<h4 id="Facebook-자바스크립트용-정적-타입-검사기-Flow-출시"><a href="#Facebook-자바스크립트용-정적-타입-검사기-Flow-출시" class="headerlink" title="Facebook, 자바스크립트용 정적 타입 검사기 Flow 출시"></a>Facebook, 자바스크립트용 정적 타입 검사기 <a target="_blank" rel="noopener" href="https://engineering.fb.com/2014/11/18/web/flow-a-new-static-type-checker-for-javascript/">Flow</a> 출시</h4><!-- Flow is a static type checker for JavaScript that helps developers catch bugs and type errors during development. Facebook developed it as a way to better maintain its massive codebase and improve developer productivity. By the late 2010s, however, TypeScript became the dominant typed JavaScript language, leading to the decline of Flow. -->
<p>Flow는 개발 중에 버그와 타입 오류를 잡는 데 도움이 되는 자바스크립트용 정적 타입 검사기입니다. Facebook은 거대한 코드베이스를 더 잘 유지하고 개발자 생산성을 향상시키는 방법으로 개발했습니다. 하지만 2010년대 후반에 TypeScript가 지배적인 타입 자바스크립트 언어가 되면서 Flow의 쇠퇴로 이어졌습니다.</p>
<p><img src="./flow.webp" alt="Flow"></p>
<h3 id="2014년-11월-1"><a href="#2014년-11월-1" class="headerlink" title="2014년 11월"></a>2014년 11월</h3><!-- #### [Amazon announces AWS Lambda](https://press.aboutamazon.com/2014/11/amazon-web-services-announces-aws-lambda), powered by Node.js -->
<h4 id="아마존-Node-js로-구동되는-AWS-Lambda-발표"><a href="#아마존-Node-js로-구동되는-AWS-Lambda-발표" class="headerlink" title="아마존, Node.js로 구동되는 AWS Lambda 발표"></a>아마존, Node.js로 구동되는 <a target="_blank" rel="noopener" href="https://press.aboutamazon.com/2014/11/amazon-web-services-announces-aws-lambda">AWS Lambda</a> 발표</h4><!-- Amazon Web Services, already a market leader in cloud computing, introduces a new serverless paradigm with Lambda, which allows developers to upload code and run it in response to events without provisioning infrastructure. At launch, Lambda functions only supported JavaScript with Node.js, thanks to Node.js's event-driven, non-blocking model that fit well with Lambda's stateless and short-lived execution environment. The arrival of AWS Lambda introduced the concept of Function-as-a-Service and kicked off a serverless computing movement, with Google and Microsoft launching their own versions a year or two later. -->
<p>이미 클라우드 컴퓨팅의 시장 선도자였던 Amazon Web Services는 Lambda와 함께 새로운 서버리스 패러다임을 도입했는데, 이는 개발자들이 인프라를 프로비저닝하지 않고도 코드를 업로드하고 이벤트에 응답하여 실행할 수 있게 했습니다. 출시 당시 Lambda 함수는 Node.js와 함께 자바스크립트만 지원했는데, 이는 Node.js의 이벤트 기반, 논블로킹 모델이 Lambda의 무상태 및 단기 실행 환경에 잘 맞았기 때문입니다. AWS Lambda의 도래는 Function-as-a-Service 개념을 도입했고 서버리스 컴퓨팅 운동을 시작했으며, Google과 Microsoft가 1-2년 후에 자체 버전을 출시했습니다.</p>
<p><img src="./aws-lambda.webp" alt="AWS Lambda"></p>
<h3 id="2014년-12월"><a href="#2014년-12월" class="headerlink" title="2014년 12월"></a>2014년 12월</h3><!-- #### [Fedor Indutny creates io.js](https://blog.risingstack.com/iojs-overview/), a fork of Node.js -->
<h4 id="Fedor-Indutny-Node-js의-포크인-io-js-생성"><a href="#Fedor-Indutny-Node-js의-포크인-io-js-생성" class="headerlink" title="Fedor Indutny, Node.js의 포크인 io.js 생성"></a>Fedor Indutny, Node.js의 포크인 <a target="_blank" rel="noopener" href="https://blog.risingstack.com/iojs-overview/">io.js</a> 생성</h4><!-- Node.js, maintained by Joyent at the time, had slow releases and lacked support for modern JavaScript features due to being on an outdated version of V8. Many developers became frustrated that Node.js wasn't evolving fast enough, especially compared to the rapid progress in the browser and frontend world. Thus, the fork io.js was created. The intention is to merge io.js back into Node.js later. -->
<p>당시 Joyent이 유지보수하던 Node.js는 릴리스가 느렸고 오래된 V8 버전으로 인해 현대적인 자바스크립트 기능에 대한 지원이 부족했습니다. 많은 개발자들이 Node.js가 충분히 빠르게 발전하지 못한다고 좌절했는데, 특히 브라우저와 프론트엔드 세계의 빠른 발전에 비해 그랬습니다. 따라서 포크인 io.js가 생성되었습니다. 나중에 io.js를 다시 Node.js로 병합할 계획이었습니다.</p>
<p><img src="./iojs.webp" alt="io.js"></p>
</section><section>

<h2 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h2><h3 id="2015년"><a href="#2015년" class="headerlink" title="2015년"></a>2015년</h3><!-- The term "Jamstack" is coined by Matt Biilmann, CEO of Netlify. -->
<h4 id="Netlify의-CEO-Matt-Biilmann-“Jamstack”-용어-창안"><a href="#Netlify의-CEO-Matt-Biilmann-“Jamstack”-용어-창안" class="headerlink" title="Netlify의 CEO Matt Biilmann, “Jamstack” 용어 창안"></a>Netlify의 CEO Matt Biilmann, <a href="(https://vimeo.com/163522126)">“Jamstack”</a> 용어 창안</h4><!-- Jamstack ("Jam" an acronym for JavaScript, API, and Markup) is a web development architecture pattern for frontend web development that offers better performance, scalability, and developer experience. This marks the start of a new era in modern web development where developers are moving away from SPA-architectures and more towards SSR and SSG. -->
<p>Jamstack(“Jam”은 JavaScript, API, Markup의 줄임말)은 더 나은 성능, 확장성, 개발자 경험을 제공하는 프론트엔드 개발 아키텍처 패턴입니다. 이는 개발자들이 SPA 아키텍처에서 벗어나 SSR과 SSG로 옮겨가는 현대 웹 개발의 새로운 시대의 시작을 알리는 신호였습니다.</p>
<p><img src="./jamstack.webp" alt="Jamstack"></p>
<h3 id="2015년-2월"><a href="#2015년-2월" class="headerlink" title="2015년 2월"></a>2015년 2월</h3><!-- [The Node.js Foundation is introduced.](https://web.archive.org/web/20150613112723/https://nodejs.org/foundation/) -->
<h4 id="Node-js-Foundation-설립"><a href="#Node-js-Foundation-설립" class="headerlink" title="Node.js Foundation 설립"></a><a target="_blank" rel="noopener" href="https://web.archive.org/web/20150613112723/https://nodejs.org/foundation/">Node.js Foundation</a> 설립</h4><!-- Under the umbrella of the Linux Foundation, the Node.js Foundation was established to advance the development and adoption of Node.js by resolving project fragmentation. At the time, io.js, a prominent fork of Node.js, was managed by a group of former Node.js contributors seeking faster releases and better governance, which was merged back into Node.js in June 2015. The Node.js foundation had the support of major tech companies, such as IBM, Microsoft, PayPal, Intel, Fidelity, Joyent, and the Linux Foundation. -->
<p>Linux Foundation 산하에서 Node.js Foundation이 설립되었는데, 프로젝트 분열 문제를 해결해서 Node.js의 개발과 도입을 촉진하겠다는 목적이었습니다. 당시 Node.js의 주요 포크였던 io.js는 더 빠른 릴리스와 더 나은 거버넌스를 원하는 전 Node.js 기여자 그룹이 관리하고 있었는데, 2015년 6월에 Node.js로 다시 합쳐졌습니다. Node.js Foundation은 IBM, Microsoft, PayPal, Intel, Fidelity, Joyent, Linux Foundation 등 주요 기술 기업들의 지원을 받았습니다.</p>
<p><img src="./nodejs-foundation.webp" alt="Node.js Foundation"></p>
<h3 id="2015년-9월"><a href="#2015년-9월" class="headerlink" title="2015년 9월"></a>2015년 9월</h3><!-- [GraphQL](https://deno.com/blog/history-of-javascript), a query language for APIs, is launched -->
<h4 id="API를-위한-쿼리-언어-GraphQL-출시"><a href="#API를-위한-쿼리-언어-GraphQL-출시" class="headerlink" title="API를 위한 쿼리 언어 GraphQL 출시"></a>API를 위한 쿼리 언어 <a target="_blank" rel="noopener" href="https://deno.com/blog/history-of-javascript">GraphQL</a> 출시</h4><!-- Facebook began development on GraphQL in 2012 as a data query language that can be used declaratively. GraphQL offered a new way to access and mutate data, with fewer trips to the server and strong typing. -->
<p>Facebook은 2012년에 선언적으로 사용할 수 있는 데이터 쿼리 언어 GraphQL을 개발하기 시작했습니다. GraphQL은 서버 왕복 횟수를 줄이고 강력한 타입 시스템으로 데이터에 접근하고 변경하는 새로운 방법을 제시했습니다.</p>
<p><img src="./graphql.webp" alt="GraphQL"></p>
<h3 id="2015년-6월"><a href="#2015년-6월" class="headerlink" title="2015년 6월"></a>2015년 6월</h3><!-- [Redux](https://github.com/reduxjs/redux/releases/tag/v0.2.0) is released -->
<h4 id="Redux-출시"><a href="#Redux-출시" class="headerlink" title="Redux 출시"></a><a target="_blank" rel="noopener" href="https://github.com/reduxjs/redux/releases/tag/v0.2.0">Redux</a> 출시</h4><!-- With more and more developers building apps using React, the need for managing state rose. Redux, a predictable state container, was released to help. Now, Redux can be used with a wide variety of JavaScript frameworks. -->
<p>React로 앱을 만드는 개발자가 점점 늘어나면서 상태 관리의 필요성이 커졌습니다. 이를 해결하기 위해 예측 가능한 상태 컨테이너 Redux가 등장했습니다. 지금은 Redux를 다양한 JavaScript 프레임워크와 함께 사용할 수 있습니다.</p>
<p><img src="./redux.webp" alt="Redux"></p>
<h3 id="2015년-6월-1"><a href="#2015년-6월-1" class="headerlink" title="2015년 6월"></a>2015년 6월</h3><!-- [Web assembly is released](https://github.com/WebAssembly/design/issues/150) -->
<h4 id="WebAssembly-출시"><a href="#WebAssembly-출시" class="headerlink" title="WebAssembly 출시"></a><a target="_blank" rel="noopener" href="https://github.com/WebAssembly/design/issues/150">WebAssembly</a> 출시</h4><!-- Web assembly aimed to solve the performance limitations of JavaScript in the browser. It enabled high speed execution of code intensive applications, like games, video editing, and more. It also addressed the need for a portable, secure way to run code written in languages like C/C++ on the web. -->
<p>WebAssembly는 브라우저에서 자바스크립트의 성능 한계를 해결하려는 목적으로 만들어졌습니다. 게임, 동영상 편집 등 연산 집약적인 애플리케이션을 고속으로 실행할 수 있게 해줬습니다. 또한 C/C++ 같은 언어로 작성된 코드를 웹에서 안전하고 이식 가능하게 실행할 수 있는 방법도 제공했습니다.</p>
<p><img src="./webassembly.webp" alt="WebAssembly"></p>
<h3 id="2015년-6월-2"><a href="#2015년-6월-2" class="headerlink" title="2015년 6월"></a>2015년 6월</h3><!-- [Atom, a "hackable" text editor, is released](https://web.archive.org/web/20190809140923/http://blog.atom.io/2015/06/25/atom-1-0.html) -->
<h4 id="“해킹-가능한”-텍스트-에디터-Atom-출시"><a href="#“해킹-가능한”-텍스트-에디터-Atom-출시" class="headerlink" title="“해킹 가능한” 텍스트 에디터 Atom 출시"></a>“해킹 가능한” 텍스트 에디터 <a target="_blank" rel="noopener" href="https://web.archive.org/web/20190809140923/http://blog.atom.io/2015/06/25/atom-1-0.html">Atom</a> 출시</h4><!-- Atom was one of the first highly extensible desktop editors built entirely on web technologies. It emphasized deep customization, letting developers tweak everything from the UI to the core behavior with packages and themes. Not only did Atom validate Atom Shell (now known as Electron) as a framework for developing cross-platform desktop applications, it shifted how developers thought about text editors from tools to platforms. It inspired a wave of modern, extensible, web-powered tools such as VS Code, which adopted and refined many of Atom's core ideas. -->
<p>Atom은 웹 기술로만 만들어진 최초의 고도로 확장 가능한 데스크톱 에디터 중 하나였습니다. 깊이 있는 커스터마이징을 내세워 개발자들이 패키지와 테마로 UI부터 핵심 동작까지 모든 걸 마음대로 조정할 수 있게 했습니다. Atom은 Atom Shell(지금의 Electron)을 크로스플랫폼 데스크톱 앱 개발 프레임워크로 입증했을 뿐만 아니라, 개발자들이 텍스트 에디터를 단순한 도구가 아닌 플랫폼으로 바라보는 시각을 바꿔놓았습니다. Atom의 핵심 아이디어를 받아들이고 발전시킨 VS Code 같은 현대적이고 확장 가능한 웹 기반 도구들의 등장에도 영감을 주었습니다.</p>
<p><img src="./atom1.webp" alt="Atom 1"></p>
<p><img src="./atom2.webp" alt="Atom 2"></p>
<!-- Atom 1.0 was released with this retro announcement video from GitHub. -->
<div style="text-align: center">Atom 1.0은 GitHub의 이 레트로 발표 비디오와 함께 출시되었습니다.</div>

<h3 id="2015년-7월"><a href="#2015년-7월" class="headerlink" title="2015년 7월"></a>2015년 7월</h3><!-- [ECMAScript 6 (ES2015) is released](https://262.ecma-international.org/6.0/) -->
<h4 id="ECMAScript-6-ES2015-출시"><a href="#ECMAScript-6-ES2015-출시" class="headerlink" title="ECMAScript 6 (ES2015) 출시"></a><a target="_blank" rel="noopener" href="https://262.ecma-international.org/6.0/">ECMAScript 6 (ES2015)</a> 출시</h4><!-- With the release of ES6, JavaScript finally got many of the features that developers had been asking for, like the `fetch` API and ESM native module system with `import` and `export`. -->
<p>ES6가 출시되면서 자바스크립트는 드디어 개발자들이 그토록 원했던 많은 기능들을 갖게 되었습니다. <code>fetch</code> API와 <code>import</code>, <code>export</code>를 사용하는 ESM 네이티브 모듈 시스템 같은 것들 말입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com/data&quot;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Network response was not ok: &quot;</span> + response.<span class="property">status</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response.<span class="title function_">text</span>(); <span class="comment">// or response.json() for JSON APIs</span></span><br><span class="line">                              <span class="comment">// JSON API의 경우 response.json() 사용</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;result&quot;</span>).<span class="property">textContent</span> = data;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Fetch error:&quot;</span>, error);</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&quot;Error fetching data.&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button onclick=<span class="string">&quot;getData()&quot;</span>&gt;<span class="title class_">Fetch</span> data&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span>Waiting for response...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2015년-9월-1"><a href="#2015년-9월-1" class="headerlink" title="2015년 9월"></a>2015년 9월</h3><!-- Node.js v0.12 and io.js merge to form Node.js v4.0 -->
<h4 id="Node-js-v0-12와-io-js를-병합한-Node-js-v4-0-출시"><a href="#Node-js-v0-12와-io-js를-병합한-Node-js-v4-0-출시" class="headerlink" title="Node.js v0.12와 io.js를 병합한 Node.js v4.0 출시"></a>Node.js v0.12와 io.js를 병합한 Node.js v4.0 출시</h4><!-- [Node.js v4.0](https://nodejs.org/en/blog/release/v4.0.0) represents countless hours of work in both the Node.js and the io.js project that is combined in a single codebase. The merger, which brings to close a fractured community in which many npm modules became incompatible with one or the other runtime, also brought a Long-Term support schedule and a new semantic versioning scheme. The success of the merger demonstrated the power of open governance and community collaboration. -->
<p><a target="_blank" rel="noopener" href="https://nodejs.org/en/blog/release/v4.0.0">Node.js v4.0</a>은 단일 코드베이스로 결합된 Node.js와 io.js 프로젝트에서 수많은 시간의 작업을 대표합니다. 많은 npm 모듈이 하나 또는 다른 런타임과 호환되지 않는 분열된 커뮤니티를 종결시킨 이 병합은 또한 장기 지원 일정과 새로운 시맨틱 버저닝 체계를 가져왔습니다. 병합의 성공은 오픈 거버넌스와 커뮤니티 협업의 힘을 보여주었습니다.</p>
</section><section>

<h2 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h2><h3 id="2016년-1월"><a href="#2016년-1월" class="headerlink" title="2016년 1월"></a>2016년 1월</h3><!-- [Microsoft open sources Edge's Chakra JavaScript engine](https://opensource.microsoft.com/blog/2016/01/13/microsoft-open-source-edge-chakra-javascript/) -->
<h4 id="Microsoft-Edge의-Chakra-자바스크립트-엔진-오픈소스화"><a href="#Microsoft-Edge의-Chakra-자바스크립트-엔진-오픈소스화" class="headerlink" title="Microsoft, Edge의 Chakra 자바스크립트 엔진 오픈소스화"></a>Microsoft, <a target="_blank" rel="noopener" href="https://opensource.microsoft.com/blog/2016/01/13/microsoft-open-source-edge-chakra-javascript/">Edge의 Chakra 자바스크립트 엔진 오픈소스화</a></h4><!-- Microsoft aimed to attract external contributors and increase adoption beyond their Edge browser by open sourcing Chakra. It attracted significant initial interest from developers, and Microsoft even released a version of Node.js running on Chakra. However, V8 remained the dominant engine, largely due to its massive community and extensive tooling. By 2021, Microsoft announced the deprecation of Chakra, ceasing active development, as Microsoft began transitioning to the Chromium-based Edge that relied on the V8 engine. -->
<p>Microsoft는 Chakra를 오픈소스로 공개하여 외부 기여자를 유치하고 Edge 브라우저를 넘어선 채택을 증가시키고자 했습니다. 개발자들로부터 상당한 초기 관심을 끌었고, Microsoft는 심지어 Chakra에서 실행되는 Node.js 버전도 출시했습니다. 그러나 V8은 거대한 커뮤니티와 광범위한 도구로 인해 여전히 지배적인 엔진으로 남아있었습니다. 2021년에 Microsoft는 V8 엔진에 의존하는 Chromium 기반 Edge로 전환하기 시작하면서 Chakra의 폐지를 발표하고 활발한 개발을 중단했습니다.</p>
<h3 id="2016년-3월"><a href="#2016년-3월" class="headerlink" title="2016년 3월"></a>2016년 3월</h3><!-- Azer Koculu removes [Leftpad from npm](https://en.wikipedia.org/wiki/Npm_left-pad_incident), inadvertently leading to a supply chain attack on the order of millions of users impacted -->
<h4 id="Azer-Koculu-npm에서-Leftpad를-제거하여-의도치-않게-수백만-사용자에-영향을-미치는-공급망-공격-초래"><a href="#Azer-Koculu-npm에서-Leftpad를-제거하여-의도치-않게-수백만-사용자에-영향을-미치는-공급망-공격-초래" class="headerlink" title="Azer Koculu, npm에서 Leftpad를 제거하여 의도치 않게 수백만 사용자에 영향을 미치는 공급망 공격 초래"></a>Azer Koculu, npm에서 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Npm_left-pad_incident">Leftpad를 제거</a>하여 의도치 않게 수백만 사용자에 영향을 미치는 공급망 공격 초래</h4><!-- Commonly known as the ["npm Leftpad incident"](https://en.wikipedia.org/wiki/Npm_left-pad_incident), Azer removes `left-pad` from npm after a dispute with Kik Messenger. As a result, thousands of projects using `left-pad` as a dependency, including React and Babel, were unable to be built or installed. This created a huge disruption across major technology corporations, such as Meta, Netflix, Spotify, and highlighted the staggering magnitude that a supply chain vulnerability might have in the JavaScript ecosystem. Since then, npm changed its policy to limit a users' ability to remove their package. -->
<p>일반적으로 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Npm_left-pad_incident">“npm Leftpad 사건”</a>으로 알려진 이 사건에서 Azer는 Kik Messenger와의 분쟁 후 npm에서 <code>left-pad</code>를 제거했습니다. 그 결과, React와 Babel을 포함하여 <code>left-pad</code>를 의존성으로 사용하는 수천 개의 프로젝트가 빌드되거나 설치될 수 없게 되었습니다. 이는 Meta, Netflix, Spotify와 같은 주요 기술 기업들에 걸쳐 큰 혼란을 야기했고, JavaScript 생태계에서 공급망 취약점이 가질 수 있는 놀라운 규모를 부각시켰습니다. 이후 npm은 사용자가 자신의 패키지를 제거할 수 있는 능력을 제한하는 정책을 변경했습니다.</p>
<h3 id="2016년-4월"><a href="#2016년-4월" class="headerlink" title="2016년 4월"></a>2016년 4월</h3><!-- Microsoft releases [VSCode 1.0](https://code.visualstudio.com/blogs/2016/04/14/vscode-1.0/), a lightweight, fast, cross-platform IDE -->
<h4 id="Microsoft-가볍고-빠른-크로스-플랫폼-IDE-VSCode-1-0-출시"><a href="#Microsoft-가볍고-빠른-크로스-플랫폼-IDE-VSCode-1-0-출시" class="headerlink" title="Microsoft, 가볍고 빠른 크로스 플랫폼 IDE VSCode 1.0 출시"></a>Microsoft, 가볍고 빠른 크로스 플랫폼 IDE <a target="_blank" rel="noopener" href="https://code.visualstudio.com/blogs/2016/04/14/vscode-1.0/">VSCode 1.0</a> 출시</h4><!-- Not only was it built on web technologies (Electron, TypeScript), but offered first-class JavaScript and TypeScript support. It quickly disrupted Sublime Text, Atom, and other full IDEs. -->
<p>웹 기술(Electron, TypeScript)로 구축되었을 뿐만 아니라, 최고 수준의 JavaScript와 TypeScript 지원을 제공했습니다. 이는 빠르게 Sublime Text, Atom 및 기타 전체 IDE들을 혼란에 빠뜨렸습니다.</p>
<p><img src="./vscode.webp" alt="VSCode"></p>
<!-- Microsoft announcing VSCode at the Microsoft Build conference in 2015. -->
<div style="text-align: center">2015년 Microsoft Build 컨퍼런스에서 VSCode를 발표하는 Microsoft.</div>

<h3 id="2016년-6월"><a href="#2016년-6월" class="headerlink" title="2016년 6월"></a>2016년 6월</h3><!-- [ECMAScript 2016 is released](https://262.ecma-international.org/7.0/index.html), with exponential operator (`**`) and `array.includes()` method -->
<h4 id="ECMAScript-2016-출시-지수-연산자-와-array-includes-메서드-등-포함"><a href="#ECMAScript-2016-출시-지수-연산자-와-array-includes-메서드-등-포함" class="headerlink" title="ECMAScript 2016 출시 - 지수 연산자(**)와 array.includes() 메서드 등 포함"></a><a target="_blank" rel="noopener" href="https://262.ecma-international.org/7.0/index.html">ECMAScript 2016</a> 출시 - 지수 연산자(<code>**</code>)와 <code>array.includes()</code> 메서드 등 포함</h4><h3 id="2016년-9월"><a href="#2016년-9월" class="headerlink" title="2016년 9월"></a>2016년 9월</h3><!-- [Angular (Angular2) is released](https://web.archive.org/web/20170312063434/http://angularjs.blogspot.com/2016/09/angular2-final.html) -->
<h4 id="Angular-Angular2-출시"><a href="#Angular-Angular2-출시" class="headerlink" title="Angular (Angular2) 출시"></a><a target="_blank" rel="noopener" href="https://web.archive.org/web/20170312063434/http://angularjs.blogspot.com/2016/09/angular2-final.html">Angular (Angular2)</a> 출시</h4><!-- Angular was a complete reimagining of the original AngularJS framework, written from scratch to address many of the original framework's shortcomings. Some key differences include replacing the Model-View-Controller with a component tree structure, embracing TypeScript which allowed for better overall tooling, and Ahead-of-Time compilation for performance and security. Angular became a top choice for large-scale enterprise applications due to its structure and opinionated framework. -->
<p>Angular는 원래 AngularJS 프레임워크의 완전한 재상상이었으며, 원래 프레임워크의 많은 단점을 해결하기 위해 처음부터 작성되었습니다. 주요 차이점으로는 Model-View-Controller를 컴포넌트 트리 구조로 대체하고, 더 나은 전체 도구를 가능하게 하는 TypeScript를 채택하며, 성능과 보안을 위한 Ahead-of-Time 컴파일이 포함됩니다. Angular는 그 구조와 의견이 있는 프레임워크로 인해 대규모 엔터프라이즈 애플리케이션의 최고 선택이 되었습니다.</p>
<p><img src="./angular.webp" alt="Angular"></p>
<h3 id="2016년-10월"><a href="#2016년-10월" class="headerlink" title="2016년 10월"></a>2016년 10월</h3><!-- [Next.js 1.0 is released](https://vercel.com/blog/next) -->
<h4 id="Next-js-1-0-출시"><a href="#Next-js-1-0-출시" class="headerlink" title="Next.js 1.0 출시"></a><a target="_blank" rel="noopener" href="https://vercel.com/blog/next">Next.js 1.0</a> 출시</h4><!-- Next.js began as a small framework for server-rendered universal JavaScript web applications, built on React, Webpack, and Babel. Next.js paved the way for full-stack React apps by making server-side rendering with React simple. With Next.js, developers can use React for content heavy, SEO-focused websites. This framework eventually becomes the default framework for production-grade React apps. -->
<p>Next.js는 React, Webpack, Babel을 기반으로 구축된 서버 렌더링 유니버설 JavaScript 웹 애플리케이션을 위한 작은 프레임워크로 시작했습니다. Next.js는 React로 서버 사이드 렌더링을 간단하게 만들어 풀스택 React 앱의 길을 열었습니다. Next.js를 사용하면 개발자들이 콘텐츠가 많고 SEO 중심의 웹사이트에 React를 사용할 수 있습니다. 이 프레임워크는 결국 프로덕션급 React 앱의 기본 프레임워크가 됩니다.</p>
<p><img src="./nextjs.webp" alt="Next.js"></p>
</section><section>

<h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><h3 id="2017년-3월"><a href="#2017년-3월" class="headerlink" title="2017년 3월"></a>2017년 3월</h3><!-- [The initial commit for the Temporal proposal](https://github.com/tc39/proposal-temporal/commit/8a171d1661babda716251250fbdb4dd39f2dd1c2) is created -->
<h4 id="Temporal-제안의-초기-커밋-생성"><a href="#Temporal-제안의-초기-커밋-생성" class="headerlink" title="Temporal 제안의 초기 커밋 생성"></a><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-temporal/commit/8a171d1661babda716251250fbdb4dd39f2dd1c2">Temporal 제안</a>의 초기 커밋 생성</h4><!-- The Temporal proposal was introduced as a solution to long-standing issues with JavaScript's built-in `Date` object, such as lack of immutability, poor timezone and daylight saving time support, and inconsistent parsing. In 2021, the Temporal proposal was approved for inclusion in the ECMAScript standard. However, currently the only environments supporting the Temporal API are Firefox Nightly and Deno. -->
<p>Temporal 제안은 JavaScript의 내장 <code>Date</code> 객체의 불변성 부족, 시간대 및 일광절약시간 지원 부족, 일관성 없는 파싱과 같은 오랜 문제에 대한 해결책으로 도입되었습니다. 2021년에 Temporal 제안은 ECMAScript 표준에 포함되도록 승인되었습니다. 그러나 현재 Temporal API를 지원하는 유일한 환경은 Firefox Nightly와 Deno입니다.</p>
<h3 id="2017년-4월"><a href="#2017년-4월" class="headerlink" title="2017년 4월"></a>2017년 4월</h3><!-- [Prettier 1.0 is released](https://prettier.io/blog/2017/04/13/1.0.0) -->
<h4 id="Prettier-1-0-출시"><a href="#Prettier-1-0-출시" class="headerlink" title="Prettier 1.0 출시"></a><a target="_blank" rel="noopener" href="https://prettier.io/blog/2017/04/13/1.0.0">Prettier 1.0</a> 출시</h4><!-- Prettier is an opinionated code formatter that parses code and reprints it with its own rules to enforce consistent code style, aiming to reduce time wasted on code reviews due to inconsistent formatting. Tools like ESLint focused on detecting issues but didn't automatically fix formatting, which Prettier introduced. Prettier also promoted a write-first, format-later workflow that led to cleaner code and collaboration. Its influence extended beyond JavaScript: Python projects adopted [Black](https://github.com/psf/black), and Rust added a formatter as part of the toolchain, treating formatting as a non-negotiable build step. -->
<p>Prettier는 코드를 파싱하고 자체 규칙으로 다시 출력하여 일관된 코드 스타일을 강제하는 의견이 있는 코드 포맷터로, 일관성 없는 포맷팅으로 인해 코드 리뷰에서 낭비되는 시간을 줄이는 것을 목표로 했습니다. ESLint와 같은 도구들은 문제 감지에 집중했지만 자동으로 포맷팅을 수정하지는 않았는데, 이것을 Prettier가 도입했습니다. Prettier는 또한 먼저 작성하고 나중에 포맷하는 워크플로우를 촉진하여 더 깔끔한 코드와 협업으로 이어졌습니다. 그 영향은 JavaScript를 넘어서 확장되었습니다. Python 프로젝트들은 <a target="_blank" rel="noopener" href="https://github.com/psf/black">Black</a>을 채택했고, Rust는 포맷터를 툴체인의 일부로 추가하여 포맷팅을 협상 불가능한 빌드 단계로 취급했습니다.</p>
<p><img src="./prettier.webp" alt="Prettier"></p>
<h3 id="2017년-6월"><a href="#2017년-6월" class="headerlink" title="2017년 6월"></a>2017년 6월</h3><!-- [ECMAScript 2017 is released](https://262.ecma-international.org/8.0/index.html) with string padding, `Object.entries()`, `Object.values()`, async functions, and more -->
<h4 id="ECMAScript-2017-출시-문자열-패딩-Object-entries-Object-values-async-함수-등-포함"><a href="#ECMAScript-2017-출시-문자열-패딩-Object-entries-Object-values-async-함수-등-포함" class="headerlink" title="ECMAScript 2017 출시 - 문자열 패딩, Object.entries(), Object.values(), async 함수 등 포함"></a><a target="_blank" rel="noopener" href="https://262.ecma-international.org/8.0/index.html">ECMAScript 2017</a> 출시 - 문자열 패딩, <code>Object.entries()</code>, <code>Object.values()</code>, async 함수 등 포함</h4><!-- By 2017, browser support for `fetch()` had become strong across all modern browsers (except IE11), and many developers were using `async`/`await` (with or without Babel). -->
<p>2017년까지 모든 현대 브라우저(IE11 제외)에서 <code>fetch()</code>에 대한 브라우저 지원이 강력해졌고, 많은 개발자가 <code>async</code>/<code>await</code>를 사용하고 있었습니다(Babel과 함께 또는 없이).</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com/data&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;HTTP error &quot;</span> + response.<span class="property">status</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">text</span>(); <span class="comment">// or response.json() for JSON</span></span><br><span class="line">                                          <span class="comment">// JSON의 경우 response.json() 사용</span></span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;result&quot;</span>).<span class="property">textContent</span> = data;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Fetch failed:&quot;</span>, error);</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&quot;Something went wrong!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;getData()&quot;</span>&gt;</span>Load Data<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">pre</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span>Waiting for response...<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2017년-9월"><a href="#2017년-9월" class="headerlink" title="2017년 9월"></a>2017년 9월</h3><!-- [Facebook releases Yarn, a new package manager](https://engineering.fb.com/2016/10/11/web/yarn-a-new-package-manager-for-javascript/) -->
<h4 id="Facebook-새로운-패키지-매니저-Yarn-출시"><a href="#Facebook-새로운-패키지-매니저-Yarn-출시" class="headerlink" title="Facebook, 새로운 패키지 매니저 Yarn 출시"></a>Facebook, 새로운 패키지 매니저 <a target="_blank" rel="noopener" href="https://engineering.fb.com/2016/10/11/web/yarn-a-new-package-manager-for-javascript/">Yarn</a> 출시</h4><!-- Yarn was created to solve the pain points of npm at the time: speed, reliability, and consistency. Yarn introduced concepts like deterministic dependency resolution using `yarn.lock`, automatic package caching, and parallel installation. -->
<p>Yarn은 당시 npm의 고통점인 속도, 신뢰성, 일관성을 해결하기 위해 만들어졌습니다. Yarn은 <code>yarn.lock</code>을 사용한 결정적 의존성 해결, 자동 패키지 캐싱, 병렬 설치 등의 개념을 도입했습니다.</p>
<p><img src="./yarn.webp" alt="Yarn"></p>
<h3 id="2017년-9월-1"><a href="#2017년-9월-1" class="headerlink" title="2017년 9월"></a>2017년 9월</h3><!-- [Cloudflare releases Cloudflare Workers](https://blog.cloudflare.com/introducing-cloudflare-workers/), allowing developers to run JavaScript at the edge -->
<h4 id="Cloudflare-개발자가-Edge에서-JavaScript를-실행할-수-있게-하는-Cloudflare-Workers-출시"><a href="#Cloudflare-개발자가-Edge에서-JavaScript를-실행할-수-있게-하는-Cloudflare-Workers-출시" class="headerlink" title="Cloudflare, 개발자가 Edge에서 JavaScript를 실행할 수 있게 하는 Cloudflare Workers 출시"></a>Cloudflare, 개발자가 Edge에서 JavaScript를 실행할 수 있게 하는 <a target="_blank" rel="noopener" href="https://blog.cloudflare.com/introducing-cloudflare-workers/">Cloudflare Workers</a> 출시</h4><!-- Cloudflare Workers ushered in the modern era of serverless edge computing by combining serverless principles with edge distribution (around 100 data centers at the time, over 300 now) and fast, scalable isolation. Edge distribution meant serverless code could run closer to end users, minimizing latency. Cloudflare Workers being built on lightweight V8 isolation (instead of containers or micro-VMs) also minimized cold start times. The advent of Cloudflare Workers not only transformed Cloudflare from a CDN company providing security and performance for websites into a complete web application platform, but also paved the way for other platforms like Netlify, Vercel, and Deno Deploy to add isolation-based edge functions. -->
<p>Cloudflare Workers는 서버리스 원칙과 Edge 분산(당시 약 100개의 데이터 센터, 현재 300개 이상) 및 빠르고 확장 가능한 격리를 결합하여 서버리스 Edge 컴퓨팅의 현대 시대를 열었습니다. Edge 분산은 서버리스 코드가 최종 사용자 가까이에서 실행될 수 있어 지연 시간을 최소화한다는 의미였습니다. Cloudflare Workers가 경량 V8 격리(컨테이너나 마이크로-VM 대신)를 기반으로 구축되어 콜드 스타트 시간도 최소화되었습니다. Cloudflare Workers의 도래는 Cloudflare를 웹사이트의 보안과 성능을 제공하는 CDN 회사에서 완전한 웹 애플리케이션 플랫폼으로 변화시켰을 뿐만 아니라, Netlify, Vercel, Deno Deploy와 같은 다른 플랫폼들이 격리 기반 엣지 함수를 추가할 수 있는 길을 열었습니다.</p>
<p><img src="./introducing-cloudflare-workers.webp" alt="Cloudflare Workers"></p>
</section><section>

<h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><h3 id="2018년-1월"><a href="#2018년-1월" class="headerlink" title="2018년 1월"></a>2018년 1월</h3><!-- Google releases [Puppeteer 1.0](https://github.com/puppeteer/puppeteer/releases/tag/v1.0.0), marking a major milestone in browser automation tools -->
<h4 id="Google-브라우저-자동화-도구의-주요-이정표를-남긴-Puppeteer-1-0-출시"><a href="#Google-브라우저-자동화-도구의-주요-이정표를-남긴-Puppeteer-1-0-출시" class="headerlink" title="Google, 브라우저 자동화 도구의 주요 이정표를 남긴 Puppeteer 1.0 출시"></a>Google, 브라우저 자동화 도구의 주요 이정표를 남긴 <a target="_blank" rel="noopener" href="https://github.com/puppeteer/puppeteer/releases/tag/v1.0.0">Puppeteer 1.0</a> 출시</h4><!-- Unlike other browser automation tools like Selenium that required multiple language bindings, Puppeteer was built specifically for Node.js, offering a more modern, JavaScript-first API to control headless Chrome. Puppeteer's release established Chromium as the default browser engine for automation, led to the decline of PhantomJS, and influenced the development of frameworks like Playwright and Cypress. -->
<p>여러 언어 바인딩이 필요한 Selenium과 같은 다른 브라우저 자동화 도구와 달리, Puppeteer는 Node.js를 위해 특별히 구축되어 헤드리스 Chrome을 제어하기 위한 더 현대적이고 JavaScript 우선의 API를 제공했습니다. Puppeteer의 출시는 Chromium을 자동화를 위한 기본 브라우저 엔진으로 확립했고, PhantomJS의 쇠퇴를 이끌었으며, Playwright와 Cypress와 같은 프레임워크의 개발에 영향을 주었습니다.</p>
<p><img src="./puppeteer.webp" alt="Puppeteer"></p>
<h3 id="2018년-3월"><a href="#2018년-3월" class="headerlink" title="2018년 3월"></a>2018년 3월</h3><!-- [TensorFlow.js is released](https://www.infoq.com/news/2018/04/tensorflow-javascript-browser/), bringing machine learning to the browser via WebGL or WebGPU without needing compute -->
<h4 id="컴퓨팅-없이-WebGL-또는-WebGPU를-통해-브라우저에-머신러닝을-도입할-수-있게-해주는-TensorFlow-js-출시"><a href="#컴퓨팅-없이-WebGL-또는-WebGPU를-통해-브라우저에-머신러닝을-도입할-수-있게-해주는-TensorFlow-js-출시" class="headerlink" title="컴퓨팅 없이 WebGL 또는 WebGPU를 통해 브라우저에 머신러닝을 도입할 수 있게 해주는 TensorFlow.js 출시"></a>컴퓨팅 없이 WebGL 또는 WebGPU를 통해 브라우저에 머신러닝을 도입할 수 있게 해주는 <a target="_blank" rel="noopener" href="https://www.infoq.com/news/2018/04/tensorflow-javascript-browser/">TensorFlow.js</a> 출시</h4><!-- TensorFlow was released by Google in 2015 as an open-source machine learning (ML) network, and quickly became the go-to tool for ML research. TensorFlow.js lowered the barrier to entry for web developers to implement ML models without Python, as well as embedding ML models into web apps, unlocking real-time predictions and browser-based AI applications. -->
<p>TensorFlow는 Google이 2015년에 오픈소스 머신러닝(ML) 네트워크로 출시했으며, 빠르게 ML 연구의 필수 도구가 되었습니다. TensorFlow.js는 웹 개발자들이 Python 없이 ML 모델을 구현하고, ML 모델을 웹 앱에 임베딩하여 실시간 예측과 브라우저 기반 AI 애플리케이션을 가능하게 하는 진입 장벽을 낮췄습니다.</p>
<p><img src="./tensorflow.webp" alt="TensorFlow"></p>
<h3 id="2018년-6월"><a href="#2018년-6월" class="headerlink" title="2018년 6월"></a>2018년 6월</h3><!-- ECMA TC39 "Smoosh gate" was resolved by renaming `flatten` to `flat` -->
<h4 id="ECMA-TC39의-“Smoosh-gate”-이름을-flatten에서-flat으로-변경하여-해결됨"><a href="#ECMA-TC39의-“Smoosh-gate”-이름을-flatten에서-flat으로-변경하여-해결됨" class="headerlink" title="ECMA TC39의 “Smoosh gate”, 이름을 flatten에서 flat으로 변경하여 해결됨"></a>ECMA TC39의 “Smoosh gate”, 이름을 <code>flatten</code>에서 <code>flat</code>으로 변경하여 해결됨</h4><!-- In 2018, TC39 proposed adding a new method to JavaScript arrays called `flatten` to flatten nested arrays. However, this name clashed with an existing method used by the popular JavaScript library, MooTools, which defined that method in a way that was incompatible with the proposed implementation. In response, some TC39 members jokingly suggested renaming the method from `flatten` to [`smoosh`](https://github.com/tc39/proposal-flatMap/pull/56). While not meant to be taken seriously, it gained traction in discussions and memes. -->
<p>2018년에 TC39는 중첩된 배열을 평탄화하기 위해 자바스크립트 배열에 <code>flatten</code>이라는 새로운 메서드를 추가하는 것을 제안했습니다. 그러나 이 이름은 인기 있는 자바스크립트 라이브러리인 MooTools에서 사용하는 기존 메서드와 충돌했는데, MooTools는 제안된 구현과 호환되지 않는 방식으로 해당 메서드를 정의했습니다. 이에 대응하여 일부 TC39 멤버들이 농담으로 메서드 이름을 <code>flatten</code>에서 <a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-flatMap/pull/56"><code>smoosh</code></a>로 바꾸는 것을 제안했습니다. 진지하게 받아들일 의도는 아니었지만, 토론과 밈에서 주목을 받았습니다.</p>
<p><img src="./smooshgate.webp" alt="Smooshgate"></p>
<h3 id="2018년-6월-1"><a href="#2018년-6월-1" class="headerlink" title="2018년 6월"></a>2018년 6월</h3><!-- Ryan Dahl teases a new project in a talk about his regrets about Node -->
<h4 id="Ryan-Dahl-강연에서-Node-js에-대한-후회와-새로운-프로젝트-언급"><a href="#Ryan-Dahl-강연에서-Node-js에-대한-후회와-새로운-프로젝트-언급" class="headerlink" title="Ryan Dahl, 강연에서 Node.js에 대한 후회와 새로운 프로젝트 언급"></a>Ryan Dahl, 강연에서 Node.js에 대한 후회와 새로운 프로젝트 언급</h4><!-- In 2018, Ryan Dahl announced a new JavaScript runtime named "Deno" (an anagram of Node) during his widely viewed talk ["10 things I regret about Node"](https://www.youtube.com/watch?v=M3BM9TB-8yA). -->
<p>2018년에 Ryan Dahl은 널리 시청된 강연 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=M3BM9TB-8yA">“Node에 대해 후회하는 10가지”</a>에서 “Deno”(Node의 애너그램)라는 새로운 자바스크립트 런타임을 발표했습니다.</p>
<p><img src="./ryan-introduces-deno.webp" alt="Ryan introduces Deno"></p>
<h3 id="2018년-10월"><a href="#2018년-10월" class="headerlink" title="2018년 10월"></a>2018년 10월</h3><!-- [ECMAScript 2018 is released](https://262.ecma-international.org/9.0/) with rest/spread properties, `async` iteration, `promise.finally()`, and more -->
<h4 id="ECMAScript-2018-출시-rest-spread-속성-async-반복-promise-finally-등-포함"><a href="#ECMAScript-2018-출시-rest-spread-속성-async-반복-promise-finally-등-포함" class="headerlink" title="ECMAScript 2018 출시 - rest/spread 속성, async 반복, promise.finally() 등 포함"></a><a target="_blank" rel="noopener" href="https://262.ecma-international.org/9.0/">ECMAScript 2018</a> 출시 - rest/spread 속성, <code>async</code> 반복, <code>promise.finally()</code> 등 포함</h4></section><section>

<h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><h3 id="2019년-3월"><a href="#2019년-3월" class="headerlink" title="2019년 3월"></a>2019년 3월</h3><!-- [The JavaScript Foundation and the Node.js Foundation merge to form the OpenJS Foundation](https://www.linuxfoundation.org/press/press-release/node-js-foundation-and-js-foundation-merge-to-form-openjs-foundation) -->
<h4 id="JavaScript-Foundation과-Node-js-Foundation이-합병하여-OpenJS-Foundation-설립"><a href="#JavaScript-Foundation과-Node-js-Foundation이-합병하여-OpenJS-Foundation-설립" class="headerlink" title="JavaScript Foundation과 Node.js Foundation이 합병하여 OpenJS Foundation 설립"></a>JavaScript Foundation과 Node.js Foundation이 합병하여 <a target="_blank" rel="noopener" href="https://www.linuxfoundation.org/press/press-release/node-js-foundation-and-js-foundation-merge-to-form-openjs-foundation">OpenJS Foundation</a> 설립</h4><!-- At the time, the JavaScript open source ecosystem had been fragmented across multiple foundations, each managing different projects. There was the Node.js Foundation focused on Node.js and server-side JavaScript. Then, there was the JavaScript Foundation, (formerly the jQuery Foundation), which managed client-side libraries like jQuery, ESLint, and Lodash. Both foundations were operating independently, resulting in overlapping resources and fragmented support for JavaScript projects. However, with Node.js becoming the de facto backend runtime for JavaScript and the growth of frontend libraries, the merger aimed to unify governance and support JavaScript as a whole. -->
<p>당시 자바스크립트 오픈소스 생태계는 여러 재단에 걸쳐 분열되어 있었고, 각각이 다른 프로젝트를 관리하고 있었습니다. Node.js와 서버 사이드 자바스크립트에 집중하는 Node.js Foundation이 있었습니다. 그 다음에는 jQuery, ESLint, Lodash와 같은 클라이언트 사이드 라이브러리를 관리하는 JavaScript Foundation(구 jQuery Foundation)이 있었습니다. 두 재단 모두 독립적으로 운영되어 중복되는 자원과 자바스크립트 프로젝트에 대한 분열된 지원을 초래했습니다. 그러나 Node.js가 자바스크립트의 사실상의 백엔드 런타임이 되고 프론트엔드 라이브러리가 성장함에 따라, 병합은 거버넌스를 통합하고 자바스크립트 전체를 지원하는 것을 목표로 했습니다.</p>
<p><img src="./openjsfoundation.webp" alt="OpenJS Foundation"></p>
<h3 id="2019년-4월"><a href="#2019년-4월" class="headerlink" title="2019년 4월"></a>2019년 4월</h3><!-- Node.js added experimental support for ECMAScript modules in [v12.0.0](https://nodejs.org/en/blog/release/v12.0.0) -->
<h4 id="Node-js-v12-0-0에서-ECMAScript-모듈에-대한-실험적-지원-추가"><a href="#Node-js-v12-0-0에서-ECMAScript-모듈에-대한-실험적-지원-추가" class="headerlink" title="Node.js, v12.0.0에서 ECMAScript 모듈에 대한 실험적 지원 추가"></a>Node.js, <a target="_blank" rel="noopener" href="https://nodejs.org/en/blog/release/v12.0.0">v12.0.0</a>에서 ECMAScript 모듈에 대한 실험적 지원 추가</h4><!-- As JavaScript adopted ES modules as a way to modularize and share code, Node.js slowly follows suit. In v12.0.0, Node.js introduces the `.mjs` file extension, the `type` field in `package.json`, and new mechanisms for interoperability with CommonJS. -->
<p>자바스크립트가 코드를 모듈화하고 공유하는 방법으로 ES 모듈을 채택함에 따라, Node.js도 천천히 따라갔습니다. v12.0.0에서 Node.js는 <code>.mjs</code> 파일 확장자, <code>package.json</code>의 <code>type</code> 필드, CommonJS와의 상호 운용성을 위한 새로운 메커니즘을 도입했습니다.</p>
<h3 id="2019년-7월"><a href="#2019년-7월" class="headerlink" title="2019년 7월"></a>2019년 7월</h3><!-- [ECMAScript 2019](https://262.ecma-international.org/10.0/index.html) is released with `Object.fromEntries()`, `String.prototype.trimStart()` and more -->
<h4 id="ECMAScript-2019-출시-Object-fromEntries-String-prototype-trimStart-등-포함"><a href="#ECMAScript-2019-출시-Object-fromEntries-String-prototype-trimStart-등-포함" class="headerlink" title="ECMAScript 2019 출시 - Object.fromEntries(), String.prototype.trimStart() 등 포함"></a><a target="_blank" rel="noopener" href="https://262.ecma-international.org/10.0/index.html">ECMAScript 2019</a> 출시 - <code>Object.fromEntries()</code>, <code>String.prototype.trimStart()</code> 등 포함</h4><h3 id="2019년-11월"><a href="#2019년-11월" class="headerlink" title="2019년 11월"></a>2019년 11월</h3><!-- [Node.js stabilizes support for ECMAScript modules in v13.2.0](https://nodejs.medium.com/announcing-core-node-js-support-for-ecmascript-modules-c5d6dc29b663) -->
<h4 id="Node-js-v13-2-0에서-ECMAScript-모듈-지원-안정화"><a href="#Node-js-v13-2-0에서-ECMAScript-모듈-지원-안정화" class="headerlink" title="Node.js, v13.2.0에서 ECMAScript 모듈 지원 안정화"></a>Node.js, v13.2.0에서 <a target="_blank" rel="noopener" href="https://nodejs.medium.com/announcing-core-node-js-support-for-ecmascript-modules-c5d6dc29b663">ECMAScript 모듈 지원 안정화</a></h4><!-- Node v13.2.0 marks the official stabilization of support for ECMAScript modules, a significant milestone in the Node.js ecosystem. This brought Node.js in line with the modern JavaScript module system, allowing developers to use the standardized `import` and `export` syntax natively. -->
<p>Node v13.2.0은 ECMAScript 모듈 지원의 공식 안정화를 표시하며, 이는 Node.js 생태계의 중요한 이정표입니다. 이는 Node.js를 현대 자바스크립트 모듈 시스템과 일치시켜 개발자들이 표준화된 <code>import</code>와 <code>export</code> 구문을 네이티브로 사용할 수 있게 했습니다.</p>
</section><section>

<h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><h3 id="2020년-5월"><a href="#2020년-5월" class="headerlink" title="2020년 5월"></a>2020년 5월</h3><!-- [JavaScript makes it into space with SpaceX Dragon](https://os-system.com/blog/javascript-in-space-spacex-devs-have-shared-crewdragons-tech-stack/) -->
<h4 id="자바스크립트-SpaceX-Dragon과-함께-우주로-진출"><a href="#자바스크립트-SpaceX-Dragon과-함께-우주로-진출" class="headerlink" title="자바스크립트, SpaceX Dragon과 함께 우주로 진출"></a>자바스크립트, SpaceX Dragon과 함께 <a target="_blank" rel="noopener" href="https://os-system.com/blog/javascript-in-space-spacex-devs-have-shared-crewdragons-tech-stack/">우주로 진출</a></h4><!-- This famous touchscreen interface below runs on Chromium and is fully written in JavaScript. In an [AMA with the SpaceX software engineers](https://www.reddit.com/r/spacex/comments/gxb7j1/we_are_the_spacex_software_team_ask_us_anything/), they cited choosing Chromium gave SpaceX access to lots of programmers skilled with the technology. -->
<p>아래의 유명한 터치스크린 인터페이스는 Chromium에서 실행되며 완전히 자바스크립트로 작성되었습니다. <a target="_blank" rel="noopener" href="https://www.reddit.com/r/spacex/comments/gxb7j1/we_are_the_spacex_software_team_ask_us_anything/">SpaceX 소프트웨어 엔지니어들과의 AMA</a>에서, 그들은 Chromium을 선택한 것이 SpaceX에게 해당 기술에 숙련된 많은 프로그래머들에게 접근할 수 있게 해줬다고 언급했습니다.</p>
<p><img src="./spacex-dragon-screen.webp" alt="SpaceX Dragon Screen"></p>
<h3 id="2020년-5월-1"><a href="#2020년-5월-1" class="headerlink" title="2020년 5월"></a>2020년 5월</h3><!-- Deno 1.0 is released -->
<h4 id="Deno-1-0-출시"><a href="#Deno-1-0-출시" class="headerlink" title="Deno 1.0 출시"></a>Deno 1.0 출시</h4><!-- Ryan Dahl announces [the first major version of Deno](https://deno.com/blog/v1), a batteries-included, complete toolchain for writing modern JavaScript. It launches as a single executable file with first class TypeScript support, opt-in permissions model, and HTTP imports. -->
<p>Ryan Dahl은 현대 자바스크립트 작성을 위한 배터리 포함 완전한 도구체인인 <a target="_blank" rel="noopener" href="https://deno.com/blog/v1">Deno의 첫 번째 주요 버전</a>을 발표합니다. 최고 수준의 TypeScript 지원, 선택적 권한 모델, HTTP 임포트와 함께 단일 실행 파일로 출시됩니다.</p>
<p><img src="./deno-1.webp" alt="Deno 1"></p>
<h3 id="2020년-12월"><a href="#2020년-12월" class="headerlink" title="2020년 12월"></a>2020년 12월</h3><!-- Adobe sunset its Flash software, ending an era of videos and games that left an impression on internet culture -->
<h4 id="Adobe의-Flash-소프트웨어-종료로-인터넷-문화-내-비디오와-게임의-시대-마감"><a href="#Adobe의-Flash-소프트웨어-종료로-인터넷-문화-내-비디오와-게임의-시대-마감" class="headerlink" title="Adobe의 Flash 소프트웨어 종료로 인터넷 문화 내 비디오와 게임의 시대 마감"></a>Adobe의 Flash 소프트웨어 종료로 인터넷 문화 내 비디오와 게임의 시대 마감</h4><!-- For the nostalgic, [the Internet Archive has preserved Flash games and animations](https://www.theverge.com/2020/11/19/internet-archive-preservation-flash-animations-games-adobe). -->
<p>향수를 느끼는 사람들을 위해 <a target="_blank" rel="noopener" href="https://www.theverge.com/2020/11/19/internet-archive-preservation-flash-animations-games-adobe">Internet Archive가 Flash 게임과 애니메이션을 보존했습니다</a>.</p>
<p><img src="./helicoptergame.webp" alt="Helicopter Game"></p>
<!-- Who remembers this helicopter game? -->
<div style="text-align: center">이 헬리콥터 게임을 기억하는 사람이 있나요?</div>

</section><section>

<h2 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h2><h3 id="2022년-6월"><a href="#2022년-6월" class="headerlink" title="2022년 6월"></a>2022년 6월</h3><!-- [Deno joins TC39](https://deno.com/blog/deno-joins-tc39), underscoring the company's vision of embracing JavaScript standards server-side -->
<h4 id="Deno-서버-사이드에서-자바스크립트-표준을-수용하는-회사의-비전-강조하며-TC39에-합류"><a href="#Deno-서버-사이드에서-자바스크립트-표준을-수용하는-회사의-비전-강조하며-TC39에-합류" class="headerlink" title="Deno, 서버 사이드에서 자바스크립트 표준을 수용하는 회사의 비전 강조하며 TC39에 합류"></a>Deno, 서버 사이드에서 자바스크립트 표준을 수용하는 회사의 비전 강조하며 <a target="_blank" rel="noopener" href="https://deno.com/blog/deno-joins-tc39">TC39에 합류</a></h4><h3 id="2022년-6월-1"><a href="#2022년-6월-1" class="headerlink" title="2022년 6월"></a>2022년 6월</h3><!-- [Internet Explorer 11 is retired](https://blogs.windows.com/windowsexperience/2022/06/15/internet-explorer-11-has-retired-and-is-officially-out-of-support-what-you-need-to-know/) -->
<h4 id="Internet-Explorer-11-종료"><a href="#Internet-Explorer-11-종료" class="headerlink" title="Internet Explorer 11 종료"></a><a target="_blank" rel="noopener" href="https://blogs.windows.com/windowsexperience/2022/06/15/internet-explorer-11-has-retired-and-is-officially-out-of-support-what-you-need-to-know/">Internet Explorer 11 종료</a></h4><!-- The retirement of IE11 marked the end of a two-decade-long era dominated by Internet Explorer, which was once the world's most widely used browser. Due to many security vulnerabilities and lack of standards in IE11, this was a pivotal step towards advancing the web ecosystem towards a more standardized, secure, and performant future. -->
<p>IE11의 지원 종료는 한때 세계에서 가장 널리 사용되는 브라우저였던 Internet Explorer가 지배했던 20년간의 시대의 끝을 표시했습니다. IE11의 많은 보안 취약점과 표준 부족으로 인해, 이는 웹 생태계를 더욱 표준화되고 안전하며 성능이 좋은 미래로 발전시키는 중요한 단계였습니다.</p>
<p><img src="./ie-11-retired.webp" alt="IE 11 Retired"></p>
<h3 id="2022년"><a href="#2022년" class="headerlink" title="2022년"></a>2022년</h3><!-- [ECMAScript 2022](https://262.ecma-international.org/13.0/) is released with top-level `await`, new class elements, static block inside classes, and more -->
<h4 id="ECMAScript-2022-출시-최상위-await-새로운-클래스-요소-클래스-내부의-정적-블록-등-포함"><a href="#ECMAScript-2022-출시-최상위-await-새로운-클래스-요소-클래스-내부의-정적-블록-등-포함" class="headerlink" title="ECMAScript 2022 출시 - 최상위 await, 새로운 클래스 요소, 클래스 내부의 정적 블록 등 포함"></a><a target="_blank" rel="noopener" href="https://262.ecma-international.org/13.0/">ECMAScript 2022</a> 출시 - 최상위 <code>await</code>, 새로운 클래스 요소, 클래스 내부의 정적 블록 등 포함</h4></section><section>

<h2 id="2023"><a href="#2023" class="headerlink" title="2023"></a>2023</h2><h3 id="2023년-9월"><a href="#2023년-9월" class="headerlink" title="2023년 9월"></a>2023년 9월</h3><!-- [Bun 1.0 is released](https://bun.sh/blog/bun-v1.0) -->
<h4 id="Bun-1-0-출시"><a href="#Bun-1-0-출시" class="headerlink" title="Bun 1.0 출시"></a><a target="_blank" rel="noopener" href="https://bun.sh/blog/bun-v1.0">Bun 1.0</a> 출시</h4><!-- Another server-side JavaScript runtime (written in Zig) emerges that bills itself the most performant drop-in replacement for Node.js. -->
<p>Node.js의 가장 성능이 좋은 드롭인 대체품이라고 자칭하는 또 다른 서버 사이드 자바스크립트 런타임(Zig로 작성됨)이 등장합니다.</p>
<p><img src="./bun.webp" alt="Bun"></p>
</section><section>

<h2 id="2024"><a href="#2024" class="headerlink" title="2024"></a>2024</h2><h3 id="2024년-2월"><a href="#2024년-2월" class="headerlink" title="2024년 2월"></a>2024년 2월</h3><!-- Node.js selects Rocket Turtle as mascot after design contest -->
<h4 id="Node-js-디자인-콘테스트에서-Rocket-Turtle을-마스코트로-선정"><a href="#Node-js-디자인-콘테스트에서-Rocket-Turtle을-마스코트로-선정" class="headerlink" title="Node.js, 디자인 콘테스트에서 Rocket Turtle을 마스코트로 선정"></a>Node.js, 디자인 콘테스트에서 Rocket Turtle을 마스코트로 선정</h4><!-- The idea of a mascot had been discussed within the Node.js community for years. In 2023, Matteo Collina started [a GitHub issue](https://github.com/nodejs/admin/issues/828) discussing a Node.js mascot, culminating in [a design contest on Twitter](https://x.com/nodejs/status/1713984983566610540). By February, the final design was selected: Rocket Turtle. -->
<p>마스코트 아이디어는 Node.js 커뮤니티 내에서 수년간 논의되어 왔습니다. 2023년에 Matteo Collina가 Node.js 마스코트에 대한 논의를 시작하는 <a target="_blank" rel="noopener" href="https://github.com/nodejs/admin/issues/828">GitHub 이슈</a>를 시작했고, 이는 <a target="_blank" rel="noopener" href="https://x.com/nodejs/status/1713984983566610540">Twitter의 디자인 콘테스트</a>로 이어졌습니다. 2월에 Rocket Turtle이 최종 디자인으로 선택되었습니다.</p>
<p><img src="./nodejs-turtle.webp" alt="Node.js Turtle"></p>
<h3 id="2024년-3월"><a href="#2024년-3월" class="headerlink" title="2024년 3월"></a>2024년 3월</h3><!-- [JSR, a modern, open sourced JavaScript registry, is released](https://deno.com/blog/jsr_open_beta) -->
<h4 id="Deno-현대적인-오픈소스-자바스크립트-레지스트리-JSR-출시"><a href="#Deno-현대적인-오픈소스-자바스크립트-레지스트리-JSR-출시" class="headerlink" title="Deno, 현대적인 오픈소스 자바스크립트 레지스트리 JSR 출시"></a>Deno, 현대적인 오픈소스 자바스크립트 레지스트리 <a target="_blank" rel="noopener" href="https://deno.com/blog/jsr_open_beta">JSR</a> 출시</h4><!-- The Deno team introduces [JSR](https://jsr.io/), the JavaScript registry, which aims to offer a better experience with installing and publishing JavaScript. It only supports ECMAScript modules, can natively understand TypeScript, can work with npm, and offers cross runtime support for Deno, Bun, workerd, and more. -->
<p>Deno 팀은 자바스크립트 설치 및 게시에 더 나은 경험을 제공하는 것을 목표로 하는 자바스크립트 레지스트리인 <a target="_blank" rel="noopener" href="https://jsr.io/">JSR</a>을 소개합니다. ECMAScript 모듈만 지원하고, TypeScript를 네이티브로 이해할 수 있으며, npm과 함께 작동할 수 있고, Deno, Bun, workerd 등에 대한 크로스 런타임 지원을 제공합니다.</p>
<p><img src="./jsr.webp" alt="JSR"></p>
<h3 id="2024년-6월"><a href="#2024년-6월" class="headerlink" title="2024년 6월"></a>2024년 6월</h3><!-- [ECMAScript 2024 is released](https://262.ecma-international.org/15.0/index.html), featuring the `toWellFormed()` method for returning well-formed Unicode strings, and more -->
<h4 id="ECMAScript-2024-출시-잘-형성된-well-formed-Unicode-문자열을-반환하는-toWellFormed-메서드-등-포함"><a href="#ECMAScript-2024-출시-잘-형성된-well-formed-Unicode-문자열을-반환하는-toWellFormed-메서드-등-포함" class="headerlink" title="ECMAScript 2024 출시 - 잘 형성된(well-formed) Unicode 문자열을 반환하는 toWellFormed() 메서드 등 포함"></a><a target="_blank" rel="noopener" href="https://262.ecma-international.org/15.0/index.html">ECMAScript 2024</a> 출시 - 잘 형성된(well-formed) Unicode 문자열을 반환하는 <code>toWellFormed()</code> 메서드 등 포함</h4><h3 id="2024년-9월"><a href="#2024년-9월" class="headerlink" title="2024년 9월"></a>2024년 9월</h3><!-- [The legal battle against Oracle to #FreeJavaScript begins](https://javascript.tm/) -->
<h4 id="Oracle에-대한-FreeJavaScript-법적-투쟁-시작"><a href="#Oracle에-대한-FreeJavaScript-법적-투쟁-시작" class="headerlink" title="Oracle에 대한 #FreeJavaScript 법적 투쟁 시작"></a>Oracle에 대한 <a target="_blank" rel="noopener" href="https://javascript.tm/">#FreeJavaScript 법적 투쟁</a> 시작</h4><!-- When [Ryan Dahl's blog post asking Oracle to release the JavaScript trademark](https://tinyclouds.org/trademark) got some attention from the JavaScript community (and zero comment from Oracle), the Deno team wrote an open letter to Oracle with the intent to challenge Oracle's ownership by filing a petition for cancellation with the USPTO, citing Trademark abandonment. This open letter received nearly 20,000 signatures, including from high profile individuals such as Brendan Eich, Isaac Z. Schlueter, and more. The legal battle is currently ongoing, but you can follow Deno's [X](https://x.com/deno_land) or [Bluesky](https://bsky.app/profile/deno.land) for updates. -->
<p><a target="_blank" rel="noopener" href="https://tinyclouds.org/trademark">Ryan Dahl의 자바스크립트 상표 해제를 요청하는 블로그 포스트</a>가 자바스크립트 커뮤니티로부터 주목을 받았을 때(Oracle로부터는 댓글 없음), Deno 팀은 상표 포기를 근거로 USPTO에 취소 청원을 제출하여 Oracle의 소유권에 도전할 의도로 Oracle에게 공개 서한을 작성했습니다. 이 공개 서한은 Brendan Eich, Isaac Z. Schlueter 등 유명 인사들을 포함하여 거의 20,000개의 서명을 받았습니다. 법적 투쟁은 현재 진행 중이지만, 업데이트는 Deno의 <a target="_blank" rel="noopener" href="https://x.com/deno_land">X</a> 또는 <a target="_blank" rel="noopener" href="https://bsky.app/profile/deno.land">Bluesky</a>를 통해 팔로우할 수 있습니다.</p>
<p><img src="./freejavascript.webp" alt="Free JavaScript"></p>
<h3 id="2024년-10월"><a href="#2024년-10월" class="headerlink" title="2024년 10월"></a>2024년 10월</h3><!-- [Deno 2 is released](https://deno.com/2) -->
<h4 id="Deno-2-출시"><a href="#Deno-2-출시" class="headerlink" title="Deno 2 출시"></a><a target="_blank" rel="noopener" href="https://deno.com/2">Deno 2</a> 출시</h4><!-- [Deno 2](https://deno.com/2) is a major update that touts the simplicity of Deno 1.x but with the backwards compatibility with legacy JavaScript such as Node and npm. With the launch, Deno became [the first JavaScript runtime to publish a commercial](https://www.youtube.com/watch?v=swXWUfufu2w). -->
<p><a target="_blank" rel="noopener" href="https://deno.com/2">Deno 2</a>는 Deno 1.x의 단순성을 자랑하지만 Node와 npm과 같은 레거시 자바스크립트와의 하위 호환성을 갖춘 주요 업데이트입니다. 출시와 함께 Deno는 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=swXWUfufu2w">상업용 광고를 제작한 첫 번째 자바스크립트 런타임</a>이 되었습니다.</p>
<p><img src="./deno-2.webp" alt="Deno 2"></p>
</section><section>

<h2 id="2025"><a href="#2025" class="headerlink" title="2025"></a>2025</h2><h3 id="2025년-3월"><a href="#2025년-3월" class="headerlink" title="2025년 3월"></a>2025년 3월</h3><!-- [TypeScript is ported to Go](https://devblogs.microsoft.com/typescript/typescript-native-port/) -->
<h4 id="TypeScript가-Go로-이식됨"><a href="#TypeScript가-Go로-이식됨" class="headerlink" title="TypeScript가 Go로 이식됨"></a>TypeScript가 <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/typescript-native-port/">Go로 이식</a>됨</h4><!-- TypeScript, originally implemented in TypeScript/JavaScript, has long faced performance challenges as projects have scaled. To address this, Anders Hejlsberg began experimenting with a Go port of TypeScript. Early benchmarks have shown improved speed of around 10x, encouraging the TypeScript team to move forward with the Go port, naming it [`tsgo`](https://github.com/microsoft/typescript-go). The team plans to release the Go port of TypeScript as TypeScript 7.0, once it has sufficient feature parity with the JavaScript-based version. -->
<p>원래 TypeScript/JavaScript로 구현된 TypeScript는 프로젝트가 확장됨에 따라 오랫동안 성능 문제에 직면해 왔습니다. 이를 해결하기 위해 Anders Hejlsberg는 TypeScript의 Go 포트 실험을 시작했습니다. 초기 벤치마크는 약 10배의 속도 향상을 보여주었고, 이는 TypeScript 팀이 <a target="_blank" rel="noopener" href="https://github.com/microsoft/typescript-go"><code>tsgo</code></a>라는 이름의 Go 포트를 진행하도록 격려했습니다. 팀은 자바스크립트 기반 버전과 충분한 기능 패리티를 갖춘 후 TypeScript의 Go 포트를 TypeScript 7.0으로 출시할 계획입니다.</p>
<p><img src="./tsgo.webp" alt="tsgo"></p>
<!-- Anders Hejlsberg introduces a new port of TypeScript. -->
<div style="text-align: center">Anders Hejlsberg가 TypeScript의 새로운 이식 버전을 소개하고 있습니다.</div>

<h3 id="2025년-5월"><a href="#2025년-5월" class="headerlink" title="2025년 5월"></a>2025년 5월</h3><!-- [Microsoft announces it will open source VSCode's Copilot Chat extension](https://code.visualstudio.com/blogs/2025/05/19/openSourceAIEditor) -->
<h4 id="Microsoft-VSCode의-Copilot-Chat을-오픈소스로-공개하기로-발표"><a href="#Microsoft-VSCode의-Copilot-Chat을-오픈소스로-공개하기로-발표" class="headerlink" title="Microsoft, VSCode의 Copilot Chat을 오픈소스로 공개하기로 발표"></a>Microsoft, <a target="_blank" rel="noopener" href="https://code.visualstudio.com/blogs/2025/05/19/openSourceAIEditor">VSCode의 Copilot Chat을 오픈소스로 공개하기로 발표</a></h4><!-- As AI agentic coding heats up with several tools available for developers, Microsoft continues to champion open source by announcing it will license [the GitHub Copilot Chat extension](https://marketplace.visualstudio.com/items?itemName=GitHub.copilot-chat) under the MIT license, with the eventual goal to make VS Code an open source AI editor. This move will encourage the community to refine and build upon common AI interactions across editors, improving the agentic coding experience across all tooling. -->
<p>AI 에이전트 코딩이 개발자들을 위한 여러 도구와 함께 가열됨에 따라, Microsoft는 <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=GitHub.copilot-chat">GitHub Copilot Chat 확장</a>을 MIT 라이선스로 공개할 것이라고 발표했으며, 최종 목표는 VS Code를 오픈소스 AI 에디터로 만드는 것입니다. 이 움직임은 커뮤니티가 에디터 간의 공통 AI 상호작용을 개선하고 구축하도록 격려하여 모든 도구에서 에이전트 코딩 경험을 향상시킬 것입니다.</p>
</section>

<br/>
<br/>
<br/>

<hr>
<br/>
<br/>
<br/>


<!-- **JavaScript has come a long way in its 30-year journey**, from a scrappy scripting language to the backbone of modern web development powering everything from dynamic frontends to full-stack applications, native apps, and even AI tools. Its evolution has been driven by a dedication to open source, a passionate community, an ever-growing ecosystem, and constant innovation. As we celebrate three decades of JavaScript, we're just as excited about where it's heading next: toward faster runtimes, smarter tooling, and a web that's more accessible, powerful, and creative than ever. Here's to the next 30 years of pushing boundaries! -->

<p><strong>자바스크립트는 지난 30년 동안 놀라운 발전을 이뤄왔습니다</strong>. 단순한 스크립팅 언어로 시작했지만, 이제는 동적 프론트엔드부터 풀스택 애플리케이션, 네이티브 앱, 심지어 AI 도구까지 모든 것을 구동하는 현대 웹 개발의 핵심이 되었습니다. 이러한 진화는 오픈소스 정신, 열정적인 커뮤니티, 지속적으로 성장하는 생태계, 그리고 끊임없는 혁신 덕분에 가능했습니다. 자바스크립트의 30년을 축하하는 동시에, 앞으로의 발전 방향에 대해서도 큰 기대를 갖게 됩니다. 더 빠른 런타임, 더 똑똑한 도구, 그리고 지금보다 훨씬 더 접근하기 쉽고 강력하며 창의적인 웹을 향한 여정 말입니다. 경계를 넘나드는 다음 30년을 기대해봅시다!</p>
<style>
.article {
  overflow: visible;
}
.article .article__contents h2 {
  position: sticky;
  top: 80px;
  margin-top: 5rem;
  margin-left: -5.5rem;
  margin-bottom: -2.7rem;
  border-bottom: 0;
  background-color: #fff;
  z-index: -1;
}
.article .article__contents h3 {
  font-size: 0.9rem;
  color: rgb(107, 114, 128);
  margin-top: 3rem;
  margin-bottom: 5px;
}
.article .article__contents h3::before {
  content: '';
  display: inline-block;
  vertical-align: middle;
  border-radius: 50%;
  background-color: rgb(59, 130, 246);
  width: 7px;
  height: 7px;
  margin-left: -14px;
  margin-right: 10px;
}
.article .article__contents h3+h4 {
  margin-top: 0;
  font-weight: 700;
  font-size: 1.4rem;
}
.article .article__contents img {
  display: block;
  width: 80%;
  max-width: 600px;
  margin: 0 auto;
}
@media only screen and (max-width: 767px) {
  .article .article__contents h2 {
    margin-inline: -1rem;
    margin-bottom: 3px;
    z-index: 0;
    top: 0;
    padding: 6px 1rem;
    box-shadow: 0 2px 2px 0 #ccc6;
  }
  .article .article__contents h3::before {
    margin-left: 0;
  }
  .article .article__contents img {
    width: 100%;
  }
}
</style></div><div class="article__tags"><a class="article__tags__item" href="/tags/javascript/">javascript</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="https://www.gravatar.com/avatar/02e9f56a3202da2e6e0e36a5a23facbb" alt="Jaenam Jung"><a class="article__author__link" title="About Jaenam Jung" rel="author">Jaenam Jung</a><p class="article__author__desc">할 수 있는걸 합니다.</p><div class="article__author__socials"><a class="article__author__socials__item" href="http://github.com/roy-jung" title="github" target="_blank"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="Jaenam Jung"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><!-- Giscus Code--><script src="https://giscus.app/client.js" data-repo="roy-jung/roy-jung.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkzMDcyNDQyMDk=" data-category="General" data-category-id="DIC_kwDOElAssc4Cs9i2" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light_protanopia" data-lang="ko" data-loading="lazy" crossorigin="anonymous" async></script><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2025-08-25T09:53:30.028Z"><meta itemprop="articleBody" content="
원문: https://deno.com/blog/history-of-javascript


올해 자바스크립트가 30살이 되었습니다.


지난 30년 동안 자바스크립트는 단 10일 만에 만들어진 이상한 스크립트 언어에서 세계에서 가장 인기 있는 프로그래밍 언어로 성장했습니다. 자바스크립트가 어떻게 발전해왔고 앞으로 어떤 방향으로 나아갈지를 보여주는..."><meta itemprop="url" content="http://roy-jung.github.io/250701-history-of-js/"><meta itemprop="mainEntityOfPage" content="http://roy-jung.github.io/250701-history-of-js/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="FE재남"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="http://roy-jung.github.io/images/logo.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="http://roy-jung.github.io/250701-history-of-js/30th-bday.webp"><meta itemprop="url" content="http://roy-jung.github.io/250701-history-of-js/30th-bday.webp"><meta itemprop="width"><meta itemprop="height"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/250826-tc39-plenary/"><div class="related-posts__item__background" style="background-image:url('/250826-tc39-plenary/banner.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">2025년 5월 TC39 총회 요약 (번역)</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/iterator-helper-overview/"><div class="related-posts__item__background" style="background-image:url('/iterator-helper-overview/iterator-helpers.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">이터레이터 헬퍼 맛보기</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/161007_is-class-only-a-syntactic-sugar/"><div class="related-posts__item__background" style="background-image:url('/images/category-es.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">ES6 Class는 단지 prototype 상속의 문법설탕일 뿐인가?</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/250826-tc39-plenary/">2025년 5월 TC39 총회 요약 (번역)</a></li><li class="recent-posts__item"><a href="/250701-history-of-js/">간략한 자바스크립트 역사 (번역)</a></li><li class="recent-posts__item"><a href="/iterator-helper-overview/">이터레이터 헬퍼 맛보기</a></li><li class="recent-posts__item"><a href="/250414-react-reconciliation-deep-dive/">React Reconciliation: 컴포넌트 뒤에 숨겨진 엔진 (번역)</a></li><li class="recent-posts__item"><a href="/250323-react-server-components/">리액트 서버 컴포넌트 톺아보기 (번역)</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">2025 8월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">2025 7월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">2025 5월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">2025 4월</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">2022 1월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">2020 11월</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">2020 10월</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">2017 1월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">2016 12월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">2016 11월</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">2016 10월</a><span class="archive-list-count">2</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ecmascript/">ECMAScript</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fe/">FE</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/fe/react-js/">React.js</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/fe/react-js/next-js/">Next.js</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/fe/javascript/">javascript</a><span class="category-list-count">6</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/etc/">etc</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><span class="category-list-count">2</span></li></ul></div></div></div><p class="copyright"><small>© 2025 Jaenam Jung<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>