<!DOCTYPE html><html lang="ko-KR"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>ES6 Class는 단지 prototype 상속의 문법설탕일 뿐인가? | FE재남</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="http://roy-jung.github.io/161007_is-class-only-a-syntactic-sugar/"/>
<meta name="description" content="최근 모 커뮤니티에서 ‘ES6를 공부해야 할 필요는 없다’는 의견을 발견하였는데, 그 분의 견해를 읽던 중 ‘Class는 문법설탕일 뿐’이라는 내용에 대해서 정말로 그러한지 알아보고 싶은 마음이 들었습니다.   &#x2F;_ 본 글은 지적 호기심에 따른…">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6 Class는 단지 prototype 상속의 문법설탕일 뿐인가?">
<meta property="og:url" content="http://roy-jung.github.io/161007_is-class-only-a-syntactic-sugar/">
<meta property="og:site_name" content="FE재남">
<meta property="og:description" content="최근 모 커뮤니티에서 ‘ES6를 공부해야 할 필요는 없다’는 의견을 발견하였는데, 그 분의 견해를 읽던 중 ‘Class는 문법설탕일 뿐’이라는 내용에 대해서 정말로 그러한지 알아보고 싶은 마음이 들었습니다.   &#x2F;_ 본 글은 지적 호기심에 따른…">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="http://roy-jung.github.io/images/category-es.png">
<meta property="article:published_time" content="2016-10-06T16:43:00.000Z">
<meta property="article:modified_time" content="2025-04-02T11:37:01.495Z">
<meta property="article:author" content="Jaenam Jung">
<meta property="article:tag" content="ecmascript">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="class">
<meta property="article:tag" content="es6">
<meta property="article:tag" content="es2015">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://roy-jung.github.io/images/category-es.png"><meta property="article:author" content="Jaenam Jung"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2016-10-07 01:43:00"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="Jaenam Jung"><link rel="icon" href="/images/logo.png"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="FE재남"><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/logo.png" alt="FE재남"><span class="menu__item__link--brand__label">FE재남</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">ES6 Class는 단지 prototype 상속의 문법설탕일 뿐인가?</h1><div class="article__meta"><time class="article__meta__time" datetime="2016-10-06T16:43:00.000Z" itemprop="datePublished">2016-10-07 01:43:00</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/ecmascript/">ECMAScript</a></div></div><div class="article__contents"><img src="/images/category-es.png"/><p>최근 모 커뮤니티에서 ‘ES6를 공부해야 할 필요는 없다’는 의견을 발견하였는데, 그 분의 견해를 읽던 중 ‘Class는 문법설탕일 뿐’이라는 내용에 대해서 정말로 그러한지 알아보고 싶은 마음이 들었습니다.</p>
<span id="more"></span>

<p>/_ 본 글은 지적 호기심에 따른 탐구과정을 <code>의식의 흐름 기법</code>에 따라 적어내려간 것이므로 내용전개가 매끄럽지 못할 수 있음을 미리 밝힙니다. _/</p>
<p>우선 구글링을 통해 ‘문법설탕’이라고 정의하고 있는 글들을 찾아보았습니다. 그 중 유명한 사이트의 글들을 일부만 발췌해왔는데, 이외에도 매우 많은 것으로 보아 이 견해가 거의 정론처럼 여겨지고 있는 것 같습니다.</p>
<blockquote>
<p>JavaScript classes introduced in ECMAScript 6 are <strong>syntactical sugar</strong> over JavaScript’s existing prototype-based inheritance. The class syntax is not introducing a new object-oriented inheritance model to JavaScript. - <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">MDN - Classes</a></p>
</blockquote>
<blockquote>
<p>Many features in ES6 (such as destructuring) are, in fact, <strong>syntactic sugar</strong> – and classes are no exception. - <a target="_blank" rel="noopener" href="https://ponyfoo.com/articles/es6-classes-in-depth">ES6 Classes in Depth</a></p>
</blockquote>
<blockquote>
<p>Not “traditional” classes, <strong>syntax sugar</strong> on top of prototypal inheritance - <a target="_blank" rel="noopener" href="https://github.com/bevacqua/es6#classes">ES6 Overview in 350 Bullet Points</a></p>
</blockquote>
<blockquote>
<p>In basic use, the class keyword is <strong>syntactic sugar</strong> for writing constructor functions with prototypes. - <a target="_blank" rel="noopener" href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-classes-with-class">JavaScript Allongé</a></p>
</blockquote>
<p>심지어 ‘전적으로’ 문법설탕이라고 명확히 선을 긋는 사람들도 보입니다.</p>
<blockquote>
<p>They are totally syntactical sugar. - <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/36419713/are-es6-classes-just-syntactic-sugar-for-the-prototypal-pattern-in-javascript">are es6 classes just syntactic sugar for the prototypal pattern in javascript?</a></p>
</blockquote>
<p>그런데 위 링크 중 대부분의 글들은 ‘문법설탕이다’에서 그치지 않고 곧바로 ‘하지만 더 엄격한 제약이 생겼다’는 등의 말을 덧붙이고 있습니다.</p>
<h2 id="What-is-‘Syntatic-Sugar’"><a href="#What-is-‘Syntatic-Sugar’" class="headerlink" title="What is ‘Syntatic Sugar’?"></a>What is ‘Syntatic Sugar’?</h2><blockquote>
<p>16.10.07. 추가 - 하루동안의 반응을 지켜보니 ‘문법설탕’이라는 표현이 전혀 와닿지 않는게 저뿐은 아닌 것 같습니다. 일단은 업계에서 관용적으로 쓰이고 있는 이상 본문에서는 관례에 따르겠지만, ‘편의문법’으로 바꾸자는 목소리도 있으니 적절히 섞어 쓰면서 점차 바꿔나가는 것은 어떨까 싶기도 합니다.</p>
</blockquote>
<p>wikipedia에서는 ‘syntactic sugar’를 다음과 같이 정의하고 있습니다.</p>
<blockquote>
<p>Specifically, a construct in a language is called syntactic sugar if it can be removed from the language without any effect on what the language can do: functionality and expressive power will remain the same. - <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Syntactic_sugar">wikipedia</a></p>
</blockquote>
<p>없는 영어실력으로 발번역 해보자면, <code>어떤 언어에서 제거하더라도 그 언어가 제공하는 기능과 표현력을 똑같이 유지하는 데에 아무런 노력이 필요하지 않은 구조</code> 정도가 될 것 같습니다.</p>
<p>이 정의에 따르자면, 앞서 소개한 링크들 중 ‘ES5와 동일한 기능을 하긴 하지만 보다 엄격한 제약이 따른다’는 주장들이 사실일 경우 Class는 문법설탕이 아니라는 결론이 나오게 됩니다. ‘기능과 표현력은 그대로이지만 완전히 동일한 기능을 수행하지는 않는다’라는 모순된 문장이 만들어지기 때문이죠.</p>
<p>본 글은 문장과 글의 모순을 파헤치려는 목적이 아니므로 단어의 의미를 곱씹는 것은 이정도로 하고, 위 링크들이 말하고자 하는 바를 좀더 알아보고자 합니다. 과연 prototype과 class 사이에 어떤 차이가 있는지 하나하나 살펴보도록 하겠습니다.</p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><h3 id="1-new-keyword"><a href="#1-new-keyword" class="headerlink" title="1) new keyword"></a>1) <code>new</code> keyword</h3><p>기본적으로 ES6 Class의 <code>constructor</code>는 기존의 ‘생성자함수’와 동일한 동작을 합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ES5</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ES6</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> es5 = <span class="keyword">new</span> <span class="title class_">ES5</span>(<span class="string">&#x27;ES5&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> es6 = <span class="keyword">new</span> <span class="title class_">ES6</span>(<span class="string">&#x27;ES6&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(es5.<span class="property">name</span>, es6.<span class="property">name</span>) <span class="comment">// ES5 ES6</span></span><br></pre></td></tr></table></figure>

<p>그런데 ES5에서는 생성자로서의 기능과 일반 함수로서의 기능 모두를 수행할 수 있었던 반면, ES6의 constructor에 같은 방법을 시도하면 문제가 생깁니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ES5</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="keyword">return</span> name + <span class="string">&#x27; es5&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ES6</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="keyword">return</span> name + <span class="string">&#x27; es6&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ES5</span>(<span class="string">&#x27;ES5&#x27;</span>)) <span class="comment">// ES5 es5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ES5</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">constructor</span>(<span class="params"><span class="string">&#x27;ES5&#x27;</span></span>)) <span class="comment">// ES5 es5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ES6</span>(<span class="string">&#x27;ES6&#x27;</span>)) <span class="comment">// Uncaught TypeError</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ES6</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">constructor</span>(<span class="params"><span class="string">&#x27;ES6&#x27;</span></span>)) <span class="comment">// Uncaught TypeError</span></span><br></pre></td></tr></table></figure>

<p>Chrome 개발자도구에서 확인한 오류메시지는 다음과 같습니다.</p>
<blockquote>
<p>Uncaught TypeError: Class constructor ES6 cannot be invoked without ‘new’(…)</p>
</blockquote>
<p>Class의 constructor는 ‘new’ 명령어 없이는 호출할 수 없다고 하는군요.<br>즉, Class의 constructor는 기존의 생성자함수와 달리 함수로서는 동작하지 않으며 오직 생성자로서만 존재할 수 있겠습니다.</p>
<p>혹시 모르니 확인을 해보죠.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">ES6</span>(<span class="string">&#x27;ES6&#x27;</span>)) <span class="comment">// ES6 &#123; name: &quot;ES6&quot; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">ES6</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">constructor</span>(<span class="params"><span class="string">&#x27;ES6&#x27;</span></span>)) <span class="comment">// ES6 &#123; name: &quot;ES6&quot; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> es6 = <span class="keyword">new</span> <span class="title class_">ES6</span>(<span class="string">&#x27;ES6&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> es6.<span class="title function_">constructor</span>(<span class="params"><span class="string">&#x27;ES6 awesome&#x27;</span></span>)) <span class="comment">// ES6 &#123; name: &quot;ES6 awesome&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<p>그렇다면 constructor 메소드 내의 return 값은 return 및 그 이후의 내용은 무시된다는 점을 제외하고는 의미가 없을 것입니다. 어떤 경우에도 return 구문으로부터 결과값을 반환받을 방법이 없을테니까요.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ES6</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="keyword">return</span> name + <span class="string">&#x27; es6&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> es6 = <span class="keyword">new</span> <span class="title class_">ES6</span>(<span class="string">&#x27;es6&#x27;</span>, <span class="number">2015</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(es6) <span class="comment">// ES6 &#123; name: &quot;es6&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-super-and-extends-keyword"><a href="#2-super-and-extends-keyword" class="headerlink" title="2) super and extends keyword"></a>2) <code>super</code> and <code>extends</code> keyword</h3><p>기존 프로토타입 상속 하에서는 자식클래스의 생성자함수가 부모클래스의 생성자 함수의 내용을 덮어씌우는 식으로 동작하므로,<br>기본적으로 부모클래스의 생성자함수를 자식클래스의 생성자함수에서 호출한 것 같은 효과를 얻을 수 없습니다. (물론 프로토타입 체이닝을 통해 값은 전달되겠지만요.)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>, obj.<span class="property">b</span>) <span class="comment">// 1 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;a&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;b&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>만약 자식 클래스에서 부모 클래스의 생성자함수를 그대로 차용하여 실행하기를 원한다면 다음과 같은 복잡한 수행과정을 거쳐야 합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> parentObj = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> parentObj) &#123;</span><br><span class="line">    <span class="variable language_">this</span>[i] = parentObj[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>, obj.<span class="property">b</span>) <span class="comment">// 1 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;a&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;b&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>그러나 이 역시 완벽하지는 않습니다. 부모 클래스에도 여전히 ‘a’ 프로퍼티가 존재하기 때문이죠.<br>결국은 부모 클래스의 값을 복제한 것 이상의 의미를 지니지는 않습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj).<span class="property">a</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj).<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;a&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>한편 ES6에서는 <code>extends</code> 키워드로 subClass를 구현할 수 있는 길을 제공해주고 있으며,<br>이 경우 <code>super</code> 키워드를 통해 부모클래스(superClass)의 constructor를 자식클래스에서 호출할 수 있도록 구현하고 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>, obj.<span class="property">b</span>) <span class="comment">// 1 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;a&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;b&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>또한 Child는 Parent의 인스턴스를 상속받는 것이 아닌 서브클래스로서 Parent의 메소드만을 상속받는 것이므로,<br>Child 인스턴스(obj)의 프로토타입 체인 상에도 Parent의 constructor의 실행 결과는 존재하지 않게 됩니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj).<span class="property">a</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj).<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;a&#x27;</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>물론 ES5에서도 super/subClass를 구현할 수 있긴 하지만, 그러기 위해서는 다음처럼 꽤 복잡한 과정을 거쳐야 합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Proxy</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Proxy</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property">superClass</span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>

<p>위 방법은 임시생성자를 프록시로 활용하는 방법입니다. 위 내용을 토대로 프록시를 외부에 노출시키지 않기 위해 함수로 감싸고, 프록시를 자꾸 생산하지 않게끔 클로저로 감싸고, 최초 실행시부터 클로저가 발동하게끔 즉시실행함수로 감싸는 등을 추가로 수행한 것이 ‘임시생성자(프록시) 활용패턴’으로 알려져 있습니다. 이 프록시 활용패턴의 구현은 중급 자바스크립트 개발자를 위한 교재에서 자주 등장하는 단골 메뉴이기도 했죠.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inherit = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">C, P</span>) &#123;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = P.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    C.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">    C.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span> = C</span><br><span class="line">    C.<span class="property">superClass</span> = P.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inherit</span>(<span class="title class_">Child</span>, <span class="title class_">Parent</span>)</span><br></pre></td></tr></table></figure>

<h2 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h2><h3 id="1-static-method-및-method의-상속"><a href="#1-static-method-및-method의-상속" class="headerlink" title="1) static method 및 method의 상속"></a>1) static method 및 method의 상속</h3><p>ES5에서 static method 및 method를 구현하려면 다음과 같이 작성해야 했습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property">staticMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">s</span> = <span class="number">11</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;static method&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">m</span> = <span class="number">12</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;method&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br></pre></td></tr></table></figure>

<p>ES6 Class의 static method 및 method 선언 방식은 다음과 같습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">staticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">s</span> = <span class="number">11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;static method&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">m</span> = <span class="number">12</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;method&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br></pre></td></tr></table></figure>

<p>상속관계를 되짚어가며 method를 출력해보면 양 쪽 결과가 같습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">method</span>()) <span class="comment">// &#x27;method&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">method</span>()) <span class="comment">// &#x27;method&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">method</span>()) <span class="comment">// &#x27;method&#x27;</span></span><br></pre></td></tr></table></figure>

<p>그러나 static method의 경우에는 결과가 다릅니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">staticMethod</span>()) <span class="comment">// Uncaught TypeError</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Child</span>.<span class="title function_">staticMethod</span>()) <span class="comment">// Uncaught TypeError</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Parent</span>.<span class="title function_">staticMethod</span>()) <span class="comment">// &#x27;static&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">staticMethod</span>()) <span class="comment">// Uncaught TypeError</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Child</span>.<span class="title function_">staticMethod</span>()) <span class="comment">// &#x27;static&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Parent</span>.<span class="title function_">staticMethod</span>()) <span class="comment">// &#x27;static&#x27;</span></span><br></pre></td></tr></table></figure>

<p>앞서 언급한 프록시 생성자 활용패턴을 활용하더라도, superClass의 static method를 subClass에서도 호출 가능하게 하기 위해서는 추가로 해주어야 할 게 있습니다. 즉 Parent의 메소드를 Child에 <strong>복사</strong>하는 것이지요. 단, Child에 같은 이름의 static method가 있다면 Parent의 static method가 덮어씌우게 되니, 그러지 않게끔 접두어나 접미어를 붙여야 합니다. 혹은 프로토타입 체이닝을 통해 직접 superClass에 접근하면 되겠습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inherit = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">C, P</span>) &#123;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = P.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    C.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">    C.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span> = C</span><br><span class="line">    C.<span class="property">superClass</span> = P.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> <span class="keyword">static</span> <span class="keyword">in</span> P) &#123;</span><br><span class="line">      C[<span class="string">&#x27;super_&#x27;</span> + <span class="keyword">static</span>] = P[<span class="keyword">static</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property">method</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;super static&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property">method</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sub static&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inherit</span>(<span class="title class_">Child</span>, <span class="title class_">Parent</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="title function_">method</span>() <span class="comment">// sub static method</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="title function_">super_method</span>() <span class="comment">// super static method</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property">superClass</span>.<span class="property">constructor</span>.<span class="title function_">method</span>() <span class="comment">// super static method</span></span><br></pre></td></tr></table></figure>

<p>이밖에도 Klass 등의 ‘흉내’낸 패턴들이 존재하긴 하지만, 어느 방법에 의하더라도 static method는 ‘복사’하는 외엔 마땅한 대안이 없을 뿐 아니라,<br>subClass의 static method 내에서 superClass의 다른 method를 이용하려면 또다른 방법을 잔뜩 강구해야만 합니다.</p>
<h3 id="2-생성자-함수"><a href="#2-생성자-함수" class="headerlink" title="2) 생성자 함수"></a>2) 생성자 함수</h3><p>ES5의 static method 및 method는 그 자체로 함수이기 때문에 별개의 생성자 함수로 사용할 수 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> methodObj = <span class="keyword">new</span> <span class="title class_">ES5Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">method</span>()</span><br><span class="line"><span class="keyword">var</span> staticObj = <span class="keyword">new</span> <span class="title class_">ES5Parent</span>.<span class="title function_">staticMethod</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(staticObj) <span class="comment">// P…t.staticMethod &#123;s: 11&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(methodObj) <span class="comment">// P…t.method &#123;m: 12&#125;</span></span><br></pre></td></tr></table></figure>

<p>반면 ES6의 static method 및 method는 생성자함수로 활용할 수 없습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> methodObj = <span class="keyword">new</span> <span class="title class_">ES6Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">method</span>()</span><br><span class="line"><span class="keyword">var</span> staticObj = <span class="keyword">new</span> <span class="title class_">ES6Parent</span>.<span class="title function_">staticMethod</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(staticObj) <span class="comment">// Uncaught TypeError</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(methodObj) <span class="comment">// Uncaught TypeError</span></span><br></pre></td></tr></table></figure>

<p>그 원인은 ES5와 ES6의 각 메소드를 개발자도구로 출력해보면 파악할 수 있습니다.</p>
<p><img src="/public/img/2016-10-04-01.png" alt="ES5 static method vs. ES6 static method" style="max-width: 400px; width: 80%; margin: auto"/></p>

<p>그림에서 드러나듯이 ES6의 staticMethod에는 arguments, caller 값이 노출되지 않고 있고, name이 자동으로 지정되어 있으며, prototype이 없습니다. ES6의 shorthand method는 본질적으로는 function에 해당하긴 하지만, 기존 function에서 많은 기능이 제한되어 오직 method로서만 사용할 수 있는 특수한 함수입니다.</p>
<h3 id="3-superClass-메소드-차용"><a href="#3-superClass-메소드-차용" class="headerlink" title="3) superClass 메소드 차용"></a>3) superClass 메소드 차용</h3><p>constructor 파트에서 이미 어느정도 감은 잡으셨겠지만, 보다 확실히 하는 차원에서 method 차용에 대해서도 살펴보겠습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;super&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="variable language_">this</span>).<span class="title function_">method</span>() + <span class="string">&#x27; sub&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">method</span>()) <span class="comment">// &#x27;super sub sub&#x27;</span></span><br></pre></td></tr></table></figure>

<p>ES5에서 부모클래스와 자식클래스에 동일한 메소드를 정의한 경우, 부모클래스의 메소드를 자식클래스에서 호출하려면 위와 같은 탐색과정을 거쳐야 합니다. 그마저도 인스턴스에서 method를 호출하면 <code>__proto__</code>에 위치한 메소드를 마치 인스턴스 자신의 것처럼 사용하기 때문에, 위 메소드에는 최초 실행시 this에는 ‘obj’가 할당되었다가, 재귀적으로 <code>Child.prototype</code>가 할당되었다가, 다시 <code>Parent.prototype</code>이 할당되기 때문에, 본래 의도한 ‘super sub’라는 결과 대신 ‘ sub’가 한 번 더 출력되고 말았습니다. 이 문제를 해결하기 위해서는 조건을 설정하는 등의 노력이 추가되어야 할 것입니다.</p>
<p><code>this</code>를 사용할 경우의 문제점은 ES6 클래스에서도 똑같이 확인됩니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;super&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="variable language_">this</span>).<span class="title function_">method</span>() + <span class="string">&#x27; sub&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">method</span>()) <span class="comment">// &#x27;super sub sub&#x27;</span></span><br></pre></td></tr></table></figure>

<p>그러나 ES6에는 <code>super</code> 키워드가 있어서, <code>this</code> 활용시의 문제점을 피해갈 수 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;super&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">method</span>() + <span class="string">&#x27; sub&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">method</span>()) <span class="comment">// &#x27;super sub&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>super</code> 키워드는 상위클래스’만’을 가리키므로 재귀적으로 여러번 호출될 염려 없이 오직 Parent Class의 메소드만을 상속받아 활용할 수 있습니다.</p>
<h2 id="hoisting"><a href="#hoisting" class="headerlink" title="hoisting"></a>hoisting</h2><p>제가 읽은 거의 모든 자료들은 하나같이 <code>클래스는 호이스팅이 일어나지 않는다</code>고 하고 있습니다. 그 근거로 클래스 선언 전에 해당 클래스를 호출하면 <code>Reference Error</code>를 던지고, 블록 스코프의 영향을 받는 등을 들고 있습니다. 아래는 그 중 몇 개를 발췌한 것이며, 이외에도 굉장히 많습니다.</p>
<blockquote>
<p>class declarations are not hoisted. Therefore, a class only exists after execution reached its definition and it was evaluated. Accessing it beforehand leads to a ReferenceError - <a target="_blank" rel="noopener" href="http://exploringjs.com/es6/ch_classes.html#_base-classes-1">Exploring ES6</a>, <a target="_blank" rel="noopener" href="http://www.2ality.com/2015/02/es6-classes-final.html">2ality</a></p>
</blockquote>
<blockquote>
<p>An important difference between function declarations and class declarations is that function declarations are hoisted and class declarations are not. You first need to declare your class and then access it, otherwise code like the following will throw a ReferenceError - <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">MDN</a></p>
</blockquote>
<blockquote>
<p>The difference between class declarations and function declarations is that functions are hoisted and classes are not. - <a target="_blank" rel="noopener" href="http://stackabuse.com/es6-classes/">stackAbuse</a></p>
</blockquote>
<blockquote>
<p>class declarations can’t be hoisted. - <a target="_blank" rel="noopener" href="https://strongloop.com/strongblog/an-introduction-to-javascript-es6-classes/">StrongLoop</a></p>
</blockquote>
<blockquote>
<p>Class declarations are not hoisted as function declarations are. - <a target="_blank" rel="noopener" href="https://medium.freecodecamp.com/learn-es6-the-dope-way-part-v-classes-browser-compatibility-transpiling-es6-code-47f62267661">freeCodeCamp</a></p>
</blockquote>
<p>반면 ‘hoisting은 일어난다’는 내용은 오직 stackOverflow의 몇몇 질문에 대한 대답에서만 발견할 수 있었습니다.</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/35537619/why-are-es6-classes-not-hoisted">Why are ES6 classes not hoisted?</a></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6">Are variables declared with let or const not hoisted in ES6?</a></p>
</blockquote>
<p>호이스팅이 발생하느냐 발생하지 않느냐에 대한 확인은 뒤로 미루고, 일단 위의 ‘근거’ 두 가지가 모두 사실인지부터 확인해 봅시다. 그런 후에 다시 호이스팅에 대해 다루도록 하겠습니다.</p>
<h3 id="1-ReferenceError"><a href="#1-ReferenceError" class="headerlink" title="1) ReferenceError"></a>1) ReferenceError</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> es5 = <span class="keyword">new</span> <span class="title class_">ES5</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ES5</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(es5) <span class="comment">// ES5 &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">const</span> es6 = <span class="keyword">new</span> <span class="title class_">ES6</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ES6</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(es6) <span class="comment">// Uncaught ReferenceError</span></span><br></pre></td></tr></table></figure>

<p>ES6 Class는 ES5의 생성자함수와 달리 선언 전에 미리 인스턴스를 생성하고자 할 때 ReferenceError가 발생하는 것이 확인되었습니다.</p>
<h3 id="2-Block-Scope"><a href="#2-Block-Scope" class="headerlink" title="2) Block Scope"></a>2) Block Scope</h3><p>ES5의 함수는 ES6의 <code>strict mode</code>에서만 block scope의 영향을 받습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>()) <span class="comment">// A &#123;a: 2&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>()) <span class="comment">// A &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>()) <span class="comment">// A &#123;a: 2&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>()) <span class="comment">// A &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>

<p>한편 ES6의 Class는 언제나 block scope에 종속됩니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>()) <span class="comment">// A &#123;a: 2&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>()) <span class="comment">// A &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>

<p>간단하게 확인이 되었네요. 정리해보면, 클래스는 선언 전에 해당 클래스의 인스턴스를 생성하려 하면 <code>ReferenceError</code>를 던지며, ‘strict mode’ 여부에 무관하게 언제나 block scope의 영향 하에서만 존재할 수 있습니다.</p>
<h3 id="3-hoisting"><a href="#3-hoisting" class="headerlink" title="3) hoisting"></a>3) hoisting</h3><p>다시 한 번 호이스팅을 살펴봅시다.</p>
<p>tc39는 <code>var</code>에 대해 다음과 같이 정의하고 있습니다.</p>
<blockquote>
<p>A <code>var</code> statement declares variables that are scoped to the running execution context’s VariableEnvironment. <strong>Var variables are created when their containing Lexical Environment is instantiated and are initialized to undefined when created.</strong> - <a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/#sec-variable-statement">Variable statement</a></p>
</blockquote>
<p>한편 <code>let</code>, <code>const</code>에 대해서는 다음과 같이 정의하고 있습니다.</p>
<blockquote>
<p><code>let</code> and <code>const</code> declarations define variables that are scoped to the running execution context’s LexicalEnvironment. <strong>The variables are created when their containing Lexical Environment is instantiated but may not be accessed in any way until the variable’s LexicalBinding is evaluated.</strong> A variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer’s AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created. - <a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/#sec-let-and-const-declarations">let and const declarations</a></p>
</blockquote>
<p>위의 정의를 요약해보면 다음과 같습니다. <code>var</code>는 <em>LexicalEnvironment</em> 가 형성될 때 함께 생성되면서 동시에 undefined로 초기화됩니다. 반면 <code>let</code> 및 <code>const</code>는 <em>LexicalEnvironment</em> 가 형성될 때 함께 생성되지만, 이들의 <em>LexicalBinding</em> 이 평가되기 전까지는 접근할 수 없으며, LexicalBinding이 평가되는 시점에 비로소 초기값이 할당됩니다.</p>
<p>여기서 ‘Lexical Environment가 형성될 때 함께 생성됨’ 부분이 hoisting의 정의입니다. <code>var</code>의 ‘undefined 할당’과 <code>let</code> 및 <code>const</code>의 ‘LexicalBinding이 평가되기 전까지는 접근 불가’ 부분은 hoisting과는 별도로 분리하여 논해야 합니다. 그리고 이러한 ‘접근불가’영역을 통상 <strong>TDZ</strong>(Temporal Dead Zone, 임시사각지대)라고 부릅니다.</p>
<blockquote>
<p>TDZ에 대한 자세한 내용은 아래 링크를 참조하세요.</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified/">Temporal Dead Zone Demystified</a></li>
<li><a target="_blank" rel="noopener" href="http://www.2ality.com/2015/10/why-tdz.html">Why there is a TDZ in ES6?</a></li>
</ul>
</blockquote>
<p>TDZ 영역에서 값을 얻으려 하면 ‘ReferenceError’ 오류를 던집니다. Chrome의 오류메시지는 다음과 같습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>위 예제를 놓고 ‘hoisting이 일어나지 않은 것과 다를 바 없지 않느냐’고 생각하실 수도 있겠으나, 다음과 같은 상황에선 생각이 달라지실 것입니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‘hoisting’이 일어나지 않은 상황이라면 전역스코프에서 선언한 a변수의 값 <code>1</code>이 출력되었어야 마땅한 곳에서 ‘ReferenceError’가 발생하고 있습니다. 새로운 블록스코프가 생성됨과 동시에 해당 스코프 내의 <code>a</code> 변수가 생성되었으나, 아직 변수에 초기값이 할당되기 전 상태이기 때문에 ReferenceError를 던지는 것이죠.</p>
<p>앞서 “<code>var</code>의 ‘undefined 할당’과 <code>let</code> 및 <code>const</code>의 ‘LexicalBinding이 평가되기 전까지는 접근 불가’ 부분은 hoisting과는 별도로 분리하여 논해야 한다” 라고 말씀드린 이유가 바로 이것 때문입니다. ES5 환경에서는 변수가 <code>var</code>만 존재했으므로(함수선언문은 논외) hoisting과 undefined 할당을 동일시해도 문제되지 않았으나, 새로운 변수 유형이 생긴 ES6 환경에서는 이를 분리할 필요성이 생긴 것입니다.</p>
<p>뜬금없이 웬 변수 얘기를 하고 있냐면, 위 둘의 차이가 <code>function</code>과 <code>class</code> 사이에도 똑같이 발견되고 있어서 그렇습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>()) <span class="comment">// A &#123;a: 2&#125;</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>()) <span class="comment">// Uncaught ReferenceError: A is not defined</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>class가 선언되기 전 위치에서는 ‘ReferenceError’를 던질 뿐 아니라 class가 block scope의 영향 하에 있는 것에서 미루어보면, hoisting과 관련해서는 <code>class</code>를 <code>let</code> 및 <code>const</code>와 동일하게 취급하고 있다고 볼 수 있겠습니다.</p>
<h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><table>
<thead>
<tr>
<th align="center">기능</th>
<th align="center">ES5</th>
<th align="center">ES6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">constructor를 함수로 실행</td>
<td align="center">O</td>
<td align="center">X</td>
</tr>
<tr>
<td align="center">superClass의 constructor 호출</td>
<td align="center">X(기본). 흉내는 가능하나 한계가 있음</td>
<td align="center">O. super 키워드</td>
</tr>
<tr>
<td align="center">methods 상속</td>
<td align="center">O</td>
<td align="center">O</td>
</tr>
<tr>
<td align="center">methods를 생성자함수로 실행</td>
<td align="center">O</td>
<td align="center">X</td>
</tr>
<tr>
<td align="center">static methods : 상속</td>
<td align="center">X(기본). 흉내는 가능하나 한계가 있음</td>
<td align="center">O</td>
</tr>
<tr>
<td align="center">static methods를 생성자함수로 실행</td>
<td align="center">O</td>
<td align="center">X</td>
</tr>
<tr>
<td align="center">methods: superClass의 메소드 호출</td>
<td align="center">X(기본). 흉내는 가능하나 한계가 있음</td>
<td align="center">O. super 키워드</td>
</tr>
<tr>
<td align="center">hoisting</td>
<td align="center">O</td>
<td align="center">O</td>
</tr>
<tr>
<td align="center">TDZ</td>
<td align="center">X</td>
<td align="center">O</td>
</tr>
</tbody></table>
<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>ES6의 클래스가 ‘prototype’ 상속의 ‘문법설탕’에 불과한지 여부를 확인하기 위해 먼 길을 돌아왔습니다. 기존의 생성자함수와 ES6의 Class는 ‘prototype’을 이용하여 상속관계를 구현했다는 점에서는 같으나 구체적인 성질은 전혀 다른 부분이 많습니다. 특히 super 키워드로 처리 가능한 것들을 기존 방식으로 구현하기 위해서는 매우 많은 노력이 필요할뿐 아니라, subClass 메소드가 superClass 메소드를 호출한 다음 다시 자신만의 내용을 이어갈지 여부는 구체적 상황에 따라 달라질 수밖에 없는 문제이니 이를 패턴화하기도 어려워 보입니다. 기존 생성자함수가 하던 형태를 그대로 유지하면서 Class로 전환하는 것은 가능하고 어렵지 않을 것 같지만, 반대로 ES6의 Class를 기존 방식으로 전환하는 건 어렵거나 불가능에 가까운 경우도 존재할 것 같습니다.</p>
<p>ES6는 기본적으로 하위호환성을 유지한 채로 새로운 기능을 추가하면서도 언어가 갑자기 너무 비대해지는 것은 막아야 했기에, 최대한 새로운 기능들이 기존 기능을 토대로 동작하도록 구현되었습니다. Class가 prototype 상속을 차용한 것은 이러한 <a target="_blank" rel="noopener" href="http://exploringjs.com/es6/ch_one-javascript.html#ch_one-javascript">One Javascript</a> 전략에 따르기 위한 것이었으며, 기존 문법으로는 구현할 수 없는 기능도 포함되어 있는 이상 ‘문법설탕’ 취급을 하는 것은 너무 야박한 평가가 아닌가 싶네요. ㅎㅎ</p>
<p>중간중간 모르는 내용을 근거도 없이 추측하거나 추정했을 수도 있고, 잘못된 내용을 단정적으로 확신하며 언급했을 가능성도 있을 것 같습니다. 혹시라도 틀렸거나 보충이 필요한 내용이 있다면 기탄없이 알려주시면 감사하겠습니다.</p>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/ecmascript/">ecmascript</a><a class="article__tags__item" href="/tags/javascript/">javascript</a><a class="article__tags__item" href="/tags/class/">class</a><a class="article__tags__item" href="/tags/es6/">es6</a><a class="article__tags__item" href="/tags/es2015/">es2015</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="https://www.gravatar.com/avatar/02e9f56a3202da2e6e0e36a5a23facbb" alt="Jaenam Jung"><a class="article__author__link" title="About Jaenam Jung" rel="author">Jaenam Jung</a><p class="article__author__desc">할 수 있는걸 합니다.</p><div class="article__author__socials"><a class="article__author__socials__item" href="http://github.com/roy-jung" title="github" target="_blank"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="Jaenam Jung"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><!-- Giscus Code--><script src="https://giscus.app/client.js" data-repo="roy-jung/roy-jung.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkzMDcyNDQyMDk=" data-category="General" data-category-id="DIC_kwDOElAssc4Cs9i2" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light_protanopia" data-lang="ko" data-loading="lazy" crossorigin="anonymous" async></script><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2025-04-02T11:37:01.495Z"><meta itemprop="articleBody" content="최근 모 커뮤니티에서 ‘ES6를 공부해야 할 필요는 없다’는 의견을 발견하였는데, 그 분의 견해를 읽던 중 ‘Class는 문법설탕일 뿐’이라는 내용에 대해서 정말로 그러한지 알아보고 싶은 마음이 들었습니다.


/_ 본 글은 지적 호기심에 따른 탐구과정을 의식의 흐름 기법에 따라 적어내려간 것이므로 내용전개가 매끄럽지 못할 수 있음을 미리 밝힙니다...."><meta itemprop="url" content="http://roy-jung.github.io/161007_is-class-only-a-syntactic-sugar/"><meta itemprop="mainEntityOfPage" content="http://roy-jung.github.io/161007_is-class-only-a-syntactic-sugar/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="FE재남"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="http://roy-jung.github.io/images/logo.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="http://roy-jung.github.io/images/category-es.png"><meta itemprop="url" content="http://roy-jung.github.io/images/category-es.png"><meta itemprop="width" content="200"><meta itemprop="height" content="200"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/161127_how-to-make-private-member/"><div class="related-posts__item__background" style="background-image:url('/images/category-es.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">ES6 Class에서 private member를 정의하는 방법</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/161128_es6-for-react/"><div class="related-posts__item__background" style="background-image:url('/images/category-es.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">ReactJS를 작성할 때에 알아두면 좋은 ES6 문법들</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/170110_let-vs-var-performance-compare/"><div class="related-posts__item__background" style="background-image:url('/images/category-es.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">let과 var의 성능 비교</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/250701-history-of-js/">간략한 자바스크립트 역사</a></li><li class="recent-posts__item"><a href="/iterator-helper-overview/">이터레이터 헬퍼 맛보기</a></li><li class="recent-posts__item"><a href="/250414-react-reconciliation-deep-dive/">React Reconciliation: 컴포넌트 뒤에 숨겨진 엔진</a></li><li class="recent-posts__item"><a href="/250323-react-server-components/">리액트 서버 컴포넌트 톺아보기 (번역)</a></li><li class="recent-posts__item"><a href="/211231-review-2021/">2021 회고</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">2025 7월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">2025 5월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">2025 4월</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">2022 1월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">2020 11월</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">2020 10월</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">2017 1월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">2016 12월</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">2016 11월</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">2016 10월</a><span class="archive-list-count">2</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ecmascript/">ECMAScript</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fe/">FE</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/fe/react-js/">React.js</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/fe/react-js/next-js/">Next.js</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/fe/javascript/">javascript</a><span class="category-list-count">6</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/etc/">etc</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><span class="category-list-count">1</span></li></ul></div></div></div><p class="copyright"><small>© 2025 Jaenam Jung<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>